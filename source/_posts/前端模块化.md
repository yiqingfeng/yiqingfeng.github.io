---
title: 前端模块化
categories: 每日一题
date: 2019-04-09 11:13:52
tags: 开发规范
---

> 从最开始的前后端混写，前后端分离，到现在的大型单页面应用。前端工程化经历了哪些？

<!-- more -->

### 一、JS模块化的历程

在ES5及之前，JS并没有模块这一概念。在实际多人开发过程中，为了抽离公共代码，隔离作用域、避免各个开发人员之间的变量冲突，模块化就显得十分必要。

以下JS模块的各个阶段：
- **IIFE** 使用**自执行函数**来编写模块化，特点：在一个单独的函数作用域中执行代码，避免变量冲突。
```javascript
(function(){
    return {
        data:[]
    }
})()
```
- **AMD** 使用**requireJS**来编写模块化，特点：依赖必须提前声明好。
```javascript
define('./index.js', function (code) {
	// code 就是index.js 返回的内容
})
```
- **CMD** 使用**seaJS**来编写模块化，特点：支持动态引入依赖文件。
```javascript
define(function(require, exports, module) {  
  var indexCode = require('./index.js')
})
```
- **CommonJS** nodejs 中自带的模块化。
```javascript
var fs = require('fs')
```
- **UMD** 兼容 AMD，CommonJS 模块化语法。
```javascript
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node, CommonJS之类的
        module.exports = factory(require('jquery'));
    } else {
        // 浏览器全局变量(root 即 window)
        root.returnExports = factory(root.jQuery);
    }
}(this, function ($) {
    // 方法
    function myFunc(){};
    // 暴露公共方法
    return myFunc;
}));
```
- **webpack(require.ensure)** webpack 2.x 版本中的代码分割。
- **ES Modules** ES6 引入的模块化，支持import 来引入另一个 js 。
```javascript
import a from 'a';
```

### 二、CommonJs

JavaScript最初被认为只能构建基于浏览器的应用程序，适用面狭窄。而 CommonJs API 却定义了很多普通应用程序（非浏览器）使用的 API，填补这些空白，旨在提供一个类似Python，Ruby和Java标准库。让开发者利用 CommonJS 编写的程序可以在不同的JS解析器和宿主环境中运行。


2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。
而服务器端存在与操作系统或其他应用程序之间的互动


### 二、AMD




### 相关讨论：

- https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/28

### 相关阅读

- [js模块化编程之彻底弄懂CommonJS和AMD/CMD！](https://blog.csdn.net/xixi880928/article/details/51768469)
- [模块化思维导图](https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a#outline)
- [前端中的模块化](https://blog.csdn.net/dadadeganhuo/article/details/86777249)