<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>过客的个人小站</title>
  
  <subtitle>承上启下，学而不思则罔</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yiqingfeng.github.io/"/>
  <updated>2021-01-31T16:09:39.075Z</updated>
  <id>https://yiqingfeng.github.io/</id>
  
  <author>
    <name>过客</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue.extend()和extends选项</title>
    <link href="https://yiqingfeng.github.io/2021/02/01/vue/extend/"/>
    <id>https://yiqingfeng.github.io/2021/02/01/vue/extend/</id>
    <published>2021-01-31T16:08:32.000Z</published>
    <updated>2021-01-31T16:09:39.075Z</updated>
    
    <content type="html"><![CDATA[<p>Vue.extend() 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。其中 data 属性必须是一个函数（这样每个组件的实例的 data 才能是独立的）。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = Vue.extend(&#123;</span><br><span class="line">    template: <span class="string">'&lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt;'</span>,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            text: <span class="string">'你好'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>extends 选项允许声明扩展另一个组件 (可以是一个简单的选项对象或构造函数)，而无需使用 Vue.extend。这主要是为了便于扩展单文件组件。其功能类似 mixins</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> CompA = &#123; ... &#125;</span><br><span class="line"><span class="comment">// 在没有调用 `Vue.extend` 时候继承 CompA</span></span><br><span class="line"><span class="keyword">var</span> CompB = &#123;</span><br><span class="line">  extends: CompA,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Vue.extend() 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。其中 data 属性必须是一个函数（这样每个组件的实例的 data 才能是独立的）。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight java
      
    
    </summary>
    
      <category term="学习" scheme="https://yiqingfeng.github.io/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Vue" scheme="https://yiqingfeng.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>前端·学习笔记</title>
    <link href="https://yiqingfeng.github.io/2020/12/18/fe/%E5%89%8D%E7%AB%AF%C2%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://yiqingfeng.github.io/2020/12/18/fe/前端·学习笔记/</id>
    <published>2020-12-18T09:40:01.000Z</published>
    <updated>2021-01-26T16:44:24.737Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习记录未知的事物，努力扩大自己的小圈子。（学而时习之，不亦说乎）</p></blockquote><a id="more"></a><!-- toc --><h2 id="常用小技巧"><a href="#常用小技巧" class="headerlink" title="常用小技巧"></a>常用小技巧</h2><ul><li><p><a href="https://zhuanlan.zhihu.com/p/304360774?utm_source=com.facishare.fsneice&amp;utm_medium=social&amp;utm_oi=46648013094912" target="_blank" rel="noopener">写 JS 逻辑判断，不要只知道用 if-else 和 switch - 知乎</a></p><blockquote><p><strong>小结：</strong> 可以利用键值对（object / map）处理复杂的逻辑判断，便于后续维护。【多重判断时，Map 比 Object 更加适合处理】</p></blockquote>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同身份、不同状态处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">identity, status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> actions = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">            [<span class="regexp">/^guest_[1-4]$/</span>, () =&gt; &#123;<span class="built_in">console</span>.log(<span class="string">'操作1'</span>)&#125;],</span><br><span class="line">            [<span class="regexp">/^guest_.*$/</span>, () =&gt; &#123;<span class="built_in">console</span>.log(<span class="string">'操作2'</span>)&#125;],</span><br><span class="line">            [<span class="regexp">/^master_[2-3]$/</span>, () =&gt; &#123;<span class="built_in">console</span>.log(<span class="string">'操作3'</span>)&#125;],</span><br><span class="line">            [<span class="regexp">/^master_.*$/</span>, () =&gt; &#123;<span class="built_in">console</span>.log(<span class="string">'操作4'</span>)&#125;],</span><br><span class="line">        ]);</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> curRule = <span class="string">`<span class="subst">$&#123;identity&#125;</span>_<span class="subst">$&#123;status&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [rule, action] <span class="keyword">of</span> actions.entries()) &#123;</span><br><span class="line">        <span class="comment">// 优先匹配原则</span></span><br><span class="line">        <span class="keyword">if</span> (rule.test(curRule)) &#123;</span><br><span class="line">            action.call(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>等待更多… ^ ^</p></li></ul><h2 id="对比思考"><a href="#对比思考" class="headerlink" title="对比思考"></a>对比思考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/337296578" target="_blank" rel="noopener">继承 vs 组合：哪一个更适合你的 JavaScript 项目 - 知乎</a><ul><li>小结： <ul><li>继承：子类借用父类除私有属性方法外的所有公共和受保护的属性和方法。（JavaScript 中，子对象常借用父对象的构造函数（自身新属性）和原型链上的方法）  </li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习记录未知的事物，努力扩大自己的小圈子。（学而时习之，不亦说乎）&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端" scheme="https://yiqingfeng.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="每日一学" scheme="https://yiqingfeng.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>前端CSS试题</title>
    <link href="https://yiqingfeng.github.io/2020/10/09/blog/fe-questions/%E5%89%8D%E7%AB%AFCSS%E8%AF%95%E9%A2%98/"/>
    <id>https://yiqingfeng.github.io/2020/10/09/blog/fe-questions/前端CSS试题/</id>
    <published>2020-10-09T08:13:32.000Z</published>
    <updated>2020-10-09T08:33:17.960Z</updated>
    
    <content type="html"><![CDATA[<p>收集了解前端试题，温故而知新！！！</p><a id="more"></a><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#l1">1. css盒子模型，box-sizing属性的理解</a></li><li><a href="#l2">2. 清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法</a></li><li><a href="#l3">3. 如何让一个不定宽高的盒子水平垂直居中</a></li><li><a href="#l4">4. px、em 和 rem 的区别</a></li><li><a href="#l5">5. position 各个定位的区别</a></li><li><a href="#l6">6. display:none 与 visibility：hidden 的区别</a></li><li><a href="#l7">7. CSS 中 link 和 @import 的区别</a></li><li><a href="#l8">8. 什么是响应式设计，响应式设计的基本原理是什么</a></li><li><a href="#l9">9. 为什么要初始化CSS样式</a></li><li><a href="#l10">10. CSS3有哪些新特性</a></li><li><a href="#l11">11. ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用</a></li><li><a href="#l12">12. CSS优化、提高性能的方法有哪些</a></li><li><a href="#l13">13. 重绘和回流</a></li><li><a href="#l14">14. flex 布局</a></li><li><a href="#l15">15. grid 布局</a></li><li><a href="#l16">16. css预处理器</a></li></ul><h4 id="l1">1. css盒子模型，box-sizing属性的理解</h4><p>css盒子模型：margin + border + padding + content （由外到内）</p><p><code>box-sizing: content-box(默认) | border-box | inherit;</code> 是 css3 的属性，主要是设置盒子的宽度时，是否仅包含 <code>content</code> 。</p><h4 id="l2">2. 清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法</h4><p>浮动的元素是脱离文档标准流的。如果不进行清除浮动，会造成父元素高度塌陷，影响页面的布局。</p><p><strong>清除浮动的方式：</strong></p><ul><li>给父元素设置高度。（缺点：需要提前知道父元素需要的高度）</li><li>给父元素设置 <code>overflow: hidden;</code> （BFC独立盒子）</li><li>给父元素的伪类设置 <code>clear: both;</code> （更符合语义化）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 伪类 */</span></span><br><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>BFC：</strong>（overflow: hidden 可以触发 BFC 机制）</p><p>块级格式化上下文，创建了 BFC 的元素就是一个独立的盒子，它规定了内部如何布局，并且与这个独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素，计算BFC的高度时，浮动元素也参与计算。</p></blockquote><h4 id="l3">3. 如何让一个不定宽高的盒子水平垂直居中</h4><ul><li>table-cell + text-align （不再推荐）</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>绝对定位 + 移动</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex 布局</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>grid 布局</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">justify-self</span>: center;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="l4">4. px、em 和 rem 的区别</h4><ul><li><code>px</code>: 像素，相对长度单位。像素 <code>px</code> 是相对于显示器屏幕分辨率而言的。</li><li><code>em</code> 的值并不是固定的，会继承父级元素的字体大小，代表倍数。</li><li><code>rem</code>的值并不是固定的，始终是基于根元素 <code>&lt;html&gt;</code> 的，也代表倍数。</li></ul><h4 id="l5">5. position 各个定位的区别</h4><ul><li><code>static</code>： 默认值。没有定位，元素出现在正常的流中</li><li><code>relative</code>（相对定位）：生成相对定位的元素,相对于其正常（原先本身）位置进行定位</li><li><code>absolute</code>（绝对定位）：生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位</li><li><code>fixed</code>（固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位</li><li><code>sticky</code> (粘性定位)：基于用户的滚动位置来定位，粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。</li></ul><blockquote><p>关于 <code>position: sticky;</code> 可参考，<a href="https://www.zhangxinxu.com/wordpress/2018/12/css-position-sticky/" target="_blank" rel="noopener">杀了个回马枪，还是说说position:sticky吧</a></p></blockquote><h4 id="l6">6. display:none 与 visibility：hidden 的区别</h4><table><thead><tr><th>区别</th><th>display: none;</th><th>visibility: hidden;</th></tr></thead><tbody><tr><td>是否占据空间</td><td>不占据任何空间，在文档渲染时，该元素如同不存在（但依然存在文档对象模型树中）</td><td>该元素空间依旧存在</td></tr><tr><td>是否渲染</td><td>会触发 reflow（回流），进行渲染</td><td>会触发 repaint（重绘），因为没有发现位置变化，不进行渲染</td></tr><tr><td>是否是继承属性</td><td>不是继承属性，元素及其子元素都会消失</td><td>是继承属性，若子元素使用了visibility:visible，则不继承，这个子孙元素又会显现出</td></tr></tbody></table><h4 id="l7">7. CSS 中 link 和 @import 的区别</h4><ul><li><strong>所属不同：</strong> link 属于 XHTML 标签，主要是用于定义文档与外部资源的关系，而 @import 完全是 CSS 提供的一种加载 CSS 的方式。</li><li><strong>加载顺序不同：</strong> 当页面被加载时，link 引用的 CSS 会被同时加载，而 @import 引用的 CSS 会等到页面全部被下载完成后再加载。</li><li><strong>兼容性不同（不再考虑）：</strong> @import 是 CSS 2.1 的内容。</li><li>当使用 JavaScript 控制 DOM 改变样式时，只是使用 link 的方式，无法使用 @import 。</li></ul><h4 id="l8">8. 什么是响应式设计，响应式设计的基本原理是什么</h4><p>响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p><p>基本原理是通过媒体查询检测不同的设备屏幕尺寸做对应处理。</p><h4 id="l9">9. 为什么要初始化CSS样式</h4><ul><li><strong>兼容性处理：</strong> 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。</li><li><strong>SEO：</strong> 初始化样式会对 SEO 有一定的影响</li></ul><blockquote><p><strong>补充说明：</strong></p><ul><li><code>* {padding: 0; margin: 0;}</code> 这种初始化的方式，在应用较大、css样式较多时，<code>*</code> 会将所有便签初始化一次。</li></ul></blockquote><h4 id="l10">10. CSS3有哪些新特性</h4><ul><li>实现圆角 <code>border-radius</code>，阴影 <code>box-shadow</code>，边框图片 <code>border-image</code></li><li>对文字加特效 <code>text-shadow</code>，强制文本换行 <code>word-wrap</code>，线性渐变 <code>linear-gradient</code></li><li>实现旋转 <code>transform:rotate(90deg)</code>, 缩放 <code>scale(0.85,0.90)</code>, <code>translate(0px,-30px)</code> 定位,倾斜 <code>skew(-9deg,0deg)</code>;</li><li>增加了更多的CSS选择器、多背景、<code>rgba()</code></li><li>唯一引入的伪元素是 <code>::selection</code>；</li><li>实现媒体查询 <code>@media</code>，多栏布局 <code>flex</code></li><li>过渡 <code>transition</code> 动画 <code>animation</code></li></ul><h4 id="l11">11. ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用</h4><p>单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）,双冒号是在当前规范中引入的，用于区分伪类和伪元素。</p><h4 id="l12">12. CSS优化、提高性能的方法有哪些</h4><ul><li>移除空的css规则（Remove empty rules）</li><li>正确使用 display 的属性</li><li>不滥用浮动、web字体</li><li>不声明过多的 font-size</li><li>不在选择符中使用ID标识符</li><li>遵守盒模型规则</li><li>尽量减少页面重排、重绘</li><li>抽象提取公共样式，减少代码量</li></ul><h4 id="l13">13. 重绘和回流</h4><p>回流一定会引起重绘，重绘不一定引起回流</p><p>具体请看：<a href="https://yiqingfeng.github.io/2019/06/17/2019-2/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/">浏览器的重绘和回流</a></p><h4 id="l14">14. flex弹性布局</h4><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt></p><p><strong>flex 容器的属性：</strong></p><ul><li><code>flex-direction</code> 决定主轴排列方向，默认为 <code>row</code> 水平从左至右。</li><li><code>flex-wrap</code> 决定是否换行，以及如何换行，默认为 <code>nowrap</code> 不换行。</li><li><code>flex-flow</code> 即为<code>flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</code></li><li><code>justify-content</code> 决定子元素在主轴上的对齐方式，默认为 <code>flex-start</code> 左对齐。</li><li><code>align-items</code> 决定子元素在交叉轴上的对齐方式，默认为 <code>stretch</code> 占满整个容器高度。</li><li><code>align-content</code> 决定当存在多个轴线，即子元素分多行时的对齐方式，默认为 <code>stretch</code> 子元素将占满整个容器高度。</li></ul><p><strong>flex 子元素的属性：</strong></p><ul><li><code>order</code> 决定了元素的排列顺序，默认为 0。</li><li><code>flex-grow</code> 决定子元素的放大比例，默认为 0，即存在空余空间时，也不进行放大。</li><li><code>flex-shrink</code> 决定子元素的缩小比例，默认为 1，该属性不能设置为负值。</li><li><code>flex-basis</code> 决定分配多余空间前，子元素占据的主轴空间，默认为 <code>auto</code>，即元素的本身大小。</li><li><code>flex</code> 即为 <code>flex: &lt;flex-grow&gt; &lt;flex-shrink&gt;? || &lt;flex-basis&gt; ]</code>，该属性可以简写为 <code>auto (1 1 auto)</code> 和 <code>none (0 0 auto)</code></li><li><code>align-self</code> 元素的对齐方式，默认为 <code>auto</code>，表示继承父元素的 <code>align-items</code> 属性</li></ul><blockquote><p>注意：</p><p>设置为 <code>Flex</code> 布局后，子元素的 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 属性将失效。</p></blockquote><p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">flex布局教程–阮一峰</a></p><h4 id="l15">15. grid 网格布局</h4><p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">Grid网格布局教程–阮一峰</a></p><h4 id="l16">16. css预处理器</h4><ul><li>less</li><li>sass</li><li>postcss</li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;收集了解前端试题，温故而知新！！！&lt;/p&gt;
    
    </summary>
    
      <category term="前端面试" scheme="https://yiqingfeng.github.io/categories/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="CSS" scheme="https://yiqingfeng.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>Vuex 状态管理</title>
    <link href="https://yiqingfeng.github.io/2020/06/28/2018/vuex/"/>
    <id>https://yiqingfeng.github.io/2020/06/28/2018/vuex/</id>
    <published>2020-06-28T05:52:34.379Z</published>
    <updated>2020-06-28T05:52:34.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前端组件化开发中，一般情况下都是采用单向数据流的方式。即 state -&gt; view -&gt; action -&gt; state。这种方式在多视图情况下，<br>常会涉及多组件之间通信（数据共享）。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://vuex.vuejs.org/zh-cn/mutations.html" target="_blank" rel="noopener">Vuex 手册</a></li></ul><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="state-单一状态树"><a href="#state-单一状态树" class="headerlink" title="state (单一状态树)"></a>state (单一状态树)</h3><p>即利用一个对象包含全部应用的数据源。</p><h5 id="结合vue："><a href="#结合vue：" class="headerlink" title="结合vue："></a>结合vue：</h5><ul><li>在vue中，可以利用计算属性来返回某个状态。这样每当状态发生变动时，都会重新计算。不过这种方式会导致组件依赖全局状态单例，同时每个需要state的组件都需频繁导入。</li><li>利用 vuex 将 store 从根组件“注入”到每一个子组件中。这样子组件就能通过 <code>this.$store</code>访问。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    store, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span><br><span class="line">    components,</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>tips:</strong><br>单一组件涉及到多个状态，可以利用<code>mapState</code>辅助函数减少计算属性的重复和冗余。<br>不必要的局部状态最好还是作为组件的一部分。需依据开发进行权衡和确认。</p></blockquote><h3 id="Getter-（vuex的“计算属性”）"><a href="#Getter-（vuex的“计算属性”）" class="headerlink" title="Getter （vuex的“计算属性”）"></a>Getter （vuex的“计算属性”）</h3><p>合理的利用 Vuex 的 Getter 能更加方便地访问满足条件的state，尤其是列表的 state。</p><blockquote><p><strong>tips:</strong><br>可以利用 Getter 返回一个函数实现传参。（柯里化）<br>可以利用 mapGetters 辅助函数来对 Getter 建立一个别名。（感觉用处不是很大）</p></blockquote><h3 id="Mutation-（类似事件）"><a href="#Mutation-（类似事件）" class="headerlink" title="Mutation （类似事件）"></a>Mutation （类似事件）</h3><p>在 Vuex 中更改 state 的唯一方式就是提交 mutation。每个 mutation 都有一个字符串的<strong>事件类型 (type)</strong>和 一个<strong>回调函数 (handler)</strong>。当然不能直接调用一个 mutation handler。要唤醒一个 mutation 可以调用<code>store.commit(type)</code>。 </p><p>mutation 必须是同步函数。（同步事务）</p><blockquote><p><strong>tips:</strong><br>可以向<code>store.commit</code>传入额外的参数实现提交荷载（payload），但是大多数情况下，荷载应该是一个对象，这样既可以包含多个字段，同时也会使得 mutation 更易读。<br>对象风格的提交方式: 提交 mutation 的另一种方式是直接使用包含 type 属性的对象。即<code>store.commit({ type: &#39;increment&#39; })</code>。这样整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变。<br>使用常量替代 mutation 事件类型，能在多人合作时，使得合作者对整个 app 的 mutation 一目了然。<br>在组件中提交 mutation 时，可以使用<code>mapMutations</code>辅助函数将组件中的方法<code>methods</code>映射为<code>store.commit</code>。</p></blockquote><h3 id="Action-支持异步提交"><a href="#Action-支持异步提交" class="headerlink" title="Action (支持异步提交)"></a>Action (支持异步提交)</h3><p>action提交的是 mutation ，并非直接变更状态。</p><p>其中 action 会接受一个与 store 实例具有相同方法和属性的 context 对象。当然 action 和 mutation 一样都不能直接操作，需要通过 <code>store.dispatch</code> 触发。</p><blockquote><p><strong>tips:</strong><br>actions 支持同样的载荷方式和对象方式进行分发。<br>在组件中分发 action 时，可以使用<code>mapActions</code>辅助函数将组件中的方法<code>methods</code>映射为<code>store.dispatch</code>。<br>注意：组合 action 时，可以利用 promise、action内部调用，以及 async / await 的方式。</p></blockquote><h3 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module (模块)"></a>Module (模块)</h3><p>由于整个应用使用的是同一个状态树，当应用过于复杂时，store 对象就会相当臃肿。 vuex中提供 module 将 store 进行分割，每个 module 都拥有自己的 state、getter、mutation、action，甚至是嵌套子模块。</p><p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。对于模块内部的 getter，根节点状态会作为第三个参数暴露出来。同样对于模块内部的 action，局部状态通过<code>context.state</code>暴露出来，根节点状态则为<code>context.rootState</code>。</p><blockquote><p><strong>命名空间：</strong><br>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。<br>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为命名空间模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p></blockquote><p>模块可以进行动态创建。例如 vuex-router-sync 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在前端组件化开发中，一般情况下都是采用单向数据流的方式。即 state -&amp;gt; view -&amp;gt; action -&amp;gt; stat
      
    
    </summary>
    
      <category term="前端开发框架+库" scheme="https://yiqingfeng.github.io/categories/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6-%E5%BA%93/"/>
    
    
      <category term="VUE" scheme="https://yiqingfeng.github.io/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>2020-06-17</title>
    <link href="https://yiqingfeng.github.io/2020/06/17/fe-daily/2020-06-17/"/>
    <id>https://yiqingfeng.github.io/2020/06/17/fe-daily/2020-06-17/</id>
    <published>2020-06-17T09:22:24.000Z</published>
    <updated>2020-06-28T05:52:34.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="每日学习一点小知识："><a href="#每日学习一点小知识：" class="headerlink" title="每日学习一点小知识："></a>每日学习一点小知识：</h2><ul><li>[html] <a href="https://github.com/haizlin/fe-interview/issues/2524" target="_blank" rel="noopener">websocket是如何做心跳检测、数据加密、身份验证的？</a></li><li>[css] <a href="https://github.com/haizlin/fe-interview/issues/2525" target="_blank" rel="noopener">使用css如何设置背景虚化？</a></li><li>[js] <a href="https://github.com/haizlin/fe-interview/issues/2526" target="_blank" rel="noopener">js源代码压缩都有哪些方法？它们的压缩原理分别是什么？</a></li><li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/2527" target="_blank" rel="noopener">对于用户的隐私你是如何看待的？</a></li></ul><a id="more"></a><h2 id="使用-css3-实现背景虚化"><a href="#使用-css3-实现背景虚化" class="headerlink" title="使用 css3 实现背景虚化"></a>使用 css3 实现背景虚化</h2><p>假设现在存在这样一个场景：产品需要你将某一宣传页面背景图片虚化，但是宣传内容不能受影响，如何处理？</p><p>对应的页面结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"p-header"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"hd-content"</span>&gt;</span>这是我的相关内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.p-header</span> &#123;</span><br><span class="line"><span class="attribute">background</span>: <span class="built_in">url</span>(./test.jpg) center/cover no-repeat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hd-content</span> &#123;</span><br><span class="line"><span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line"><span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h3><ul><li>利用 CSS3 blur 滤镜 <code>filter: blur(1px);</code></li><li>利用 SVG 滤镜</li><li>利用 canvas 进行图片转换</li></ul><blockquote><p>参考文章：</p><ul><li><a href="https://www.zhangxinxu.com/wordpress/2013/11/css-svg-image-blur/" target="_blank" rel="noopener">小tip: 使用CSS将图片转换成模糊(毛玻璃)效果</a></li><li><a href="https://juejin.im/post/5bcc0367e51d453c4655e83c" target="_blank" rel="noopener">CSS设置背景模糊</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;每日学习一点小知识：&quot;&gt;&lt;a href=&quot;#每日学习一点小知识：&quot; class=&quot;headerlink&quot; title=&quot;每日学习一点小知识：&quot;&gt;&lt;/a&gt;每日学习一点小知识：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;[html] &lt;a href=&quot;https://github.com/haizlin/fe-interview/issues/2524&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;websocket是如何做心跳检测、数据加密、身份验证的？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[css] &lt;a href=&quot;https://github.com/haizlin/fe-interview/issues/2525&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用css如何设置背景虚化？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[js] &lt;a href=&quot;https://github.com/haizlin/fe-interview/issues/2526&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;js源代码压缩都有哪些方法？它们的压缩原理分别是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[软技能] &lt;a href=&quot;https://github.com/haizlin/fe-interview/issues/2527&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对于用户的隐私你是如何看待的？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="每日学习" scheme="https://yiqingfeng.github.io/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="css" scheme="https://yiqingfeng.github.io/tags/css/"/>
    
      <category term="html" scheme="https://yiqingfeng.github.io/tags/html/"/>
    
      <category term="js" scheme="https://yiqingfeng.github.io/tags/js/"/>
    
      <category term="软技能" scheme="https://yiqingfeng.github.io/tags/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>2020-06-16</title>
    <link href="https://yiqingfeng.github.io/2020/06/16/fe-daily/2020-06-16/"/>
    <id>https://yiqingfeng.github.io/2020/06/16/fe-daily/2020-06-16/</id>
    <published>2020-06-16T06:59:50.000Z</published>
    <updated>2020-06-28T05:52:34.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="每日学习一点小知识："><a href="#每日学习一点小知识：" class="headerlink" title="每日学习一点小知识："></a>每日学习一点小知识：</h2><ul><li>[html] <a href="https://github.com/haizlin/fe-interview/issues/2520" target="_blank" rel="noopener">http 和 websocket 能共用一个端口吗？为什么？</a></li><li>[css] <a href="https://github.com/haizlin/fe-interview/issues/2521" target="_blank" rel="noopener">举例说明background-repeat的新属性值：round和space的作用是什么？</a></li><li>[js] <a href="https://github.com/haizlin/fe-interview/issues/2522" target="_blank" rel="noopener">不用 + eval Function 实现加法</a></li><li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/2523" target="_blank" rel="noopener">让你去重构一个很老旧但很重要的系统，你的方法论是什么？</a></li></ul><a id="more"></a><h2 id="http-和-websocket-能共用一个端口吗？为什么？"><a href="#http-和-websocket-能共用一个端口吗？为什么？" class="headerlink" title="http 和 websocket 能共用一个端口吗？为什么？"></a>http 和 websocket 能共用一个端口吗？为什么？</h2><p>先说结论，<strong>YES！</strong> http 可以和 WebSocket 共用同一个端口。</p><p>http 和 WebSocket 都是应用层的协议。而端口是写在传输层协议上的，无论是 http 还是 WebSocket 都是基于 TCP 协议的。具体一点的话，可以理解为当客户端和服务器通信时会通过双方的 IP 和端口形成一条通信管道（抽象就是双方按照给定地址发送信息包给对方），在这条通信管道中会根据需要创建 N 个 TCP 连接，这些连接有的是用 http 协议，有的是用 WebSocket。</p><p><strong>使用 Node.js 实现 http 和 WebSocket 共用同一个端口：</strong></p><h2 id="举例说明background-repeat的新属性值：round和space的作用是什么？"><a href="#举例说明background-repeat的新属性值：round和space的作用是什么？" class="headerlink" title="举例说明background-repeat的新属性值：round和space的作用是什么？"></a>举例说明background-repeat的新属性值：round和space的作用是什么？</h2><h2 id="不用-eval-Function-实现加法"><a href="#不用-eval-Function-实现加法" class="headerlink" title="不用 + eval Function 实现加法"></a>不用 + eval Function 实现加法</h2><h2 id="让你去重构一个很老旧但很重要的系统，你的方法论是什么？"><a href="#让你去重构一个很老旧但很重要的系统，你的方法论是什么？" class="headerlink" title="让你去重构一个很老旧但很重要的系统，你的方法论是什么？"></a>让你去重构一个很老旧但很重要的系统，你的方法论是什么？</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;每日学习一点小知识：&quot;&gt;&lt;a href=&quot;#每日学习一点小知识：&quot; class=&quot;headerlink&quot; title=&quot;每日学习一点小知识：&quot;&gt;&lt;/a&gt;每日学习一点小知识：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;[html] &lt;a href=&quot;https://github.com/haizlin/fe-interview/issues/2520&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http 和 websocket 能共用一个端口吗？为什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[css] &lt;a href=&quot;https://github.com/haizlin/fe-interview/issues/2521&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;举例说明background-repeat的新属性值：round和space的作用是什么？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[js] &lt;a href=&quot;https://github.com/haizlin/fe-interview/issues/2522&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;不用 + eval Function 实现加法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[软技能] &lt;a href=&quot;https://github.com/haizlin/fe-interview/issues/2523&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;让你去重构一个很老旧但很重要的系统，你的方法论是什么？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="每日学习" scheme="https://yiqingfeng.github.io/categories/%E6%AF%8F%E6%97%A5%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="css" scheme="https://yiqingfeng.github.io/tags/css/"/>
    
      <category term="html" scheme="https://yiqingfeng.github.io/tags/html/"/>
    
      <category term="js" scheme="https://yiqingfeng.github.io/tags/js/"/>
    
      <category term="软技能" scheme="https://yiqingfeng.github.io/tags/%E8%BD%AF%E6%8A%80%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript学习笔记·2</title>
    <link href="https://yiqingfeng.github.io/2020/04/21/2020/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B72/"/>
    <id>https://yiqingfeng.github.io/2020/04/21/2020/TypeScript学习笔记·2/</id>
    <published>2020-04-21T09:28:52.000Z</published>
    <updated>2020-06-28T05:52:34.391Z</updated>
    
    <content type="html"><![CDATA[<p>了解 TypeScript 并加以使用，可以帮助我们提高代码的质量。本文主要是对官方文档上的内容进行个人理解后的知识收集，想了解更详细内容，推荐 <a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener">TypeScript官网</a>。</p><blockquote><p><strong>tip:</strong> 在学习了解 TypeScript 的内容时，最好自己去实践一下。</p></blockquote><a id="more"></a><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>在软件程序开发设计中，为了提高程序有较好的可读性和健壮性，会将相似的逻辑进行集中统一处理，构建可复用的组件。同理在 TypeScript 中，我们可以利用 <code>泛型</code> 创建可重用的组件/数据类型等。</p><p>在 TypeScript 中，泛型支持：</p><ul><li>泛型函数</li><li>泛型接口</li><li>泛型类</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line">let myIdentity: GenericIdentityFn&lt;number&gt; = identity;</span><br><span class="line">identity(1);</span><br><span class="line">identity(&apos;a&apos;);</span><br><span class="line">myIdentity(1);</span><br><span class="line">// myIdentity(&apos;a&apos;); // error!</span><br><span class="line"></span><br><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: (x: T, y: T) =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line">let myGenericNumber = new GenericNumber&lt;number&gt;();</span><br><span class="line">myGenericNumber.zeroValue = 1;</span><br><span class="line">// myGenericNumber.zeroValue = &apos;a&apos;; // error!</span><br></pre></td></tr></table></figure><h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>虽然在使用 <code>泛型</code> 中，如果我们知道要操作的数据具有那些属性，并希望进行相应操作的话，需要对类型变量 T 进行约束。这种情况下，可以通过定义一个接口来描述约束条件，并利用这个接口和 <code>extends</code> 关键字实现约束。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);  // Error: T doesn&apos;t have .length</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Lengthwise &#123;</span><br><span class="line">    length: number;</span><br><span class="line">&#125;</span><br><span class="line">function loggingIdentity2&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);  // Now we know it has a .length property, so no more error</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line">loggingIdentity(&#123;length: 10, value: 3&#125;); // ok</span><br><span class="line">loggingIdentity2(3); // error</span><br></pre></td></tr></table></figure><!--可以传入任意类型数据，但是如果操作了 `泛型` 类型变量的属性防范--><blockquote><p><strong>注意：</strong></p><ul><li>声明的泛型类型参数，可以被另一个类型参数所约束，例如下面获取对象属性的实例中，key</li></ul></blockquote><p>待补充<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getProperty(obj: T, key: K) &#123;</span><br><span class="line">    return obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;</span><br><span class="line"></span><br><span class="line">getProperty(x, &quot;a&quot;); // okay</span><br><span class="line">getProperty(x, &quot;m&quot;); // error: Argument of type &apos;m&apos; isn&apos;t assignable to &apos;a&apos; | &apos;b&apos; | &apos;c&apos; | &apos;d&apos;.</span><br></pre></td></tr></table></figure></p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>在编程过程中，为了便于代码阅读和后续维护。我们可以使用枚举清晰地表达意图，与其他内容加以区分。</p><p>TypeScript 支持数字和基于字符串的枚举。使用的时候可以通过访问枚举的属性/名字访问枚举成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 数字枚举</span><br><span class="line">enum Direction &#123;</span><br><span class="line">Up = 1,</span><br><span class="line">Down,// 等价于 Down = 2</span><br><span class="line">Left = 10,</span><br><span class="line">Right,// 等价于 Right = 11</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const test = 12;</span><br><span class="line">enum E &#123;</span><br><span class="line">A = test,</span><br><span class="line">B, // error: Enum member must have initializer. 即常量成员不允许紧随计算的成员</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 字符串枚举</span><br><span class="line">enum Direction &#123;</span><br><span class="line">    Up = &quot;UP&quot;,</span><br><span class="line">    Down = &quot;DOWN&quot;,</span><br><span class="line">    Left = &quot;LEFT&quot;,</span><br><span class="line">    Right = &quot;RIGHT&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>需要注意的是：</strong></p><ul><li>数字枚举中，第一个成员默认为 0。其中未赋值的成员相对于之前有值的成员 <strong>自增长</strong>。</li><li>如果在数字枚举中，利用计算的或者常量成员时，不允许不带初始化器的枚举（在正常的枚举里，没有初始化方法的成员被当成 <strong>常数成员</strong>）置于其后。</li><li>与数字枚举不同的是，字符串枚举没有 <strong>自增长行为</strong>。</li><li>在使用枚举的过程中，不建议使用 <strong>异构枚举</strong>（即混合数字和字符串的枚举）。</li><li>枚举不同于接口，枚举是在 <strong>运行时真正存在的对象</strong>。</li><li>在枚举中，除了可以通过枚举成员的名字去访问对应的枚举值，也能够通过枚举值 <strong>反向映射</strong> 到枚举名字。这是因为枚举类型会被编译成一个包含正向映射（name -&gt; value）和反向映射（value -&gt; name）的对象。</li><li>在枚举上使用 <code>const</code> 修饰符的话，可以声明 <strong>常量枚举</strong>。常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</li><li>多文件模块中，对于外部已经存在枚举，可以使用 <strong>外部枚举</strong> 用于描述已存在的枚举类型。</li></ul></blockquote><h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>在 TypeScript 中，对于没有明确指明类型的地方，类型推论会帮助提供类型。</p><p>在类型推论过程中，如果需要从表达式中推断类型，TypeScript 会使用这些表达式来推断出一个 <strong>最佳通用类型</strong>。除了表达式外，TypeScript类型推论也可能按照 <strong>上下文</strong> 进行推论。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let x = &apos;2&apos;; // x 被推断为字符串</span><br><span class="line">let y: string = x + 1; // OK！ x 为字符串，计算后的结果也是字符串</span><br><span class="line"></span><br><span class="line">let zoo = [new Rhino(), new Elephant(), new Snake()]; // zoo 没有找到最佳通用类型，被推断为联合数组类型 (Rhino | Elephant | Snake)[]</span><br></pre></td></tr></table></figure><blockquote><p>备注：</p><p>此处的内容理解得不是很清楚，感觉就是在说 TypeScript 会推论没有声明数据类型的地方，然后进行数据类型校验。</p></blockquote><h3 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h3><p><strong>结构类型</strong> 是一种只使用其成员描述类型的方式。TypeScript 使用结构类型系统的方式来描述。</p><p>TypeScript结构化类型系统的基本规则是：</p><ul><li>如果 <code>x</code> 要兼容 <code>y</code>，那么 <code>y</code> 至少具有与 <code>x</code> 相同的属性。</li><li>当比较两个函数 <code>x</code> 和 <code>y</code> 时，首先会检查它们的参数列表，<code>x</code> 的每个参数必须能在 <code>y</code> 中找到对应类型的参数。（比较时只看类型不看参数名称，具体可看示例2）</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">interface Name &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p: Name;</span><br><span class="line">p = new Person(); // ok</span><br><span class="line"></span><br><span class="line">let y = &#123; name: &apos;Alice&apos;, location: &apos;Seattle&apos; &#125;;</span><br><span class="line">p = y; // ok, 这个比较过程是递归进行的，检查每个成员及子成员</span><br></pre></td></tr></table></figure><p>示例2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let x = (a: number) =&gt; 0;</span><br><span class="line">let y = (b: number, s: string) =&gt; 0;</span><br><span class="line"></span><br><span class="line">y = x; // OK</span><br><span class="line">x = y; // Error</span><br></pre></td></tr></table></figure><h3 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h3><p>常用的高级类型有：</p><ul><li>交叉类型</li><li>联合类型</li><li>枚举类型</li><li><code>this</code>类型（在接口、类中，声明 <code>this</code> 返回，可用于链式调用场景）</li><li>索引类型</li></ul><h4 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h4><p>在 TypeScript 中，交叉类型用于将多个类型合并为一个类型，使其包含所有类型的特性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 交叉类型</span><br><span class="line">function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123;</span><br><span class="line">    let result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">    for (let id in first) &#123;</span><br><span class="line">        (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    for (let id in second) &#123;</span><br><span class="line">        if (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">            (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor(public name: string) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Loggable &#123;</span><br><span class="line">    log(): void;</span><br><span class="line">&#125;</span><br><span class="line">class ConsoleLogger implements Loggable &#123;</span><br><span class="line">    log() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var jim = extend(new Person(&quot;Jim&quot;), new ConsoleLogger());</span><br><span class="line">console.log(jim.name);</span><br><span class="line">jim.log();</span><br></pre></td></tr></table></figure><h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><p>联合类型在使用上不同于交叉类型，其常用于表示一个值可以是多种类型之一。使用 <code>|</code> 分隔每个类型。如果一个值是联合类型，访问时只能访问此联合类型中所有类型的共有成员。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class UnionType &#123;</span><br><span class="line">constructor (public type: string | number) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">let ut: UnionType;</span><br><span class="line">ut = new UnionType(&apos;hello&apos;);</span><br><span class="line">ut.type.slice(1); // error</span><br><span class="line"></span><br><span class="line">(&lt;string&gt;ut.type).slice(1);</span><br><span class="line"></span><br><span class="line">function isString (type: string | number): type is string &#123;</span><br><span class="line">return (&lt;string&gt; type).slice !== undefined;</span><br><span class="line">&#125;</span><br><span class="line">if (isString(ut.type)) &#123;</span><br><span class="line">ut.type.slice(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (typeof ut.type === &apos;string&apos;) &#123;</span><br><span class="line">ut.type.slice(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于在联合类型中，希望访问该类型特有的成员，可以使用一下几种方法：</p><ul><li>如果明确知道了联合类型的具体类型，可以使用类型断言。</li><li>可以使用类型谓词，谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</li><li><code>typeof</code> 类型保护：在 TypeScript 中，<code>typeof</code> 能被识别为一个类型保护。只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>， <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</li><li><code>instanceof</code> 类型保护：类似于 <code>typeof</code>类型保护，TypeScript 会将其细化为其构造签名。</li></ul></blockquote><h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p><blockquote><p>个人感受：</p><p>类型别名最好配合联合类型或是交叉类型使用。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type Name = string;</span><br><span class="line">type NameResolver = () =&gt; string;</span><br><span class="line">type NameOrResolver = nu | NameResolver;</span><br></pre></td></tr></table></figure><blockquote><p>类型别名和接口区别：</p><ul><li>接口创建了新名称，可以在其它任何地方使用，而类型别名并没有创建新名字。</li><li>类型别名不能被 extends和 implements</li><li>接口不能用来描述一个联合类型或是元组类型</li></ul></blockquote><h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p>在 TypeScript 中可以通过，<strong>索引类型查询</strong> （<code>keyof T</code>） 和 <strong>索引访问 操作符</strong>（<code>T[K]</code>）进行类型判断处理。</p><blockquote><p>新版本貌似去掉了 keyof 关键词</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] &#123;</span><br><span class="line">  return names.map(n =&gt; o[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">let person: Person = &#123;</span><br><span class="line">    name: &apos;Jarid&apos;,</span><br><span class="line">    age: 35</span><br><span class="line">&#125;;</span><br><span class="line">let strings: string[] = pluck(person, [&apos;name&apos;]); // ok, string[]</span><br></pre></td></tr></table></figure><h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p>自 ECMAScript 2015 起，<code>symbol</code> 成为了一种新的原生类型，就像 <code>number</code> 和 <code>string</code> 一样。</p><p>Symbols 是不可改变且唯一的。同时 Symbols 也可以用做对象的键值。在 ECMAScript 目前无私有属性的情况，下也用于定义私有属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let sym2 = Symbol(&quot;key&quot;);</span><br><span class="line">let sym3 = Symbol(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">sym2 === sym3; // false, symbols是唯一的</span><br><span class="line"></span><br><span class="line">const name = Symbol()</span><br></pre></td></tr></table></figure><p>事实上，除了用户自定义的 symbol，语言内部也内置了一些 symbol 行为。其中 <code>for..of</code> 会遍历可迭代的对象，调用对象上的 <code>Symbol.iterator</code> 方法。</p><blockquote><p>需要注意的是：</p><p>当生成目标为ES5或ES3，迭代器只允许在Array类型上使用。 在非数组值上使用 for..of语句会得到一个错误，就算这些非数组值已经实现了Symbol.iterator属性。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解 TypeScript 并加以使用，可以帮助我们提高代码的质量。本文主要是对官方文档上的内容进行个人理解后的知识收集，想了解更详细内容，推荐 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TypeScript官网&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;tip:&lt;/strong&gt; 在学习了解 TypeScript 的内容时，最好自己去实践一下。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端工具" scheme="https://yiqingfeng.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="TypeScript" scheme="https://yiqingfeng.github.io/tags/TypeScript/"/>
    
      <category term="Tools" scheme="https://yiqingfeng.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript学习笔记·1</title>
    <link href="https://yiqingfeng.github.io/2020/04/07/2020/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B71/"/>
    <id>https://yiqingfeng.github.io/2020/04/07/2020/TypeScript学习笔记·1/</id>
    <published>2020-04-07T10:08:30.000Z</published>
    <updated>2020-06-28T05:52:34.389Z</updated>
    
    <content type="html"><![CDATA[<p>了解 TypeScript 并加以使用，可以帮助我们提高代码的质量。本文主要是对官方文档上的内容进行个人理解后的知识收集，想了解更详细内容，推荐 <a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener">TypeScript官网</a>。</p><blockquote><p><strong>tip:</strong> 在学习了解 TypeScript 的内容时，最好自己去实践一下。</p></blockquote><a id="more"></a><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>在 TS 中，需要使用变量时，最好提前说明变量的类型。目前支持的类型有：</p><ul><li><strong>布尔值</strong> <code>let isBoolean: boolean = true;</code></li><li><strong>数字</strong> <code>let maxNum: number = 10;</code> (除了10进制外，还支持16进制、2进制和8进制字面量)</li><li><strong>字符串</strong> <code>let name: string = &#39;nimo&#39;;</code></li><li><strong>数组</strong> <code>let arr: number[] = [1, 2, 3];</code> 或 <code>let arr: Array&lt;number&gt; = [1, 2, 3]</code>;</li><li><strong>元组 Tuple</strong>：表示一个已知元素数量和类型的数组。 <code>let arr1: [string, number] = [&#39;hi&#39;, 12];</code> （当访问元组的元素超过预设边界时，该元素的类型会变为一个联合类型）</li><li><p><strong>枚举 Enum</strong>: 更为友好的赋值。</p>  <figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enmu Color &#123;Red, Green, Blue&#125;;</span><br><span class="line"><span class="keyword">let</span> bookColor: Color = Color.Green;</span><br><span class="line"><span class="comment">// 等价于 let bookColor: Color = Color[1];</span></span><br></pre></td></tr></table></figure></li><li><p><strong>Any</strong>: 任意类型，主要在编程无法确认变量类型的情况下，支持动态设置。 <code>let resData: any = response.data;</code></p></li><li><strong>Void</strong>: 空类型，常用于无返回值的函数。<code>function warn(): void {}</code></li><li><strong>Null &amp; Undefined</strong>: 在 <code>--strictNullChecks</code> 模式下，它们只能被赋值给自己和 <code>void</code>。</li><li><strong>Never</strong>：表示永不存值，常用于会抛出异常或根本不存在返回值的函数表达式或者箭头函数  <code>const error: Function = function (msg): never { throw new Error(msg); }; };</code></li><li><strong>Object</strong>: 非原始类型，即 number，string，boolean，symbol，null 或 undefined 之外的类型。</li><li><strong>类型断言</strong>：对于明确了解的值的类型，可以使用类型断言进行类型转换，但不进行特殊数据检查和解构，它只会在编译阶段有效。其方式有：</li></ul><blockquote><ul><li>“尖括号”:</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let data: any = &apos;string&apos;;</span><br><span class="line">let len: number = (&lt;string&gt;data).length;</span><br></pre></td></tr></table></figure><blockquote><ul><li>“as 语法”：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let data: any = &apos;string&apos;;</span><br><span class="line">let len: number = (data as string).length;</span><br></pre></td></tr></table></figure><blockquote><p>在 TypeScript 中，可以将数组设置为只读，其效果与数组泛型 <code>Array&lt;Type&gt;</code> 相似，只是去掉了所有可变的方法，确保数组创建后不能被修改。 eg. <code>let arr: ReadonlyArray&lt;number&gt; = [1, 2, 3, 4];</code></p></blockquote><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>在 <code>ECMAScript</code> 中， <code>var</code> 变量声明的方式，作用于函数作用域，存在变量提升，同时容易引起误解。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量提升、函数作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params">hasInit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasInit) &#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">getX(<span class="literal">true</span>); <span class="comment">// undefined</span></span><br><span class="line">getX(<span class="literal">false</span>); <span class="comment">// 10</span></span><br><span class="line">x <span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同一函数作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">100</span> * i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果并非我们期待的：0 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure><h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p><code>let</code> 是 <strong>块级作用域</strong>（也叫词法作用域），在区块之外是不能访问的，同时也不能在声明之前进行读写操作（即虽然声明的变量始终存在于区块内，但是在声明前的代码区块都是属于 <strong>“暂时性死区”</strong>）。</p><p>在使用 <code>let</code> 的过程中，不能像 <code>var</code> 一样，使用 <code>let</code> 声明一个变量多次，也不能同时 <code>let</code> 和 <code>var</code> 声明同一个变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// let x = x; // Uncaught SyntaxError: Identifier 'x' has already been declared</span></span><br><span class="line">    <span class="comment">// console.log(a); // Uncaught ReferenceError: Cannot access 'a' before initialization</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> b = x * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// console.log(b); // Uncaught ReferenceError: b is not defined</span></span><br><span class="line">    <span class="comment">// let a = 10; // Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br><span class="line">    <span class="comment">// var a = 20; // Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果在嵌套的块级作用域，在不同的块级中，<code>let</code> 声明同名变量的话，内层的变量会 <strong>屏蔽</strong> 之前的变量。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let sum = 0;</span><br><span class="line">for (let i = 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">    let currentRow = matrix[i];</span><br><span class="line">    for (let i = 0; i &lt; currentRow.length; i++) &#123;</span><br><span class="line">        sum += currentRow[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p><code>const</code> 类似于 <code>let</code>，不同之处在于 <code>const</code> 声明的变量被赋值后就不能再改变。实际上 const 变量内部状态是可以修改的。</p><p>在 <code>typeScript</code> 中，请尽量使用 <code>let</code> 和 <code>const</code> 替代 <code>var</code> 。这样更容易推测数据的流动。</p><blockquote><p>除了 <code>let</code> 和 <code>const</code> 变量声明，<code>typescript</code> 还支持 ES6 语法中的，解析运算符和拓展运算符，支持 数组解构、对象解构 </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 数组解构 */</span></span><br><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// [ 2, 3, 4 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对象解构 */</span></span><br><span class="line"><span class="keyword">let</span> &#123; a, ...restObj &#125; = &#123; <span class="attr">a</span>: <span class="string">'bax'</span>, <span class="attr">b</span>: <span class="number">101</span>, <span class="attr">c</span>: <span class="number">12</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 属性重命名 */</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: s1, <span class="attr">b</span>: s2&#125;: &#123;<span class="attr">a</span>: string, <span class="attr">b</span>: number&#125; = &#123;<span class="attr">a</span>: <span class="string">'1'</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(s1); <span class="comment">// '1'</span></span><br><span class="line"><span class="built_in">console</span>.log(s2); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>Waring</strong>：在进行没有声明的对象赋值时，需要用括号包起来，因为在 JavaScript 通常将 <code>{</code> 解析为一个块。eg. <code>({a, b} =  { a: &#39;bax&#39;, b: 101, c: 12 });</code> </p></blockquote><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是 TypeScript 的核心之一，是一种额外的类型，主要用于结构类型检查，为这些类型命名和项目代码或第三方代码定义契约。</p><p>在使用接口过程中：1、可以通过在属性后添加 <code>?</code> 设置属性为可选。2、可以在属性名前用  <code>readonly</code> 来指定只读。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    x: number; // 必须属性</span><br><span class="line">    title?: string; // 可选属性</span><br><span class="line">    readonly y: number; // 只读属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在 TypeScript 类型检查中，存在 <strong>额外的属性检查</strong>。即如果传入的参数存在接口声明中不存在的属性，TypeScript 就会报错。</p><ul><li>如果想要绕开这些检查，最简单的方法就是 <strong>使用类型断言</strong>。</li><li>如果一个对象上可能存在任意数量的其他属性，最佳的方法就是添加 <strong>字符串索引签名</strong>。</li><li>如果将对象赋值给变量，通过变量的方式传递参数，也不会经过额外属性检查。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    x: number;</span><br><span class="line">    y: number;</span><br><span class="line">    [propName: string]: any; // 利用字符串索引签名支持其他属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSquare (config: Point): &#123; area: number &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">let mySquare = createSquare(&#123;width: 10, x: 1, y: 2&#125; as Point); // 利用类型断言绕开检查</span><br><span class="line">let data = &#123;width: 10, x: 1, y: 2&#125;;</span><br><span class="line">let mySquare2 = createSquare(data);</span><br></pre></td></tr></table></figure><p>接口可以描述变量和参数，也可以用于描述函数的类型和类的类型。<br>除了变量、参数的类型检查外，接口 也常用于描述 函数 和 类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">interface isAdultFunc &#123;</span><br><span class="line">    (ages: number): boolean;</span><br><span class="line">&#125;</span><br><span class="line">let mySearch: SearchFunc = function (ages) &#123;</span><br><span class="line">    return ages &gt;= 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    setTime(d: Date): void;</span><br><span class="line">&#125;</span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    setTime(d: Date) &#123;</span><br><span class="line">        this.currentTime = d;</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和类一样，接口也是能相互继承的。一个接口可以继承多个接口，这样可以更加灵活地分割到可重用的模块中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">    color: string;</span><br><span class="line">&#125;</span><br><span class="line">interface PenStroke &#123;</span><br><span class="line">    penWidth: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Square extends Shape, PenStroke &#123;</span><br><span class="line">    sideLength: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口除了继承接口外，接口还可以继承类。接口继承类时，会继承类的成员但不包括其实现。就好像是声明了继承类中存在的成员，但不提供具体实现一样。（不建议这么使用，因为接口继承类时，也会继承类的 <code>private</code>  和 <code>protected</code> 成员，这也就意味着当你创建的接口击沉那个了一个拥有私有或者受保护的成员的类时，这个接口类型就只能被这个类或者其子类所实现）</p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>ES6 目前已经支持 <code>class</code> 了，TypeScript 中的类和 ES6 语法类似。同时TypeScript 中类还支持 <code>public\private\protected</code> 等修饰符。</p><p>==<strong>注意：</strong>==</p><ul><li>在 <code>TypeScript</code> 中，成员默认视为 <code>public</code> 修饰符声明的 <strong>公共成员</strong>。</li><li>成员被标记为 <code>private</code> 时，该成员为 <strong>私有成员</strong> 就不能再声明它的类的外部访问。</li><li>成员被标记为 <code>protected</code> 时，其行为与 <code>private</code> 修饰符的行为很相似，但有一点不同，<strong>受保护成员</strong> 在派生类中仍然可以访问。</li><li>除了常用的 <code>public\private\protected</code> 修饰符，也可以通过 <code>readonly</code> 关键词将属性 <strong>成员设置为只读</strong>。这种只读的属性必须在声明时或构造函数中被初始化。</li><li>在 TypeScript 中使用 <code>getters/setters</code> <strong>存取器</strong> 来截取对象成员的访问和设置时，需将编译器的输出环境设置为 ECMAScript 5 或更高。其次，只拥有 <code>get</code> 而不带 <code>set</code> 的存取器会被自动推断为 <code>readonly</code>。</li><li>成员被标记为 <code>static</code> 时，该成员即为 <strong>静态成员</strong>。实例对象中的方法如果需要访问这个属性的时候需要在前面加上类名，如同在实例中使用 <code>this.</code> 前缀访问属性一样。</li></ul><blockquote><p><strong>tips:</strong></p><ul><li>在 TypeScript 的类中可以通过 <strong>参数属性</strong> （即通过在构造函数参数前添加一个访问限定符来声明）的方式来快速声明并初始化一个参数。</li><li>在 TypeScript 中，可通过 <code>abstract</code> 关键词，定义 <strong>抽象类</strong> 和内部的抽象方法。抽象类一般不会直接实例化。不同于接口的是，抽象类可以包含成员实现细节。需要注意的是，抽象类的抽象方法类似于接口的语法，不包含具体实现，其派生类中必须实现该方法。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    provite ages: number;</span><br><span class="line">    protected sex: string;</span><br><span class="line">    readonly maxAges: number = 100;</span><br><span class="line">    static ancestor = &apos;ape man&apos;;</span><br><span class="line">    constructor(readonly minAges: number = 0) &#123; // 等价于声明了一个只读属性 minAges，并通过参数赋值</span><br><span class="line">    &#125;</span><br><span class="line">    getHi() &#123;</span><br><span class="line">        return `hi $&#123;this.name | Person.ancestor&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在 TypeScript 中类和 ES6 一样，可以通过 <code>extends</code> 关键词进行继承，同时子类（又被称为 派生类）的构造函数必需调用 <code>super()</code> 执行父类（又称为基类、超类）的构造函数。</p><blockquote><p>在继承时，如果访问 <code>this</code> 属性，一定需要在调用 <code>super()</code> 之后。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    static hi = &apos;hi&apos;;</span><br><span class="line">    constructor(public name: string) &#123; &#125;</span><br><span class="line">    abstract makeSound(): void;</span><br><span class="line">    move(): void &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125; is moving...`);</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi(): void &#123;</span><br><span class="line">        console.log(Animal.hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">super(name);</span><br><span class="line">&#125;</span><br><span class="line">makeSound() &#123;</span><br><span class="line">console.log(&apos;wow&apos;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dog: Dog; // 表示 Dog 的实例的类型是 Dog</span><br><span class="line">dog = new Dog(&apos;DOG&apos;);</span><br><span class="line"></span><br><span class="line">let DogMaker: typeof Dog = Dog; // typeof Dog 表示取 Dog 类的类型，而不是实例类型。</span><br><span class="line">DogMaker.hi = &apos;Hello&apos;;</span><br><span class="line"></span><br><span class="line">let dog2: Dog = new DogMaker(&apos;DOG&apos;);</span><br><span class="line">console.log(dog2.sayHi());</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>TypeScript 可以为函数定义类型。一个完整的函数类型包含两部分：参数类型和返回值类型。对于返回值，在函数和返回值类型之前使用 <code>=&gt;</code> 可以使之清晰，如果没有返回值，需指定返回值类型为 <code>void</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let myAdd: (baseValue: number, increment: number) =&gt; number =</span><br><span class="line">    function(x: number, y: number): number &#123; return x + y; &#125;;</span><br></pre></td></tr></table></figure><h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>在 JavaScript 中，<code>this</code> 的值只会在函数被调用时才能确定。在 TypeScript 中，为了避免代码歧义，可以提供一个显式的 <code>this</code> <strong>参数</strong>。 这个 <code>this</code> 参数是一个假的参数，它出现在参数列表的最前面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">interface Card &#123;</span><br><span class="line">    suit: string;</span><br><span class="line">    card: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Deck &#123;</span><br><span class="line">    suits: string[];</span><br><span class="line">    cards: number[];</span><br><span class="line">    createCardPicker(this: Deck): () =&gt; Card;</span><br><span class="line">&#125;</span><br><span class="line">let deck: Deck = &#123;</span><br><span class="line">    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</span><br><span class="line">    cards: Array(52),</span><br><span class="line">    // NOTE: The function now explicitly specifies that its callee must be of type Deck</span><br><span class="line">    createCardPicker: function(this: Deck) &#123;</span><br><span class="line">        return () =&gt; &#123;</span><br><span class="line">            let pickedCard = Math.floor(Math.random() * 52);</span><br><span class="line">            let pickedSuit = Math.floor(pickedCard / 13);</span><br><span class="line"></span><br><span class="line">            return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cardPicker = deck.createCardPicker();</span><br><span class="line">let pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit);</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>箭头函数不会捕获 <code>this</code>（箭头函数会保存函数创建时的 <code>this</code>）。</li><li>如果期待的回调函数不要求 <code>this</code>，可以在回调函数类型声明中使用 <code>this: void</code> 表示回调函数不要求 <code>this</code>，避免出现调用错误。</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">interface CustomEvent &#123;</span><br><span class="line">message: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addCustomEventListener(callback: (this: void, e: CustomEvent) =&gt; void): void &#123;</span><br><span class="line">// todos</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Handler &#123;</span><br><span class="line">    info: string;</span><br><span class="line">    onEvent(this: Handler, e: CustomEvent) &#123;</span><br><span class="line">        // oops, used this here. using this callback would crash at runtime</span><br><span class="line">        this.info = e.message;</span><br><span class="line">    &#125;</span><br><span class="line">    onError = (e: CustomEvent) =&gt; &#123;</span><br><span class="line">        // this 不会被捕获。缺点：1、每个实例都会创建一个箭头函数</span><br><span class="line">        this.info = e.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let h = new Handler();</span><br><span class="line">// addCustomEventListener(h.onEvent); // error!</span><br><span class="line">addCustomEventListener(h.onError); // ok!</span><br></pre></td></tr></table></figure><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>在 JavaScript 中依据不同的参数而返回不同的结果是很常见的。在 TypeScript 中为了避免出现代码混乱，可以通过重载的方式声明函数的参数和返回结果，这样就可以检查是否有错误调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">interface Card &#123;</span><br><span class="line">suit: string,</span><br><span class="line">card: number,</span><br><span class="line">&#125;</span><br><span class="line">let suits: Array&lt;string&gt; = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];</span><br><span class="line">function pickCard(x: Card[]): number;</span><br><span class="line">function pickCard(x: number): Card;</span><br><span class="line">function pickCard(x: any): any &#123;</span><br><span class="line">if (typeof x === &apos;object&apos; &amp;&amp; x !== null) &#123;</span><br><span class="line">let pickedCard = Math.floor(Math.random() * x.length);</span><br><span class="line">return pickedCard;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (typeof x === &apos;number&apos;) &#123;</span><br><span class="line">let pickedSuit = Math.floor(x / 13);</span><br><span class="line">return &#123; suit: suits[pickedSuit], card: x % 13 &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pickCard(&apos;2&apos;) // Error: No overload matches this call</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><ul><li>编译器检查类型时，查找重载列表会尝试使用第一个重载定义，如果匹配就使用这个。因此在重载时，一定要将最精确的定义放在前面。</li><li><code>function pickCard(x): any</code> 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用 pickCard 会产生错误。</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;了解 TypeScript 并加以使用，可以帮助我们提高代码的质量。本文主要是对官方文档上的内容进行个人理解后的知识收集，想了解更详细内容，推荐 &lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/basic-types.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TypeScript官网&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;tip:&lt;/strong&gt; 在学习了解 TypeScript 的内容时，最好自己去实践一下。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="前端工具" scheme="https://yiqingfeng.github.io/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="TypeScript" scheme="https://yiqingfeng.github.io/tags/TypeScript/"/>
    
      <category term="Tools" scheme="https://yiqingfeng.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="https://yiqingfeng.github.io/2019/07/22/2019-2/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>https://yiqingfeng.github.io/2019/07/22/2019-2/函数式编程/</id>
    <published>2019-07-22T09:11:39.000Z</published>
    <updated>2020-06-28T05:52:34.386Z</updated>
    
    <content type="html"><![CDATA[<p>什么是函数式编程，函数式编程能为我们解决什么问题？</p><a id="more"></a><h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p><strong>函数式编程</strong> 是一种 <strong>编程范式</strong>，是编程的一种方法论。其中常见的编程范式有 <strong>命令式编程</strong>、<strong>函数式编程</strong>和<strong>逻辑式编程</strong>。</p><p><strong>命令式编程</strong> 是对 <strong>计算机硬件的一种抽象</strong>，拥有 变量（存储单元），表达式（内存引用、数学运算）和控制语句（跳转指令）。通过将达到目的的步骤详情的描述出来，交给程序处理。即命令式程序就是一个冯诺依曼机的 <strong>指令序列</strong>。</p><p>而 <strong>函数式编程</strong> 则是对<strong>数学的抽象</strong>，将运算过程描述为一种 <strong>表达式求值</strong>。</p><p>简单来说就是，<strong>命令式编程关心解决问题的步骤，而函数式编程关心数据的映射</strong> （该映射规则只关心输入，相同的输入总是获得一致的输出）。</p><p>举个例子对比一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo 计算 1 + 2 - 3 + 4</span></span><br><span class="line"><span class="comment">// 命令行式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">a = a - <span class="number">3</span>;</span><br><span class="line">a = a + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line">add(subtract(add(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>), <span class="number">4</span>)</span><br></pre></td></tr></table></figure><blockquote><p>为了避免代码过于 <strong>横向拓展</strong>，陷入“回调地狱”，建议进行 <strong>链式优化</strong> 或 <strong>Promise模式</strong>。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loadash 链式写法</span></span><br><span class="line"><span class="keyword">const</span> utils = &#123;</span><br><span class="line">    chain (n) &#123;</span><br><span class="line">        <span class="keyword">this</span>._temp = n;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    add (b) &#123;</span><br><span class="line">        <span class="keyword">this</span>._temp += b;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    substract (b) &#123;</span><br><span class="line">        <span class="keyword">this</span>._temp += b;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">utils.chain(<span class="number">1</span>).add(<span class="number">2</span>).subtract(<span class="number">3</span>).add(<span class="number">4</span>);</span><br></pre></td></tr></table></figure><h4 id="1-函数式编程的本质："><a href="#1-函数式编程的本质：" class="headerlink" title="1. 函数式编程的本质："></a>1. 函数式编程的本质：</h4><ul><li>函数是一等公民（函数与其他数据类型一样，处于平等地位，能进行赋值和传参）</li><li>引用透明 &amp; 没有副作用（函数的运行不依赖外部状态，也不会修改外部状态）</li><li>不可变性（函数保持独立，不会对输入参数进行变更，只返回新的值）</li></ul><p><strong>函数式编程具有的好处有：</strong></p><ul><li>语义更加清晰</li><li>可复用性更高</li><li>可维护性好（函数保持独立，没有副作用，每一个函数都可视作一个单元，进行测试和调试）</li><li>易于“并发”，不会造成资源争用（不依赖外部状态）</li></ul><p>不过由于函数参数的不可变性，纯函数编程语言是无法实现循环的，只能通过递归的方式解决迭代问题，这使得函数式编程严重依赖递归。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这样的递归调用有更高的开销和局限（调用栈深度），可以尽量把递归写成尾递归的方式，编译器会自动优化为循环。</p></blockquote><h3 id="二、常见函数式编程模型"><a href="#二、常见函数式编程模型" class="headerlink" title="二、常见函数式编程模型"></a>二、常见函数式编程模型</h3><h4 id="1-高阶函数（Higher-order-function）"><a href="#1-高阶函数（Higher-order-function）" class="headerlink" title="1. 高阶函数（Higher-order function）"></a>1. 高阶函数（Higher-order function）</h4><blockquote><p>接受或返回一个函数的函数被称为高阶函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 映射将集合的每一项都做了相同转换处理</span></span><br><span class="line">arr.map(<span class="function"><span class="params">n</span> =&gt;</span> ++n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">const</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    result.push(++i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-闭包（Closure）"><a href="#2-闭包（Closure）" class="headerlink" title="2. 闭包（Closure）"></a>2. 闭包（Closure）</h4><blockquote><p>可以保留局部变量不被释放的代码块，被称为一个闭包。闭包存在内、外两层函数，同时内层函数对外层函数的局部变量进行了引用。</p></blockquote><p>例如斐波那契数列，可利用闭包缓存运算结果：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacciSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data = [<span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> sequence = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!data[n]) &#123;</span><br><span class="line">            data[n] = sequence(n - <span class="number">1</span>) + sequence(n - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequence = fibonacciSequence();</span><br><span class="line"><span class="built_in">console</span>.log(sequence(<span class="number">6</span>));  <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(sequence(<span class="number">5</span>));  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></p><blockquote><p>闭包的主要用于持久化变量，并利用这些变量做缓存或者持久化变量。但是持久化变量会持续占用内存空间，易造成内存浪费，一般需要进行额外的手动清除。</p></blockquote><h4 id="3-柯里化（Currying）"><a href="#3-柯里化（Currying）" class="headerlink" title="3. 柯里化（Currying）"></a>3. 柯里化（Currying）</h4><blockquote><p>给定一个函数的部分参数，生成一个接受其他参数的新函数，即为柯里化。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取相对于 BASE 的路径</span></span><br><span class="line"><span class="keyword">const</span> BASE = <span class="string">'/path/to/base'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般写法</span></span><br><span class="line"><span class="keyword">const</span> aPath = path.relative(BASE, <span class="string">'/a'</span>);</span><br><span class="line"><span class="keyword">const</span> bPath = path.relative(BASE, <span class="string">'/b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// _.parical 改写</span></span><br><span class="line"><span class="keyword">const</span> relativeFromBase = _.partial(path.relative, BASE);</span><br><span class="line"><span class="keyword">const</span> aPath = relativeFromBase(<span class="string">'/a'</span>);</span><br><span class="line"><span class="keyword">const</span> bPath = relativeFromBase(<span class="string">'/b'</span>);</span><br></pre></td></tr></table></figure><p>本例中 <code>aPath</code> 和 <code>bPath</code> 不用再关心 <code>BASE</code> 路径。<strong>柯里化可以使我们只关心函数的部分参数，使函数的用途更加清晰，调用更加简单。</strong></p><h4 id="4-组合（Composing）"><a href="#4-组合（Composing）" class="headerlink" title="4. 组合（Composing）"></a>4. 组合（Composing）</h4><blockquote><p>将多个函数的能力合并，创造一个新的函数，便是组合。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组中每个单词大写，做 Base64</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'pen'</span>, <span class="string">'apple'</span>, <span class="string">'applypen'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般写法 (其中一种)</span></span><br><span class="line"><span class="keyword">const</span> rs = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> w <span class="keyword">of</span> arr)&#123;</span><br><span class="line">  rs.push(btoa(w.toUpperCase()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(rs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// _.flow 改写</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'pen'</span>, <span class="string">'apple'</span>, <span class="string">'applypen'</span>];</span><br><span class="line"><span class="keyword">const</span> upperAndBase64 = _.partialRight(_.map, _.flow(_.upperCase, btoa));</span><br><span class="line"><span class="built_in">console</span>.log(upperAndBase64(arr));</span><br></pre></td></tr></table></figure><p>_.flow 将转大写和转 Base64 的函数的能力合并，生成一个新的函数。方便作为参数函数或后续复用。</p><h4 id="5-函数式组件"><a href="#5-函数式组件" class="headerlink" title="5. 函数式组件"></a>5. 函数式组件</h4><blockquote><p>一个函数就是一个组件，其入参为渲染的上下文，返回值则是渲染好的 HTML。</p></blockquote><p>对于函数式组件而言，其特点有：</p><ul><li><code>Stateless</code>，组件自身没有状态</li><li><code>Instanceless</code>，组件自身也没有实例，即 <code>this</code>。</li><li>无生命周期</li></ul><blockquote><p>当组件不涉及内部状态，只是用于数据渲染时，函数式组件更轻量，性能更好。具体内容可参考 <code>React</code> 和 <code>Vue</code> 的函数式组件。</p></blockquote><h3 id="三、自己眼中的函数式编程"><a href="#三、自己眼中的函数式编程" class="headerlink" title="三、自己眼中的函数式编程"></a>三、自己眼中的函数式编程</h3><p>我理解的函数式编程，是 <strong>以函数为载体，进行数据的映射处理</strong>，其独立而不受外界影响。虽然函数式编程有很多优点和场景，但是在开发过程中，我们不应该拘泥于这一种编程思维，而应该多对比思考其他思想，甚至多种结合进行设置。</p><blockquote><p>此处警醒自己不要钻牛角尖</p></blockquote><h3 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h3><ul><li><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="noopener">函数式编程初探 - 阮一峰</a></li><li><a href="http://taobaofed.org/blog/2017/03/16/javascript-functional-programing/" target="_blank" rel="noopener">我眼中的 JavaScript 函数式编程 - 淘宝 FED</a>  (推荐阅读)</li><li><a href="https://www.zhihu.com/question/28292740" target="_blank" rel="noopener">什么是函数式思维 - 知乎问答</a></li><li><a href="https://juejin.im/post/5b38f4bef265da59bc2cb921" target="_blank" rel="noopener">Vuejs函数式组件，你值得拥有</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是函数式编程，函数式编程能为我们解决什么问题？&lt;/p&gt;
    
    </summary>
    
      <category term="基础原理" scheme="https://yiqingfeng.github.io/categories/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="原理" scheme="https://yiqingfeng.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>实现一个简易的 MVVM 双向数据绑定</title>
    <link href="https://yiqingfeng.github.io/2019/07/01/2019-2/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAMVVM/"/>
    <id>https://yiqingfeng.github.io/2019/07/01/2019-2/手写一个MVVM/</id>
    <published>2019-07-01T03:10:31.000Z</published>
    <updated>2020-06-28T05:52:34.388Z</updated>
    
    <content type="html"><![CDATA[<p>如果你想了解 MVVM 双向数据绑定，那你之前最好有 Angular.js/React.js/Vue.js 等工具库的使用经验，便于理解。</p><a id="more"></a><h3 id="一、实现思路"><a href="#一、实现思路" class="headerlink" title="一、实现思路"></a>一、实现思路</h3><p>要实现一个 mvvm 双向数据绑定，我们需要实现以下几点：</p><ul><li>实现一个数据监听器 <code>Observer</code>，能够对数据对象的所有属性进行监听，当数据变更时能通过发布者通知所有订阅者。</li><li>实现一个指令和模板的解析器 <code>Compile</code>，能对各个元素节点进行扫描解析，将对应的数据模板替换成对应的数据，并且更新到视图上。</li><li>利用订阅者 <code>Watcher</code> 连接 <code>Observer</code> 和 <code>Compile</code>，使得监听数据变更时，视图能变化。视图绑定数据变化时，数据对象也能进行相应的变化。</li><li>提供一个 MVVM 函数，支持以上三个能力。</li></ul><p>流程示意图：</p><p><img src="/images/mvvm.png" alt></p><h3 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h3><h4 id="1-实现数据监听-Observer"><a href="#1-实现数据监听-Observer" class="headerlink" title="1. 实现数据监听 Observer"></a>1. 实现数据监听 <code>Observer</code></h4><p>利用 <code>Object.defineProperty</code> 拦截 <code>data</code> 数据变化。</p><p><strong>监听者 observer.js</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observer(data);</span><br><span class="line">    &#125;</span><br><span class="line">    observer(data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="keyword">this</span>.defineReactive(data, key, data[key]);</span><br><span class="line">            <span class="comment">// 深度递归</span></span><br><span class="line">            <span class="keyword">this</span>.observer(data[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义响应式操作，此处的 value 不可省略，否则直接 get data[key] 会陷入死循环</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param  <span class="type">&#123;Object&#125;</span> </span>data 需要进行数据劫持的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param  <span class="type">&#123;String&#125;</span> </span>key  需要进行数据劫持的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    defineReactive(data, key, value) &#123;</span><br><span class="line">        <span class="comment">// 订阅所有变更</span></span><br><span class="line">        <span class="keyword">const</span> dep = <span class="keyword">new</span> Dependence();</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">            <span class="comment">// 可删除</span></span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// 可枚举</span></span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">set</span>: (newVal) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (newVal !== value) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.observer(newVal);<span class="comment">// 避免新值变更为 object 后没有监听</span></span><br><span class="line">                    value = newVal;</span><br><span class="line">                    <span class="comment">// 通知所有订阅者</span></span><br><span class="line">                    dep.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>发布者 dependence.js</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dependence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 订阅者列表</span></span><br><span class="line">        <span class="keyword">this</span>.subs = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.add(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    removeSub(sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.delete(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知所有订阅者</span></span><br><span class="line">    notify() &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每当 <code>data</code> 数据发生变更时，<code>setter</code> 拦截器都会通知发布者，从而通知所有相关的订阅者。</p><h4 id="2-实现DOM编译-Compile"><a href="#2-实现DOM编译-Compile" class="headerlink" title="2. 实现DOM编译 Compile"></a>2. 实现DOM编译 <code>Compile</code></h4><p><code>Compile</code> 主要负责模板的解析和初始化页面视图。</p><p>由于在解析过程涉及到多次dom元素的操作，为了避免引起页面的多次回流，我们可以利用 <code>fragment</code> 文档片段进行处理，处理结束后再将 <code>fragment</code> 插入原来的节点中。</p><p><strong>编译者 compiler.js</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(el, vm) &#123;</span><br><span class="line">        <span class="keyword">this</span>.el = <span class="keyword">this</span>.getElementNode(el);</span><br><span class="line">        <span class="keyword">this</span>.vm = vm;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.el) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * core方法</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// 1、把这些真实的 Dom 移动到内存中，即 fragment（文档碎片）</span></span><br><span class="line">        <span class="keyword">const</span> fragment = <span class="keyword">this</span>.node2fragment(<span class="keyword">this</span>.el);</span><br><span class="line">        <span class="comment">// 2、将模板中的指令中的变量和 &#123;&#123;&#125;&#125; 中的变量替换成真实的数据</span></span><br><span class="line">        <span class="keyword">this</span>.compile(fragment);</span><br><span class="line">        <span class="comment">// 3、把编译好的 fragment 再塞回页面中</span></span><br><span class="line">        <span class="keyword">this</span>.el.appendChild(fragment);</span><br><span class="line">    &#125;</span><br><span class="line">    node2fragment(el) &#123;</span><br><span class="line">        <span class="comment">// 创建文档碎片</span></span><br><span class="line">        <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">        <span class="comment">// 第一个子节点</span></span><br><span class="line">        <span class="keyword">let</span> firstChild;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环取出根节点中的节点并放入文档碎片中，此时该节点脱离DOM树</span></span><br><span class="line">        <span class="keyword">while</span> (firstChild = el.firstChild) &#123;</span><br><span class="line">            fragment.appendChild(firstChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析文档碎片</span></span><br><span class="line">    compile(fragment) &#123;</span><br><span class="line">        <span class="comment">// 获取当前节点的所有子节点，包括文本节点</span></span><br><span class="line">        <span class="keyword">const</span> childNodes = <span class="built_in">Array</span>.from(fragment.childNodes);</span><br><span class="line"></span><br><span class="line">        childNodes.forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isElementNode(node)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.compile(node);</span><br><span class="line">                <span class="keyword">this</span>.compileElement(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.compileText(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    compileElement(node) &#123;</span><br><span class="line">        <span class="comment">// 获取当前节点的属性</span></span><br><span class="line">        <span class="keyword">const</span> attrs = <span class="built_in">Array</span>.from(node.attributes);</span><br><span class="line"></span><br><span class="line">        attrs.forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 判断该元素属性是否为指令</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isDirective(attr.name)) &#123;</span><br><span class="line">                <span class="comment">// 获取指令对应表达式</span></span><br><span class="line">                <span class="keyword">let</span> exp = attr.value;</span><br><span class="line">                <span class="keyword">let</span> [, type] = attr.name.split(<span class="string">'-'</span>);</span><br><span class="line">                type = <span class="string">`<span class="subst">$&#123;type&#125;</span>Handle`</span>;</span><br><span class="line">                <span class="keyword">this</span>[type] &amp;&amp; <span class="keyword">this</span>[type](node, <span class="keyword">this</span>.vm, exp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    compileText(node) &#123;</span><br><span class="line">        <span class="keyword">let</span> exp = node.textContent;</span><br><span class="line">        <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g</span>;</span><br><span class="line">        <span class="comment">// 将文本的编译视作默认指令 v-text</span></span><br><span class="line">        <span class="keyword">if</span> (reg.test(exp)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.textHandle(node, <span class="keyword">this</span>.vm, exp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * 辅助方法</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    isElementNode(node) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.nodeType === <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getElementNode(el) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isElementNode(el) ?</span><br><span class="line">            el :</span><br><span class="line">            <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断属性是否为指令</span></span><br><span class="line">    isDirective(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> name.includes(<span class="string">'v-'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * 指令处理</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    modelHandle(node, vm, exp) &#123; <span class="comment">// 输入框处理</span></span><br><span class="line">        <span class="keyword">const</span> updateFn = <span class="function">(<span class="params">node, value</span>) =&gt;</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 这里应该加一个监控，数据变化了应该调用这个watch的callbak</span></span><br><span class="line">        <span class="keyword">new</span> Watcher(vm, exp, (newVal, oldVal) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 当值变化后会调用callback将新值传递过来()</span></span><br><span class="line">            updateFn(node, utils.getVal(vm, exp));</span><br><span class="line">        &#125;);</span><br><span class="line">        node.addEventListener(<span class="string">'input'</span>, (e) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> newValue = e.target.value;</span><br><span class="line">            utils.setVal(vm, exp, newValue);</span><br><span class="line">        &#125;);</span><br><span class="line">        updateFn(node, utils.getVal(vm, exp));</span><br><span class="line">    &#125;</span><br><span class="line">    textHandle(node, vm, exp) &#123;</span><br><span class="line">        <span class="keyword">let</span> updateFn = <span class="function">(<span class="params">node, value</span>) =&gt;</span> &#123;</span><br><span class="line">            node.textContent = value;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> value = utils.getTextVal(vm, exp);</span><br><span class="line"></span><br><span class="line">        exp.replace(<span class="regexp">/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g</span>, (...arg) =&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Watcher(vm, arg[<span class="number">1</span>], (newVal, oldVal) =&gt; &#123;</span><br><span class="line">                <span class="comment">// 如果数据变化了，文本节点需要重新获取依赖的数据，更新文本中的内容</span></span><br><span class="line">                updateFn(node, utils.getTextVal(vm, exp));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        updateFn(node, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-实现依赖收集-Watcher"><a href="#3-实现依赖收集-Watcher" class="headerlink" title="3. 实现依赖收集 Watcher"></a>3. 实现依赖收集 <code>Watcher</code></h4><blockquote><p><strong>依赖收集：</strong></p><p>新增订阅者时，将当前订阅者赋值给一个全局变量，之后触发相关联的数据的 <code>getter</code>，<code>getter</code> 就能将全局变量中包含的订阅者添加到相关的订阅者列表中。</p></blockquote><blockquote><p><strong>连接 <code>Observer</code> 和 <code>Compile</code>：</strong></p><p>当 <code>Compile</code> 解析指令或数据模板时，发现有效指令或数据模板时，可新增一个订阅者相应的变化，并在回调中做出对应的处理。</p></blockquote><p><strong>订阅者 watcher.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(vm, exp, callback) &#123;</span><br><span class="line"><span class="keyword">this</span>.vm = vm;</span><br><span class="line"><span class="keyword">this</span>.exp = exp;</span><br><span class="line"><span class="comment">// 存储生成编译结果的函数</span></span><br><span class="line"><span class="keyword">this</span>.callback = callback;</span><br><span class="line"><span class="comment">// 存储当前编译结果</span></span><br><span class="line"><span class="keyword">this</span>.value = <span class="keyword">this</span>.get();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">get</span>() &#123;</span><br><span class="line"><span class="comment">// 通过触发该数据的getter函数，将watch添加到dep中</span></span><br><span class="line">Dependence.target = <span class="keyword">this</span>;</span><br><span class="line"><span class="keyword">const</span> value = utils.getVal(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.exp);</span><br><span class="line">Dependence.target = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line">update() &#123;</span><br><span class="line"><span class="keyword">const</span> newVal = <span class="keyword">this</span>.get();</span><br><span class="line"><span class="keyword">const</span> oldVal = <span class="keyword">this</span>.value;</span><br><span class="line"><span class="keyword">if</span> (oldVal !== newVal) &#123;</span><br><span class="line"><span class="keyword">this</span>.value = newVal;</span><br><span class="line"><span class="keyword">this</span>.callback &amp;&amp; <span class="keyword">this</span>.callback(newVal, oldVal)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>observer.js 新增</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    defineReactive(data, key, value) &#123;</span><br><span class="line">        <span class="comment">// 订阅所有变更</span></span><br><span class="line">        <span class="keyword">const</span> dep = <span class="keyword">new</span> Dependence();</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">get</span>: () =&gt; &#123;</span><br><span class="line">                <span class="comment">// 利用全局变量新增相关订阅者</span></span><br><span class="line">            Dependence.target &amp;&amp; dep.addSub(Dependence.target);</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-提供入口构造函数-MVVM"><a href="#4-提供入口构造函数-MVVM" class="headerlink" title="4. 提供入口构造函数 MVVM"></a>4. 提供入口构造函数 <code>MVVM</code></h4><p>mvvm.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVVM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$data = options.data();</span><br><span class="line">        <span class="comment">// 数据劫持</span></span><br><span class="line">        <span class="keyword">new</span> Observer(<span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="comment">// 数据代理</span></span><br><span class="line">        <span class="keyword">this</span>.proxyData(<span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="comment">// 元素存在，则进行挂载</span></span><br><span class="line">        <span class="keyword">if</span> (options.el) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mount(options.el);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据代理，方便调用</span></span><br><span class="line"><span class="comment">     * 可通过修改 vm.test 间接修改 vm.$data.test 的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param  <span class="type">&#123;Object&#125;</span> </span>data vm.$data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    proxyData(data) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">                <span class="keyword">get</span>() &#123;</span><br><span class="line">                    <span class="keyword">return</span> data[key]</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">                    data[key] = newValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素挂载，进行初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>el [description]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mount(el) &#123;</span><br><span class="line">        <span class="keyword">new</span> Compile(el, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h3><p>相关源码地址：<a href="https://github.com/yiqingfeng/blog-code" target="_blank" rel="noopener">请访问</a></p><h4 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h4><ul><li><a href="https://github.com/DMQ/mvvm" target="_blank" rel="noopener">https://github.com/DMQ/mvvm</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果你想了解 MVVM 双向数据绑定，那你之前最好有 Angular.js/React.js/Vue.js 等工具库的使用经验，便于理解。&lt;/p&gt;
    
    </summary>
    
      <category term="基础原理" scheme="https://yiqingfeng.github.io/categories/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="JS" scheme="https://yiqingfeng.github.io/tags/JS/"/>
    
      <category term="VUE" scheme="https://yiqingfeng.github.io/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>前端开发规范</title>
    <link href="https://yiqingfeng.github.io/2019/06/26/2019-2/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>https://yiqingfeng.github.io/2019/06/26/2019-2/前端开发规范/</id>
    <published>2019-06-26T08:25:31.000Z</published>
    <updated>2020-06-28T05:52:34.387Z</updated>
    
    <content type="html"><![CDATA[<p>一个良好的开发规范能够给代码一个更好的可读性、复用性、拓展性。</p><a id="more"></a><h3 id="一、JavaScript-命名规范"><a href="#一、JavaScript-命名规范" class="headerlink" title="一、JavaScript 命名规范"></a>一、JavaScript 命名规范</h3><ul><li>变量使用<code>有意义</code>且<code>常用</code>的单词，尽量<code>简短</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">const</span> yyyymmdstr = moment().format(<span class="string">'YYYY/MM/DD'</span>);</span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">const</span> currentDate = moment().format(<span class="string">'YYYY/MM/DD'</span>);</span><br></pre></td></tr></table></figure><ul><li>每个常量需要<code>大写</code>，同时有意义</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad: 其他人知道 86400000 的意思吗？</span></span><br><span class="line">setTimeout( blastOff, <span class="number">86400000</span> );</span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">const</span> MILLISECOND_IN_A_DAY = <span class="number">86400000</span>;</span><br><span class="line">setTimeout( blastOff, MILLISECOND_IN_A_DAY );</span><br></pre></td></tr></table></figure><ul><li>对象属性避免无意义命名</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">    carMake: <span class="string">'Honda'</span>,</span><br><span class="line">    carModel: <span class="string">'Accord'</span>,</span><br><span class="line">    carColor: <span class="string">'Blue'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">    make: <span class="string">'Honda'</span>,</span><br><span class="line">    model: <span class="string">'Accord'</span>,</span><br><span class="line">    color: <span class="string">'Blue'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>函数名需要体现其作用（建议和一个函数仅处理一件事规则相匹配，这样函数的表达才更加具体）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emailClients</span>(<span class="params"> clients </span>) </span>&#123;</span><br><span class="line">    clients.forEach( <span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> clientRecord = database.lookup( client );</span><br><span class="line">        <span class="keyword">if</span> ( clientRecord.isActive() ) &#123;</span><br><span class="line">            email( client );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Good: </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emailActiveClients</span>(<span class="params"> clients </span>) </span>&#123;</span><br><span class="line">    clients</span><br><span class="line">        .filter( isActiveClient )</span><br><span class="line">        .forEach( email );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isActiveClient</span>(<span class="params"> client </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> clientRecord = database.lookup( client );    </span><br><span class="line">    <span class="keyword">return</span> clientRecord.isActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、JavaScript-开发规范"><a href="#二、JavaScript-开发规范" class="headerlink" title="二、JavaScript 开发规范"></a>二、JavaScript 开发规范</h3><ul><li><code>一个方法只做一件事</code>。（这是一条在软件工程领域流传久远的规则，遵循这条规则能让你的代码可读性更好，也便于后续重构）</li><li>函数参数使用默认值（可以和解构参数相配合）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    name = name || <span class="string">'Jack'</span>;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// good:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name = <span class="string">'Jack'</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>函数参数最好2个或更少（如果参数超过两个，建议使用ES6的解构语法）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">name, sex, desc</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// good:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">&#123;name, sex, desc&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>避免使用全局方法（如需使用请添加一个命名空间）</li><li><code>删除重复代码，合并相似函数</code> （方便后期维护，但是不建议盲目合并）</li><li><code>删除弃用代码</code> （项目迭代过程中，如果功能变更导致的弃用代码，请删除，不要只是注释！！！）</li><li>尽可能地支持链式调用（能使得代码简洁优雅）</li><li>不要过度优化 (现代浏览器已经在底层做了很多优化，过去的很多优化方案都是无效的，会浪费你的时间。)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="comment">// 现代浏览器已对此( 缓存 list.length )做了优化。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用 <code>Promise</code> 或 <code>Async/Await</code> 代替回调</li></ul><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul><li><a href="https://juejin.im/post/5d0e11196fb9a07eee5ed6d2" target="_blank" rel="noopener">[译] 如何写出漂亮的 JavaScript 代码</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个良好的开发规范能够给代码一个更好的可读性、复用性、拓展性。&lt;/p&gt;
    
    </summary>
    
      <category term="前端方案" scheme="https://yiqingfeng.github.io/categories/%E5%89%8D%E7%AB%AF%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="开发规范" scheme="https://yiqingfeng.github.io/tags/%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>浏览器的回流和重绘</title>
    <link href="https://yiqingfeng.github.io/2019/06/17/2019-2/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/"/>
    <id>https://yiqingfeng.github.io/2019/06/17/2019-2/浏览器的回流和重绘/</id>
    <published>2019-06-16T16:20:03.000Z</published>
    <updated>2020-06-28T05:52:34.388Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、浏览器渲染"><a href="#一、浏览器渲染" class="headerlink" title="一、浏览器渲染"></a>一、浏览器渲染</h3><p>在了解浏览器的回流和重绘之前，我们先来了解下浏览器的渲染过程。该图来源于<a href="https://segmentfault.com/a/1190000017329980" target="_blank" rel="noopener">你真的了解回流和重绘吗</a></p><p><img src="https://image-static.segmentfault.com/408/885/4088852130-5afbe6c95934b_articlex" alt></p><p><img src="https://image-static.segmentfault.com/422/377/4223770356-5abdb235cdd7d_articlex" alt></p><p>简化图如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">HTML--&gt;DOM</span><br><span class="line">CSS--&gt;CSSOM</span><br><span class="line">DOM--&gt;RenderTree</span><br><span class="line">CSSOM--&gt;RenderTree</span><br><span class="line">RenderTree--&gt;paint</span><br></pre></td></tr></table></figure><p>从上面的图中，我们可以看到，整个浏览器的渲染过程有：</p><ol><li>浏览器会把 <code>HTML</code> 解析成 <code>DOM</code>，把 <code>CSS</code> 解析成 <code>CSSOM</code>。</li><li><code>DOM</code> 和 <code>CSSOM</code> 合并就产生了 <code>Render Tree</code>。</li><li>浏览器依据 <code>Render Tree</code> 就能获取所有节点的样式，计算各节点元素在页面上的大小和位置，并将其绘制到页面上。</li></ol><blockquote><p><strong>补充说明：</strong></p><ul><li>浏览器使用流式布局模型 (Flow Based Layout)，因此只需要对 <code>Render Tree</code> 计算遍历一次就可以。（<code>table</code> 及其内部元素除外，它们可能需要多次计算，通常要花同等元素的3倍时间）</li><li><code>Render Tree</code> 不包含隐藏的节点。（例如 <code>display: none;</code> 的节点，还有 <code>head</code>、<code>script</code>、<code>meta</code>、<code>link</code> 节点）</li><li>Display: 将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，此处不再展开）</li></ul></blockquote><h3 id="二、回流"><a href="#二、回流" class="headerlink" title="二、回流"></a>二、回流</h3><p>当 <code>Render Tree</code> 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。（即构建渲染树，计算变化节点在设备视口 viewport 内的确切位置的计算阶段）</p><h4 id="导致回流的操作："><a href="#导致回流的操作：" class="headerlink" title="导致回流的操作："></a>导致回流的操作：</h4><ul><li>页面首次渲染（<code>Render Tree</code> 构建）</li><li>浏览器窗口大小发生改变</li><li>增加或移除样式表</li><li>元素尺寸或位置发生改变</li><li>元素内容变化（文字数量或图片大小等等）</li><li>元素字体大小变化</li><li>添加或者删除可见的DOM元素</li><li>激活CSS伪类（例如：:hover）</li><li>查询某些属性或调用某些方法</li></ul><h4 id="浏览器的优化机制："><a href="#浏览器的优化机制：" class="headerlink" title="浏览器的优化机制："></a>浏览器的优化机制：</h4><p>由于每次重排都会造成额外的计算消耗，因此现代的大多数浏览器会通过队列化修改并批量执行来优化重排的过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>，比如当你访问以下属性或者使用以下方法：</p><ul><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>width、height</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li></ul><p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列</strong>。如果要使用它们，最好将值缓存起来。</p><h3 id="三、重绘"><a href="#三、重绘" class="headerlink" title="三、重绘"></a>三、重绘</h3><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code> 等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p><blockquote><p><strong>注意：</strong> 回流必将引起重绘，而重绘不一定会引起回流。</p></blockquote><h3 id="四、如何减少性能影响"><a href="#四、如何减少性能影响" class="headerlink" title="四、如何减少性能影响"></a>四、如何减少性能影响</h3><p>通过减少回流和重绘，能减少程序对于浏览器的性能的压力。</p><h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><ul><li>避免使用 <code>table</code> 布局。</li><li>尽可能在 <code>DOM</code> 树的最末端改变 <code>class</code>。（减少不必要的影响）</li><li>避免设置多层内联样式。</li><li>将动画效果应用到 <code>position</code> 属性为 <code>absolute</code> 或 <code>fixed</code> 的元素上。</li><li>避免使用 <code>CSS</code> 表达式（例如：<code>calc()</code>）。</li></ul><h4 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h4><ul><li>避免频繁操作样式，最好一次性重写 <code>style</code>属性，或者将样式列表定义为 <code>class</code> 并一次性更改 <code>class</code> 属性。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">el.style.padding = <span class="string">'5px'</span>;</span><br><span class="line">el.style.height = <span class="string">'100px'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">el.style.cssText += <span class="string">'padding: 5px; height: 100px;'</span>;</span><br><span class="line"></span><br><span class="line">el.className += <span class="string">' active'</span>;</span><br></pre></td></tr></table></figure><ul><li><strong><code>DOM</code> 元素“离线处理”：</strong> 避免频繁操作 <code>DOM</code>，创建一个 <code>documentFragment</code>，在它上面应用所有 <code>DOM</code> 操作，最后再把它添加到文档中。也可以先为元素设置 <code>display: none;</code>，操作结束后再把它显示出来。因为在 <code>display</code> 属性为 <code>none</code>的元素上进行的 <code>DOM</code> 操作不会引发回流和重绘。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* DocumentFragment 文档片段缓存操作 回流一次 */</span></span><br><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="comment">// todo ...</span></span><br><span class="line">el.appendChild(fragment); <span class="comment">// 回流</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* cloneNode(true or false) &amp; replaceChild 回流一次 */</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">div.style.width = <span class="string">'100px'</span>;</span><br><span class="line"><span class="comment">// todo ...</span></span><br><span class="line">el.parentNode.replaceChild(div, el); <span class="comment">// 回流</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* display: none; 回流两次 */</span></span><br><span class="line">el.style.display = <span class="string">'none'</span>; <span class="comment">// 回流</span></span><br><span class="line">el.style.width = <span class="string">'100px'</span>;</span><br><span class="line"><span class="comment">// todo ...</span></span><br><span class="line">el.sty;e.display = <span class="string">'block'</span>; <span class="comment">// 回流</span></span><br></pre></td></tr></table></figure><ul><li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li><li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul><h3 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h3><ul><li><a href="https://juejin.im/post/5a9923e9518825558251c96a" target="_blank" rel="noopener">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></li><li><a href="https://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/" target="_blank" rel="noopener">回流与重绘：CSS性能让JavaScript变慢？</a></li><li><a href="https://www.html.cn/archives/4996" target="_blank" rel="noopener">页面重绘和回流以及优化</a></li><li><a href="https://segmentfault.com/a/1190000017329980" target="_blank" rel="noopener">你真的了解回流和重绘吗</a></li></ul>]]></content>
    
    <summary type="html">
    
      说到浏览器的渲染过程，你了解其中的回流和重绘吗？
    
    </summary>
    
      <category term="基础原理" scheme="https://yiqingfeng.github.io/categories/%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="原理" scheme="https://yiqingfeng.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>图片懒加载及异常处理</title>
    <link href="https://yiqingfeng.github.io/2019/05/31/2019-2/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://yiqingfeng.github.io/2019/05/31/2019-2/图片懒加载及异常处理/</id>
    <published>2019-05-31T10:13:22.000Z</published>
    <updated>2020-06-28T05:52:34.387Z</updated>
    
    <content type="html"><![CDATA[<p>在日常页面开发中，常常会涉及到图片的展示。有时候当图片资源过多时，我们希望能将图片延迟加载，同时当图片加载失败后，能用一张默认图片去代替其进行展示。其效果如图所示：</p><a id="more"></a><p><img src="/images/img-load.gif" alt></p><h3 id="一、图片懒加载"><a href="#一、图片懒加载" class="headerlink" title="一、图片懒加载"></a>一、图片懒加载</h3><p>其实图片懒加载的核心思想很简单：</p><ol><li>通过预先将图片的src资源指向一张小图片或空，并通过 <code>data-src</code> 来记录其实际图片地址。</li><li>通过延迟加载或监听滚动事件（图片出现在可视区域中）， 将 <code>data-src</code> 属性值赋值给 <code>src</code> 实现图片的懒加载。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(&#123;</span><br><span class="line">    $imgs.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $img = $(<span class="keyword">this</span>);</span><br><span class="line">        $img.src = $img.attr(<span class="string">'data-src'</span>);</span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 500ms 防抖动，避免回调频繁执行，影响性能</span></span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>, _.debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $<span class="built_in">window</span> = $(<span class="built_in">window</span>); </span><br><span class="line">    <span class="keyword">var</span> top = <span class="built_in">parseInt</span>($<span class="built_in">window</span>.height()) + <span class="built_in">parseInt</span>($<span class="built_in">window</span>.scrollTop());</span><br><span class="line">    $imgs.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $img = $(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">var</span> oSrc = $img.attr(<span class="string">'data-src'</span>);</span><br><span class="line">        <span class="keyword">if</span> (!oSrc) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> ($img.offset().top &lt; top) &#123;</span><br><span class="line">            $img.src = oSrc;</span><br><span class="line">            $img.attr(<span class="string">'data-src'</span>, <span class="string">''</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;, <span class="number">500</span>));</span><br></pre></td></tr></table></figure><h3 id="二、图片加载错误处理"><a href="#二、图片加载错误处理" class="headerlink" title="二、图片加载错误处理"></a>二、图片加载错误处理</h3><p>有些时候，由于网络请求或是资源问题，导致图片资源请求失败，这时图片会展示为非常难看的效果（破碎的图片）。这时可以通过监听图片的 <code>onerror</code> 时间来处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $img.src = <span class="string">'default.jpg'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了避免默认图片也加载失败时，图片资源无限执行的情况，可以利用 jQuery 的 <code>one()</code> api 接口绑定一个一次性的 <code>onerror</code> 事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$img.one(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $img.src = <span class="string">'default.jpg'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>tip:</strong> 在加载图片时，我们可以利用创建一个不在 渲染树 中的 Img 元素来加载图片资源。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oSrc = $img.attr(<span class="string">'data-src'</span>);</span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $img.src = oSrc;</span><br><span class="line">&#125;;</span><br><span class="line">img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.debug(<span class="string">'图片加载失败:'</span>, img.src);</span><br><span class="line">    <span class="comment">// 此时 $img src 依然为默认图，如果图片是否替换判断不为 data-src ，可不进行清空</span></span><br><span class="line">    $img.attr(<span class="string">'data-src'</span>, <span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line">img.src = oSrc;</span><br></pre></td></tr></table></figure><h3 id="三、利用-background-size-属性代替-img-标签"><a href="#三、利用-background-size-属性代替-img-标签" class="headerlink" title="三、利用 background-size 属性代替 img 标签"></a>三、利用 <code>background-size</code> 属性代替 <code>img</code> 标签</h3><p>大多数的时候，图片所处位置的宽高都是固定的。但是图片实际的宽高都是未知的，图片宽高的设置方式有：</p><ol><li>直接将 <code>img</code> 的宽高设置为 <code>img { width: 100%; height: 100%; }</code>可能会出现图片严重失真。</li><li>通过设置最大宽高的方式 <code>img { max-width: 100%; max-height: 100%; }</code> 会出现上下或左右的留白，同时当资源图片宽高小于容器时，留白更多。</li></ol><p><code>background-size: cover;</code> 能够对图片最大程度的利用，不存在留白和图片失真的问题。不过该方式会存在图片资源的损失（图片不能完全展示）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.img</span> &#123;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">background-position</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、利用-Vue-实现一个图片处理指令"><a href="#四、利用-Vue-实现一个图片处理指令" class="headerlink" title="四、利用 Vue 实现一个图片处理指令"></a>四、利用 Vue 实现一个图片处理指令</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    bind(el, binding) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">            img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                el.style.backgroundImage = <span class="string">`url(<span class="subst">$&#123;binding.value&#125;</span>)`</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.debug(<span class="string">'图片加载失败:'</span>, img.src);</span><br><span class="line">            &#125;;</span><br><span class="line">            img.src = binding.value;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>完整示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>图片懒加载处理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.img-group</span> &#123;</span></span><br><span class="line">            display: flex;</span><br><span class="line">            width: 800px;</span><br><span class="line">            flex-wrap: wrap;</span><br><span class="line">            list-style-type: none;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.img-item</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">flex</span>: 0 0 33<span class="selector-class">.3</span>%;</span></span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">            background-position: center;</span><br><span class="line">            background-repeat: no-repeat;</span><br><span class="line">            background-size: cover;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.img-item</span><span class="selector-pseudo">:nth-child(odd)</span> &#123;</span></span><br><span class="line">            background-color: chocolate;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"tpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"img-group"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"img-item"</span> <span class="attr">v-for</span>=<span class="string">"img in imgs"</span> <span class="attr">v-img</span>=<span class="string">" img"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        template: <span class="string">'#tpl'</span>,</span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line">                imgs: [</span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167593089/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167593090/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167593092/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167593093/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167593095/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167595616/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167595617/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167595618/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167595619/0'</span></span></span><br><span class="line">                ],</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        directives: &#123;</span><br><span class="line">            img: &#123;</span><br><span class="line">                bind(el, binding) &#123;</span><br><span class="line"><span class="javascript">                    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span></span><br><span class="line"><span class="javascript">                        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                            el.style.backgroundImage = <span class="string">`url(<span class="subst">$&#123;binding.value&#125;</span>)`</span>;</span></span><br><span class="line">                        &#125;;</span><br><span class="line"><span class="javascript">                        img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                            <span class="built_in">console</span>.debug(<span class="string">'图片加载失败:'</span>, img.src);</span></span><br><span class="line">                        &#125;;</span><br><span class="line">                        img.src = binding.value;</span><br><span class="line">                    &#125;, 0);</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="五、图片优化"><a href="#五、图片优化" class="headerlink" title="五、图片优化"></a>五、图片优化</h3><p>如果是前端资源图片的话，还可以做图片做一些其他优化：</p><ul><li>压缩图片，降低图片大小 （<a href="https://zhitu.isux.us/" target="_blank" rel="noopener">智图：一个图片优化平台</a>）</li><li>响应式请求图片资源（高清屏请求 @2x 图片 ， 一般屏幕 请求 @x 图片，控制图片尺寸，从而缩减图片大小）</li><li>减少图片 http 请求次数（雪碧图）</li><li>利用字体库代替图标 （canvas 、svg 绘图替代图标）</li></ul><p>具体细节说明可以参考： <a href="https://juejin.im/post/59a7725b6fb9a02497170459" target="_blank" rel="noopener">web前端优化之图片优化</a> </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在日常页面开发中，常常会涉及到图片的展示。有时候当图片资源过多时，我们希望能将图片延迟加载，同时当图片加载失败后，能用一张默认图片去代替其进行展示。其效果如图所示：&lt;/p&gt;
    
    </summary>
    
      <category term="前端方案" scheme="https://yiqingfeng.github.io/categories/%E5%89%8D%E7%AB%AF%E6%96%B9%E6%A1%88/"/>
    
    
      <category term="CSS" scheme="https://yiqingfeng.github.io/tags/CSS/"/>
    
      <category term="JS" scheme="https://yiqingfeng.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>css初始化样式</title>
    <link href="https://yiqingfeng.github.io/2019/05/28/2019-1/css%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%B7%E5%BC%8F/"/>
    <id>https://yiqingfeng.github.io/2019/05/28/2019-1/css初始化样式/</id>
    <published>2019-05-28T11:11:02.000Z</published>
    <updated>2020-06-28T05:52:34.384Z</updated>
    
    <content type="html"><![CDATA[<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。</p><a id="more"></a><h3 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h3><p><code>* {padding: 0; margin: 0;}</code> 这种初始化的方式，在应用较大、css样式较多时，<code>*</code> 会将所有便签初始化一次。</p><ul><li><a href="https://www.jianshu.com/p/beabef833bfe" target="_blank" rel="noopener">CSS样式初始化代码</a></li></ul><h3 id="二、示例-tabao"><a href="#二、示例-tabao" class="headerlink" title="二、示例(tabao)"></a>二、示例(tabao)</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*css 初始化 */</span></span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">hr</span>, <span class="selector-tag">p</span>, <span class="selector-tag">blockquote</span>, <span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">li</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">form</span>, <span class="selector-tag">fieldset</span>, <span class="selector-tag">legend</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123; <span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>; &#125; </span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font</span>:<span class="number">12px</span>/<span class="number">1.5</span>tahoma, arial, \<span class="number">5</span>b8b\<span class="number">4</span>f53; &#125; </span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>&#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125; </span><br><span class="line"><span class="selector-tag">address</span>, <span class="selector-tag">cite</span>, <span class="selector-tag">dfn</span>, <span class="selector-tag">em</span>, <span class="selector-tag">var</span> &#123; <span class="attribute">font-style</span>:normal; &#125; </span><br><span class="line"><span class="selector-tag">code</span>, <span class="selector-tag">kbd</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">samp</span> &#123; <span class="attribute">font-family</span>:couriernew, courier, monospace; &#125; </span><br><span class="line"><span class="selector-tag">small</span>&#123; <span class="attribute">font-size</span>:<span class="number">12px</span>; &#125; </span><br><span class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123; <span class="attribute">list-style</span>:none; &#125; </span><br><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">text-decoration</span>:none; &#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>:underline; &#125; </span><br><span class="line"><span class="selector-tag">sup</span> &#123; <span class="attribute">vertical-align</span>:text-top; &#125; </span><br><span class="line"><span class="selector-tag">sub</span>&#123; <span class="attribute">vertical-align</span>:text-bottom; &#125; </span><br><span class="line"><span class="selector-tag">legend</span> &#123; <span class="attribute">color</span>:<span class="number">#000</span>; &#125; </span><br><span class="line"><span class="selector-tag">fieldset</span>, <span class="selector-tag">img</span> &#123; <span class="attribute">border</span>:<span class="number">0</span>; &#125; </span><br><span class="line"><span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125; </span><br><span class="line"><span class="selector-tag">table</span> &#123; <span class="attribute">border-collapse</span>:collapse; <span class="attribute">border-spacing</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">/*css初始化完成*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。&lt;/p&gt;
    
    </summary>
    
      <category term="每日一题" scheme="https://yiqingfeng.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="css" scheme="https://yiqingfeng.github.io/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>无缝轮播</title>
    <link href="https://yiqingfeng.github.io/2019/04/28/2019-1/%E6%97%A0%E7%BC%9D%E8%BD%AE%E6%92%AD/"/>
    <id>https://yiqingfeng.github.io/2019/04/28/2019-1/无缝轮播/</id>
    <published>2019-04-28T03:44:43.000Z</published>
    <updated>2020-06-28T05:52:34.386Z</updated>
    
    <content type="html"><![CDATA[<p>轮播图，前端开发中常见的UI交互。而无缝轮播，其实上就是将第一张图片或轮播区的内容，复制放置到最后，当最后的图片，也就是第一张图被轮播到视图区时，将第一张替换过来，用户感觉不到视觉差异，实现无缝效果。</p><p><img src="/images/无缝轮播.webp" alt></p><h3 id="一、实现："><a href="#一、实现：" class="headerlink" title="一、实现："></a>一、实现：</h3><p><a href="/examples/demo/无缝轮播.html">demo</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二、相关讨论："><a href="#二、相关讨论：" class="headerlink" title="二、相关讨论："></a>二、相关讨论：</h3><ul><li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/108" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/108</a></li></ul><h3 id="三、相关阅读："><a href="#三、相关阅读：" class="headerlink" title="三、相关阅读："></a>三、相关阅读：</h3><ul><li><a href="https://www.jianshu.com/p/d3c650a5c994" target="_blank" rel="noopener">原生JavaScript无缝轮播图特效</a></li></ul>]]></content>
    
    <summary type="html">
    
      如何设计实现无缝轮播?
    
    </summary>
    
      <category term="每日一题" scheme="https://yiqingfeng.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>set和map</title>
    <link href="https://yiqingfeng.github.io/2019/04/25/es6/set%E5%92%8Cmap/"/>
    <id>https://yiqingfeng.github.io/2019/04/25/es6/set和map/</id>
    <published>2019-04-25T06:27:33.000Z</published>
    <updated>2020-06-28T05:52:34.391Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>请介绍 Set \ Map 之间的区别？</p></blockquote><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>JS 中的对象（<code>Object</code>），本质是键值对的集合（Hash结构），传统上只能使用字符串作为键值（限制）。为了解决对象的这种限制，<code>ES6</code> 提供了 <code>Map</code> 数据结构。<br><code>Map</code> 类似于对象，也是键值对的集合，但是“键”不再仅限于字符串，包括各种类型的值（包括对象）都能作为 <code>Map</code> 的键。简单来说就是，<code>Object</code> 是 <strong>字符串 - 值</strong>，而 <code>Map</code> 是 <strong>值 - 值</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;&#125;;</span><br><span class="line">object[<span class="literal">false</span>] = <span class="number">1</span>; <span class="comment">// object['false']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">'true'</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="literal">true</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">'true'</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'true'</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h3 id="相关讨论："><a href="#相关讨论：" class="headerlink" title="相关讨论："></a>相关讨论：</h3><ul><li><h3 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h3></li><li><p><a href></a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;请介绍 Set \ Map 之间的区别？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Map&quot;&gt;&lt;a href=&quot;#Map&quot; class=&quot;headerlink&quot; title=&quot;Map&quot;&gt;&lt;/a&gt;Map&lt;/h3&gt;&lt;p&gt;JS 中的对象（&lt;co
      
    
    </summary>
    
      <category term="每日一题" scheme="https://yiqingfeng.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="JS" scheme="https://yiqingfeng.github.io/tags/JS/"/>
    
      <category term="ES6" scheme="https://yiqingfeng.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>token原理</title>
    <link href="https://yiqingfeng.github.io/2019/04/24/2019-1/token%E5%8E%9F%E7%90%86/"/>
    <id>https://yiqingfeng.github.io/2019/04/24/2019-1/token原理/</id>
    <published>2019-04-24T08:49:41.000Z</published>
    <updated>2020-06-28T05:52:34.385Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、token"><a href="#一、token" class="headerlink" title="一、token"></a>一、token</h3><h4 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h4><p>如何在客户端与服务器断开连接后，客户端不直接存储用户的账号和密码的情况下，实现自动登录，即避免用户多次输入登录。（持久化登录）</p><h4 id="token机制："><a href="#token机制：" class="headerlink" title="token机制："></a>token机制：</h4><ol><li>客户端通过，账户和密码请求登录。</li><li>服务器收到请求，验证账户密码。验证成功后，签发一个字符串<code>token</code>（包含部分用户信息和过期时间）给客户端。</li><li>客户端请求时，带上<code>token</code>。</li><li>服务器收到请求后，验证<code>token</code>，通过则返回对应数据，否则给出错误信息。</li></ol><p><strong>用户匹配</strong>：在实际使用中通过添加用户的少量信息，如 <code>useId</code>，就能将 <code>token</code> 与用户进行关联。 </p><h4 id="token校验："><a href="#token校验：" class="headerlink" title="token校验："></a>token校验：</h4><p><code>token</code>虽然可以持久化登录，但是服务器又该怎么确保<code>token</code>的正确性呢？（防止伪造）</p><ul><li><strong>防伪造</strong>：服务器利用私钥对一些不敏感的信息加密生成签名，将签名和数据拼接作为token的一部分。例如 JWT，参考<a href="http://blog.leapoahead.com/2015/09/06/understanding-jwt/" target="_blank" rel="noopener">JSON Web Token - 在Web应用间安全地传递信息</a>。</li><li><strong>干扰码</strong>：服务器生成 <code>token</code> 时，可以使用客户端的UA作为干扰码对数据加密。客户端请求时，服务器可以使用UA对<code>token</code>解密。</li><li><strong>有效期</strong>：通过加入有效期，使得 <code>token</code> 仅在一段时间内有效，这样能尽量减少损失。</li></ul><h4 id="token刷新："><a href="#token刷新：" class="headerlink" title="token刷新："></a>token刷新：</h4><p><strong><code>token</code> 过期机制：</strong></p><ul><li>服务器缓存<code>token</code>及对应的过期时间，需要服务器更新过期时间，<code>token</code>就会再次有效。</li><li><code>token</code>中包含有过期时间。需要重新生成 <code>token</code>。</li></ul><p>当 <code>token</code> 过期了，如果客户端希望刷新 <code>token</code> 的话，需要重新引入数据来验证。一种是让用户重新输入账号密码。另一种方式就是使用摘要。即在生成 <code>token</code> 的同时，生成 <code>token</code> 的摘要，一起返回给客户端，类似于微信登录的 refresh_token。</p><h3 id="二、相关讨论："><a href="#二、相关讨论：" class="headerlink" title="二、相关讨论："></a>二、相关讨论：</h3><ul><li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/106" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/106</a></li></ul><h3 id="三、相关阅读："><a href="#三、相关阅读：" class="headerlink" title="三、相关阅读："></a>三、相关阅读：</h3><ul><li><a href="https://blog.csdn.net/maocai008/article/details/79064542" target="_blank" rel="noopener">关于token、签名、加密的一点理解</a></li><li><a href="https://www.jianshu.com/p/e0ac7c3067eb" target="_blank" rel="noopener">Token - 服务端身份验证的流行方案</a></li><li><a href="https://ninghao.net/blog/2834" target="_blank" rel="noopener">基于 Token 的身份验证：JSON Web Token</a></li></ul>]]></content>
    
    <summary type="html">
    
      token 加密的原理是什么样的呢？
    
    </summary>
    
      <category term="每日一题" scheme="https://yiqingfeng.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="原理" scheme="https://yiqingfeng.github.io/tags/%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>img宽度调整</title>
    <link href="https://yiqingfeng.github.io/2019/04/23/2019-1/img%E5%AE%BD%E5%BA%A6%E8%B0%83%E6%95%B4/"/>
    <id>https://yiqingfeng.github.io/2019/04/23/2019-1/img宽度调整/</id>
    <published>2019-04-23T13:32:17.000Z</published>
    <updated>2020-06-28T05:52:34.385Z</updated>
    
    <content type="html"><![CDATA[<blockquote></blockquote><h3 id="一、实现思路"><a href="#一、实现思路" class="headerlink" title="一、实现思路"></a>一、实现思路</h3><h3 id="相关讨论："><a href="#相关讨论：" class="headerlink" title="相关讨论："></a>相关讨论：</h3><ul><li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/105" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/105</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、实现思路&quot;&gt;&lt;a href=&quot;#一、实现思路&quot; class=&quot;headerlink&quot; title=&quot;一、实现思路&quot;&gt;&lt;/a&gt;一、实现思路&lt;/h3&gt;&lt;h3 id=&quot;相关讨论：&quot;&gt;&lt;a href=&quot;#相关讨论：
      
    
    </summary>
    
      <category term="每日一题" scheme="https://yiqingfeng.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>取交集</title>
    <link href="https://yiqingfeng.github.io/2019/04/22/2019-1/%E5%8F%96%E4%BA%A4%E9%9B%86/"/>
    <id>https://yiqingfeng.github.io/2019/04/22/2019-1/取交集/</id>
    <published>2019-04-22T06:20:10.000Z</published>
    <updated>2020-06-28T05:52:34.385Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给定两个数组，写一个方法来计算它们的交集。<br>例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]</p></blockquote><h3 id="一、初步解答"><a href="#一、初步解答" class="headerlink" title="一、初步解答"></a>一、初步解答</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIntersection</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    num1.forEach(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num2.indexOf(num) !== <span class="number">-1</span>) &#123;</span><br><span class="line">            result.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIntersection</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1.filter(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num2.includes(num);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、易错点"><a href="#二、易错点" class="headerlink" title="二、易错点"></a>二、易错点</h3><p>举个反例： <code>num1 = [1, 1]; num2 = [1];</code></p><p>对于这种情况，要么利用空间换取时间，要么提高时间复杂度</p><ul><li>空间换时间：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIntersection</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> maps = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    num1.forEach(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maps[num]) &#123;</span><br><span class="line">            maps[num] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maps[num] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    num2.forEach(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maps[num]) &#123;</span><br><span class="line">            result.push(num);</span><br><span class="line">            maps[num] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不使用额外空间：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIntersection</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1.filter(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = num2.indexOf(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index !== <span class="number">-1</span>) &#123;</span><br><span class="line">            num2.splice(index, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、相关讨论："><a href="#三、相关讨论：" class="headerlink" title="三、相关讨论："></a>三、相关讨论：</h3><ul><li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/102" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/102</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;给定两个数组，写一个方法来计算它们的交集。&lt;br&gt;例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;一、初步解答&quot;&gt;&lt;a href=&quot;#一、初
      
    
    </summary>
    
      <category term="每日一题" scheme="https://yiqingfeng.github.io/categories/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
    
      <category term="算法" scheme="https://yiqingfeng.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>个人简历</title>
    <link href="https://yiqingfeng.github.io/2019/04/21/2018/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/"/>
    <id>https://yiqingfeng.github.io/2019/04/21/2018/个人简历/</id>
    <published>2019-04-21T14:12:51.000Z</published>
    <updated>2020-06-28T05:52:34.379Z</updated>
    
    <content type="html"><![CDATA[<div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="个人简历访问密码" />    <label for="pass">个人简历访问密码</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      web前端开发个人简历
    
    </summary>
    
      <category term="自我反思" scheme="https://yiqingfeng.github.io/categories/%E8%87%AA%E6%88%91%E5%8F%8D%E6%80%9D/"/>
    
    
  </entry>
  
</feed>
