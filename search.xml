<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IE CSS hack</title>
    <url>/2018/04/09/2018/IE%20CSS%20hack/</url>
    <content><![CDATA[<h2 id="针对IE的css-hack"><a href="#针对IE的css-hack" class="headerlink" title="针对IE的css hack"></a>针对IE的css hack</h2><figure class="highlight"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="selector-class">.all</span> <span class="selector-tag">IE</span>&#123;<span class="attribute">property</span>:value\<span class="number">9</span>;&#125;</span><br><span class="line"><span class="selector-class">.gte</span> <span class="selector-tag">IE</span> 8&#123;<span class="attribute">property</span>:value\<span class="number">0</span>;&#125;</span><br><span class="line">.lte IE 7&#123;*property:value;&#125;</span><br><span class="line">.IE 8/9&#123;property:value\0;&#125;</span><br><span class="line"><span class="selector-class">.IE</span> 9&#123;<span class="attribute">property</span>:value\<span class="number">9</span>\<span class="number">0</span>;&#125;</span><br><span class="line">.IE 7&#123;+property:value;&#125;</span><br><span class="line"><span class="selector-class">.IE</span> 6&#123;<span class="attribute">_property</span>:value;&#125;</span><br><span class="line">.not IE&#123;property//:value;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lte</code>：就是Less than or equal to的简写，也就是小于或等于的意思。</li>
<li><code>lt</code> ：就是Less than的简写，也就是小于的意思。</li>
<li><code>gte</code>：就是Greater than or equal to的简写，也就是大于或等于的意思。</li>
<li><code>gt</code> ：就是Greater than的简写，也就是大于的意思。</li>
<li><code>!</code>  ：就是不等于的意思，跟javascript里的不等于判断符相同</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ie浏览器hack */</span></span><br><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">       <span class="attribute">padding</span>:<span class="number">10px</span>;</span><br><span class="line">       <span class="attribute">padding</span>:<span class="number">9px</span>\<span class="number">9</span>; <span class="comment">/* all ie */</span></span><br><span class="line">       <span class="attribute">padding</span>:<span class="number">8px</span>\<span class="number">0</span>; <span class="comment">/* ie8-9 目前应用于IE8的单独hack，情况比较少 */</span></span><br><span class="line">       *padding:5px; /* ie6-7 */</span><br><span class="line">       +<span class="selector-tag">padding</span><span class="selector-pseudo">:7px</span>; <span class="comment">/* ie7 */</span></span><br><span class="line">       _<span class="selector-tag">padding</span><span class="selector-pseudo">:6px</span>; <span class="comment">/* ie6 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PS: 这是所有ie的hack了，360用的ie内核，跟你自己本机的ie有关系</p>
]]></content>
      <categories>
        <category>WEB前端基础</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS运算符</title>
    <url>/2019/04/12/2018/JS%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>在JavaScript这门编程语言中，存在着各种各样的运算符，用于应对各种各样的计算。</p>
<p>但是当这些运算符聚集在一起的时候，运算符的优先级和规则影响着运算结果。</p>
<a id="more"></a>
<h3 id="一、-运算符之间的优先级"><a href="#一、-运算符之间的优先级" class="headerlink" title="一、 运算符之间的优先级"></a>一、 运算符之间的优先级</h3><ul>
<li>赋值运算符(Assignment operators)</li>
<li>比较运算符(Comparison operators)</li>
<li>算数运算符(Arithmetic operators)</li>
<li>位运算符(Bitwise operators)</li>
<li>逻辑运算符(Logical operators)</li>
<li>字符串运算符(String operators)</li>
<li>条件（三元）运算符(Conditional operator)</li>
<li>逗号运算符(Comma operator)</li>
<li>一元运算符(Unary operators) </li>
<li>关系运算符(Relational operator)</li>
</ul>
<p>详细的优先级先后顺序可在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence#Table" target="_blank" rel="noopener">JavaScript 参考手册</a> 中查找。</p>
<h3 id="二、-运算符的结合性"><a href="#二、-运算符的结合性" class="headerlink" title="二、 运算符的结合性"></a>二、 运算符的结合性</h3><p>优先级决定表达式中的计算执行顺序。而结合性则是决定相同优先级运算符的执行顺序。结合结合性主要是分为左结合和右结合。因此，表达式中运算执行的规则为：<strong>先按照优先级顺序执行，当优先级相同时，按照结合性顺序执行。</strong></p>
<p>例如：</p>
<ul>
<li>左结合 <code>1 + 2 + 3</code> 等价于 <code>(1 + 2) + 3</code> </li>
<li>右结合 <code>a = b = 1</code> 等价于 <code>a = (b = 1)</code></li>
</ul>
<p>下面我们直接看一些前端试题：</p>
<h3 id="二：一些前端试题"><a href="#二：一些前端试题" class="headerlink" title="二：一些前端试题"></a>二：一些前端试题</h3><h4 id="1-优先级的坑"><a href="#1-优先级的坑" class="headerlink" title="1. 优先级的坑"></a>1. 优先级的坑</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> val = <span class="string">'smtg'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Value is '</span> + (val === <span class="string">'smtg'</span>) ? <span class="string">'Something'</span> : <span class="string">'Nothing'</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解析：<br>输出表达式 <code>&#39;Value is &#39; + (val === &#39;smtg&#39;) ? &#39;Something&#39; : &#39;Nothing&#39;</code> 中，括号运算符 &gt; 加号 &gt; 条件运算符，因此其等价于 <code>(&#39;Value is &#39; + (val === &#39;smtg&#39;)) ? &#39;Something&#39; : &#39;Nothing&#39;</code>;<br>结果即为：<strong>“Something”</strong></p>
</blockquote>
<h4 id="2-连续赋值的坑"><a href="#2-连续赋值的坑" class="headerlink" title="2. 连续赋值的坑"></a>2. 连续赋值的坑</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.x);</span><br><span class="line"><span class="built_in">console</span>.log(b.x);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解析：</p>
<ol>
<li><code>var a = {n: 1}; var b = a;</code> 表明 <code>a</code>和<code>b</code>两个变量都指向了对象<code>{n: 1}</code>。</li>
<li><code>a.x = a = {n: 2}</code> 表达式中存在两类运算符，成员运算符 &gt; 赋值运算符。<strong>注意，此时{n: 1} 在内存中变为 {n: 1, x: undefined}, a.x 指向的是该对象的 x，等待被赋值</strong>，然后<code>a = {n: 2}</code>执行，<code>a</code>指向对象<code>{n: 2}</code>, <code>a</code>发生了指向变更，但也不再影响此刻中的 <code>a.x</code>（之前已经对其进行了指向确定）。随后 <code>{n: 1, x: undefined}</code> 中的 <code>x</code>，被赋值为 <code>a</code>。<br>因此：<code>a 指向 {n: 2}</code>，<code>b</code> 指向 <code>{n: 1, x: a}</code>。<br>结果即为：a.x: <code>undefined</code>，b.x: <code>{n: 2}</code></li>
</ol>
</blockquote>
<h3 id="三、相关阅读"><a href="#三、相关阅读" class="headerlink" title="三、相关阅读"></a>三、相关阅读</h3><ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators" target="_blank" rel="noopener">MDN 表达式和运算符</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">MDN 运算符优先级</a></li>
<li><a href="https://www.zhihu.com/question/41220520" target="_blank" rel="noopener">javascript面试题，关于连续赋值的坑</a></li>
</ul>
<h3 id="四、汇总表（来自MDN）"><a href="#四、汇总表（来自MDN）" class="headerlink" title="四、汇总表（来自MDN）"></a>四、汇总表（来自MDN）</h3><table>
<thead>
<tr>
<th>优先级</th>
<th>运算类型</th>
<th>关联性</th>
<th>运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td>20</td>
<td>圆括号</td>
<td>n/a</td>
<td><code>( … )</code></td>
</tr>
<tr>
<td>19</td>
<td>成员访问</td>
<td>从左到右</td>
<td><code>… . …</code></td>
</tr>
<tr>
<td></td>
<td>需计算的成员访问</td>
<td>从左到右</td>
<td><code>… [ … ]</code></td>
</tr>
<tr>
<td></td>
<td>new (带参数列表)</td>
<td>n/a</td>
<td><code>new … ( … )</code></td>
</tr>
<tr>
<td></td>
<td>函数调用</td>
<td>从左到右</td>
<td><code>… ( … )</code></td>
</tr>
<tr>
<td>18</td>
<td>new (无参数列表)</td>
<td>从右到左</td>
<td><code>new …</code></td>
</tr>
<tr>
<td>17</td>
<td>后置递增(运算符在后)</td>
<td>n/a</td>
<td><code>… ++</code></td>
</tr>
<tr>
<td></td>
<td>后置递减(运算符在后)</td>
<td></td>
<td><code>… --</code></td>
</tr>
<tr>
<td>16</td>
<td>逻辑非</td>
<td>从右到左</td>
<td><code>! …</code></td>
</tr>
<tr>
<td></td>
<td>按位非</td>
<td></td>
<td><code>~ …</code></td>
</tr>
<tr>
<td></td>
<td>一元加法</td>
<td></td>
<td><code>+ …</code></td>
</tr>
<tr>
<td></td>
<td>一元减法</td>
<td></td>
<td><code>- …</code></td>
</tr>
<tr>
<td></td>
<td>前置递增</td>
<td></td>
<td><code>++ …</code></td>
</tr>
<tr>
<td></td>
<td>前置递减</td>
<td></td>
<td><code>-- …</code></td>
</tr>
<tr>
<td></td>
<td>typeof</td>
<td></td>
<td><code>typeof …</code></td>
</tr>
<tr>
<td></td>
<td>void</td>
<td></td>
<td><code>void …</code></td>
</tr>
<tr>
<td></td>
<td>delete</td>
<td></td>
<td><code>delete …</code></td>
</tr>
<tr>
<td></td>
<td>await</td>
<td></td>
<td><code>await …</code></td>
</tr>
<tr>
<td>15</td>
<td>幂</td>
<td>从右到左</td>
<td><code>… ** …</code></td>
</tr>
<tr>
<td>14</td>
<td>乘法</td>
<td>从左到右</td>
<td><code>… * …</code></td>
</tr>
<tr>
<td></td>
<td>除法</td>
<td></td>
<td><code>… / …</code></td>
</tr>
<tr>
<td></td>
<td>取模</td>
<td></td>
<td><code>… % …</code></td>
</tr>
<tr>
<td>13</td>
<td>加法</td>
<td>从左到右</td>
<td><code>… + …</code></td>
</tr>
<tr>
<td></td>
<td>减法</td>
<td></td>
<td><code>… - …</code></td>
</tr>
<tr>
<td>12</td>
<td>按位左移</td>
<td>从左到右</td>
<td><code>… &lt;&lt; …</code></td>
</tr>
<tr>
<td></td>
<td>按位右移</td>
<td></td>
<td><code>… &gt;&gt; …</code></td>
</tr>
<tr>
<td></td>
<td>无符号右移</td>
<td></td>
<td><code>… &gt;&gt;&gt; …</code></td>
</tr>
<tr>
<td>11</td>
<td>小于</td>
<td>从左到右</td>
<td><code>… &lt; …</code></td>
</tr>
<tr>
<td></td>
<td>小于等于</td>
<td></td>
<td><code>… &lt;= …</code></td>
</tr>
<tr>
<td></td>
<td>大于</td>
<td></td>
<td><code>… &gt; …</code></td>
</tr>
<tr>
<td></td>
<td>大于等于</td>
<td></td>
<td><code>… &gt;= …</code></td>
</tr>
<tr>
<td></td>
<td>in</td>
<td></td>
<td><code>… in …</code></td>
</tr>
<tr>
<td></td>
<td>instanceof</td>
<td></td>
<td><code>… instanceof …</code></td>
</tr>
<tr>
<td>10</td>
<td>等号</td>
<td>从左到右</td>
<td><code>… == …</code></td>
</tr>
<tr>
<td></td>
<td>非等号</td>
<td></td>
<td><code>… != …</code></td>
</tr>
<tr>
<td></td>
<td>全等号</td>
<td></td>
<td><code>… === …</code></td>
</tr>
<tr>
<td></td>
<td>非全等号</td>
<td></td>
<td><code>… !== …</code></td>
</tr>
<tr>
<td> 9</td>
<td>按位与</td>
<td>从左到右</td>
<td><code>… &amp; …</code></td>
</tr>
<tr>
<td> 8</td>
<td>按位异或</td>
<td>从左到右</td>
<td><code>… ^ …</code></td>
</tr>
<tr>
<td> 7</td>
<td>按位或</td>
<td>从左到右</td>
<td>… &#166; …</td>
</tr>
<tr>
<td> 6</td>
<td>逻辑与</td>
<td>从左到右</td>
<td><code>… &amp;&amp; …</code></td>
</tr>
<tr>
<td> 5</td>
<td>逻辑或</td>
<td>从左到右</td>
<td>… &#166;&#166; …</td>
</tr>
<tr>
<td> 4</td>
<td>条件运算符</td>
<td>从右到左</td>
<td><code>… ? … : …</code></td>
</tr>
<tr>
<td> 3</td>
<td>赋值</td>
<td>从右到左</td>
<td><code>… = …</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>… += …</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>… -= …</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>… *= …</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>… /= …</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>… %= …</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>… &lt;&lt;= …</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>… &gt;&gt;= …</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>… &gt;&gt;&gt;= …</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>… &amp;= …</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><code>… ^= …</code></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>… &#166;= …</td>
</tr>
<tr>
<td> 2</td>
<td>yield</td>
<td>从右到左</td>
<td><code>yield …</code></td>
</tr>
<tr>
<td></td>
<td>yield*</td>
<td></td>
<td><code>yield* …</code></td>
</tr>
<tr>
<td> 1</td>
<td>展开运算符</td>
<td>n/a</td>
<td><code>... …</code></td>
</tr>
<tr>
<td> 0</td>
<td>逗号</td>
<td>从左到右</td>
<td><code>… , …</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>优先级数据越大越优先执行。</p>
</blockquote>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>利用bat</title>
    <url>/2019/03/22/2018/bat/</url>
    <content><![CDATA[<blockquote>
<p><code>bat</code>批处理文件是一个文本文件，其每一行都是一条DOS命令。同时<code>bat</code>也是一种简单的运行程序。</p>
</blockquote>
<h3 id="一、简单介绍批处理文件"><a href="#一、简单介绍批处理文件" class="headerlink" title="一、简单介绍批处理文件"></a>一、简单介绍批处理文件</h3><p><code>bat</code>是<code>window</code>系统下的一种批处理文件，主要适用于自动的连续执行多条命令。批处理文件支持条件判断、循环和流程控制。每个编写好的批处理文件相当于一个DOS外部命令。（如果批量文件路径被添加到 <code>PATH</code>，）</p>
<p>通过利用批处理文件可以有效简化我们的操作处理。</p>
<h3 id="二、bat常用命令"><a href="#二、bat常用命令" class="headerlink" title="二、bat常用命令"></a>二、bat常用命令</h3><ul>
<li><code>echo</code> 表示 显示此命令后的字符</li>
<li><code>echo off</code> 表示 在此语句后所有运行的命令都不显示命令行本身 </li>
<li><code>@</code> 表示 与echo off相象，但它是加在每个命令行的最前面，表示运行时不显示这一行的命令行（<code>@</code> 只能影响当前行）</li>
<li><code>call</code> 表示 调用另一个批处理文件（如果不用 <code>call</code> 而直接调用别的批处理文件，那么执行完那个批处理文件后将无法返回当前文件并执行当前文件的后续命令）。 </li>
<li><code>pause</code> 表示 运行此句会暂停批处理的执行并在屏幕上显示Press any key to continue…的提示，等待用户按任意键后继续 </li>
<li><code>rem</code> 表示 注释当前代码行</li>
<li><code>%</code> 参数表示符</li>
<li><code>%[1-9]</code> 表示 参数，参数是指在运行批处理文件时在文件名后加的以空格（或者Tab）分隔的字符串。（%0表示批处理命令本身）</li>
</ul>
<h3 id="三、bat特殊命令"><a href="#三、bat特殊命令" class="headerlink" title="三、bat特殊命令"></a>三、bat特殊命令</h3><ul>
<li><code>if</code> 条件语句，其支持三种格式<ul>
<li><code>if [not] &quot;param&quot; == &quot;string&quot; expression</code> 程序（不）满足条件时，执行相应操作。</li>
<li><code>if [not] exist [path\]filename expression</code> 指定文件（不）存在时，执行相应操作。</li>
<li><code>if errorlevel &lt;number&gt; expression</code> 很多DOS程序在运行结束后会返回一个数字值用来表示程序运行的结果。通过 <code>errorlevel</code> 可以判断程序的返回值。</li>
</ul>
</li>
<li><p><code>goto</code> 跳转操作，常与 <code>labal</code>（标号，标号用 <code>:</code> 后跟标准字符串来定义） 配合使用。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">goto end</span><br><span class="line"></span><br><span class="line">:end</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>choice</code> 使用此命令可以让用户输入一个字符（用于选择），从而根据用户的选择返回不同的errorlevel，然后于if errorlevel配合，根据用户的选择运行不同的命令。 </p>
<ul>
<li>语法 <code>CHOICE [/C choices] [/N] [/CS] [/T timeout /D choice] [/M text]</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>/C</td>
<td>choices</td>
<td>指定要创建的选项列表。默认列表是 “YN”。</td>
</tr>
<tr>
<td>/N</td>
<td></td>
<td>在提示符中隐藏选项列表。提示前面的消息得到显示，选项依旧处于启用状态。</td>
</tr>
<tr>
<td>/CS</td>
<td></td>
<td>允许选择分大小写的选项。在默认情况下，这个工具是不分大小写的。</td>
</tr>
<tr>
<td>/T</td>
<td>timeout</td>
<td>做出默认选择之前，暂停的秒数。可接受的值是从 0 到 9999。如果指定了 0，就不会有暂停，默认选项会得到选择。</td>
</tr>
<tr>
<td>/D</td>
<td>choice</td>
<td>在 nnnn 秒之后指定默认选项。字符必须在用 /C 选项指定的一组选择中; 同时，必须用 /T 指定 nnnn。</td>
</tr>
<tr>
<td>/M　</td>
<td>text</td>
<td>指定提示之前要显示的消息。如果没有指定，工具只显示提示。</td>
</tr>
<tr>
<td>/?</td>
<td></td>
<td>显示帮助消息。 </td>
</tr>
</tbody>
</table>
<ul>
<li><code>for</code> 循环命令。 对一组文件中的每一个文件执行某个特定命令。 <ul>
<li>语法 <code>FOR %%variable IN (set) DO command [command-parameters]</code></li>
</ul>
</li>
</ul>
<h3 id="四、编写一个简单的示例"><a href="#四、编写一个简单的示例" class="headerlink" title="四、编写一个简单的示例"></a>四、编写一个简单的示例</h3><p><strong>场景：</strong>现在需要将 <strong>D:\mine\test\a</strong> 中所有的文本文件，移动到 <strong>D:\mine\test\b</strong> 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> a</span><br><span class="line"><span class="keyword">for</span> %%f <span class="keyword">in</span> (*.txt) <span class="keyword">do</span> XCOPY %%f ..\b\</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>calibre</title>
    <url>/2018/05/28/2018/calibre/</url>
    <content><![CDATA[<h2 id="kindle工具calibre之格式转换"><a href="#kindle工具calibre之格式转换" class="headerlink" title="kindle工具calibre之格式转换"></a>kindle工具calibre之格式转换</h2><p>利用calibre可以很方便地解决文件格式之间的转换，同时还能进行规则的制定，从而控制渲染效果。</p>
<p>calibre在进行转换的过程中，会将文件按照格式转换成html文件，之后会按照指定的规则进行设置。</p>
<h3 id="示例：利用calibre将markdown转换成mobi"><a href="#示例：利用calibre将markdown转换成mobi" class="headerlink" title="示例：利用calibre将markdown转换成mobi"></a>示例：利用calibre将markdown转换成mobi</h3><ol>
<li>自己在md源文件中设置好文件的排版。</li>
<li>利用calibre转换。</li>
<li>在界面外观的Styling中设置你想设置的css样式。<code>p{text-indent: 2em;}</code></li>
<li>在内容目录的一级目录下设置表达式<code>//h:h3</code>，即表示匹配一级目录。</li>
</ol>
<p>当然你也可以按照自己的想法进行设置。</p>
<h3 id="利用calibre进行文件合并"><a href="#利用calibre进行文件合并" class="headerlink" title="利用calibre进行文件合并"></a>利用calibre进行文件合并</h3><p>在calibre中，当源文件较大时，calibre的转换就会变的相当慢，这是不妨将文件拆分成多个，之后进行合并即可。</p>
<p>在calibre中，有一个名为<code>EpubMerge</code>的插件，通过这个插件的帮助，我们即可将文件转换成<code>epub</code>格式进行转换即可。然后将转换之后的多个文件通过插件进行合并，当然目录依旧存在，不过每个文件会被视为一个一级目录，而文件内的以及目录则相应降级。</p>
]]></content>
      <categories>
        <category>小工具</category>
      </categories>
      <tags>
        <tag>kindle</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue响应式原理</title>
    <url>/2019/04/10/2018/Vue%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<blockquote>
<p>Vue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么在 Vue 3.0 采用了 Proxy，抛弃了 Object.defineProperty？</p>
</blockquote>
<a id="more"></a>
<h3 id="相关讨论："><a href="#相关讨论：" class="headerlink" title="相关讨论："></a>相关讨论：</h3><ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/90" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/90</a></li>
</ul>
<h3 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h3><ul>
<li><a href></a></li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>call和apply</title>
    <url>/2019/04/04/2018/call%E5%92%8Capply/</url>
    <content><![CDATA[<blockquote>
<p>call 和 apply 的区别是什么，哪个性能更好一些</p>
</blockquote>
<a id="more"></a>
<p>call和apply使开发过程中，常用的方法。</p>
<h3 id="相关参考："><a href="#相关参考：" class="headerlink" title="相关参考："></a>相关参考：</h3><h3 id="自我总结："><a href="#自我总结：" class="headerlink" title="自我总结："></a>自我总结：</h3>]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>css图片布局</title>
    <url>/2018/05/17/2018/css%E5%9B%BE%E7%89%87%E5%B8%83%E5%B1%80/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前端开发过程中，经常会涉及到图片相关布局。尤其是涉及到图片宽度自适应时，这时候就需要将容器宽高按照一定比例进行设置。</p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><ul>
<li>利用<code>padding</code>实现容器宽高比</li>
</ul>
<blockquote>
<p><strong>padding</strong>:<br>在默认的水平文档流方向下，CSS margin和padding属性的垂直方向的百分比值都是相对于宽度计算的，这个和top, bottom等属性的百分比值不一样。</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo-bg"</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"demo-img"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"./test.jpg"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demo-bg</span> &#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">50%</span> <span class="number">50%</span> <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"./test.jpg"</span>) no-repeat;</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.demo-img</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">50%</span> <span class="number">50%</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.demo-img</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">    position: absolute;;</span><br><span class="line">    <span class="selector-tag">top</span>: 0;</span><br><span class="line">    <span class="selector-tag">left</span>: 0;</span><br><span class="line">    <span class="selector-tag">width</span>: 100%;</span><br><span class="line">    <span class="selector-tag">height</span>: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="http://www.zhangxinxu.com/wordpress/2017/08/css-percent-padding-image-layout/" target="_blank" rel="noopener">CSS百分比padding实现比例固定图片自适应布局</a></li>
</ul>
]]></content>
      <categories>
        <category>WEB前端基础</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>es5和es6的继承对比分析</title>
    <url>/2019/02/27/2018/es5%E5%92%8Ces6%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p>原问题为：ES5/ES6 的继承除了写法以外还有什么区别？</p>
<h3 id="相关参考："><a href="#相关参考：" class="headerlink" title="相关参考："></a>相关参考：</h3><ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/20" target="_blank" rel="noopener">第 7 期：ES5/ES6 的继承除了写法以外还有什么区别？</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">Class 的基本语法</a></li>
<li><a href="http://es6.ruanyifeng.com/#docs/class-extends" target="_blank" rel="noopener">Class 的继承</a></li>
<li><a href="https://leanpub.com/understandinges6/read#leanpub-auto-class-declarations" target="_blank" rel="noopener">Class Declarations</a></li>
</ul>
<h3 id="自我总结："><a href="#自我总结：" class="headerlink" title="自我总结："></a>自我总结：</h3><p>声明阶段：</p>
<p>ES5 是通过构造函数来声明一个“类”，在 ES6 中 通过关键字 <code>Class</code> 来进行声明。但是 ES5 的构造函数存在变量提升，但是 <code>Class</code> 声明不存在变量提升。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> A()); <span class="comment">// A &#123;&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> B()); <span class="comment">// ReferenceError: B is not defined</span></span><br><span class="line">Class B &#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继承：</p>
<p>ES5 通过修改原型链进行继承，ES6 通过关键字<code>extend</code>进行继承，但是子类的<code>constructor</code>调用时，需要先利用<code>super</code>调用父类的构造方法。否则新建实例对象时，会报错。</p>
<p>ES5继承的实质，是通过将父类的方法添加到子类的实例中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Super</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name || <span class="string">'nimo'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Super.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sub</span>(<span class="params">ages</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ages = ages || <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Sub.prototype = <span class="keyword">new</span> Super();</span><br><span class="line">Sub.prototype.constructor = Sub;</span><br></pre></td></tr></table></figure>
<p><img src="/images/es5继承.jpg" alt></p>
<p>ES6继承的实质，是通过将父类的属性和方法添加到<code>this</code>中，即将父类的属性和方法添加到子类实例对象上，即子类的实例其实是基于父类创建的。这也就是为什么在ES6继承中，子类的构造函数必须先调用<code>super</code>方法才能调用this。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es6</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name || <span class="string">'nimo'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getName() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Super</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(ages) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.ages = ages || <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/es6继承.jpg" alt></p>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>express入门使用</title>
    <url>/2019/03/28/2018/express%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>Express是基于Node.js平台，快速、开放、极简的Web开发框架，合理利用express能够提高我们的开发效率。<br><a id="more"></a></p>
<blockquote>
<p>express 是一款轻量高效的 node web 开发框架。通过对 node 内置模块的封装和拓展，提高开发者构建一个 web 应用的效率。类似的框架还有 <strong>koa</strong>（<strong>koa</strong>和<strong>express</strong>是同一个开发团队）。</p>
</blockquote>
<h3 id="一、Express概述"><a href="#一、Express概述" class="headerlink" title="一、Express概述"></a>一、Express概述</h3><p>Express开发web框架的优点：</p>
<ul>
<li><strong>易上手：</strong> express 对 node 底层API进行了适度封装，减少了程序的复杂度。</li>
<li><strong>性能好：</strong> nodejs最初就是为了开发高性能web服务器而被设计出来的。</li>
<li><strong>高拓展：</strong> express 是基于中间件的开发模式，对请求处理进行了拆分，方便应用模块化和后期维护。</li>
</ul>
<p>以下是 node 请求的一个流程图：<br><img src="/images/node-web-flow-chat.jpg" alt></p>
<p>express 在其中的作用就是协助开发者处理圆圈中的请求处理函数。与上图相比，express 处理流程如下：<br><img src="/images/express-web-flow-chat.jpg" alt></p>
<p>和之前处理相比，express 将一个大型的 request 请求拆分成了多个中间件，依次处理。</p>
<h3 id="二、Express快速开始"><a href="#二、Express快速开始" class="headerlink" title="二、Express快速开始"></a>二、Express快速开始</h3><p>express 官方提供了一个生成器 <code>express-generator</code> 可用于快速构建一个 web 应用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g express-generator</span><br><span class="line">express --view=ejs myapp</span><br><span class="line"><span class="built_in">cd</span> myapp</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>
<h3 id="三、中间件-amp-路由"><a href="#三、中间件-amp-路由" class="headerlink" title="三、中间件 &amp; 路由"></a>三、中间件 &amp; 路由</h3><p>Express 对中间件分为以下几类：</p>
<ul>
<li>应用级中间件 （<code>app.use()</code>、<code>app.METHOD()</code>）</li>
<li>路由级中间件 （通过<code>express.Router()</code>创建，<code>router.use()</code>、<code>router.METHOD()</code>）</li>
<li>错误处理中间件 （通过中间件四个参数识别 <code>(err, req, res, next) =&gt; {}</code>）</li>
<li>内置中间件</li>
<li>第三方中间件</li>
</ul>
<p>以下是 应用级中间件的一个使用说明：<br><img src="/images/express中间件.png" alt></p>
<p>在利用 express 进行实际开发过程中，开发者只要能按照中间件的规则，就能进行快速开发。</p>
<p>express支持四种类型路由：</p>
<ul>
<li>字符串类型 <code>app.get(&#39;/book&#39;, (req, res, next) =&gt; { });</code>  eg. <code>/book</code></li>
<li>字符串模式类型  <code>app.get(&#39;/user/*man&#39;, (req, res, next) =&gt; { });</code> eg. <code>/user/man, /user/woman</code></li>
<li>正则表达式类型  <code>app.get(&#39;/animals?$/&#39;, (req, res, next) =&gt; { });</code> eg. <code>/animal, /animals</code></li>
<li>参数类型 <code>app.get(&#39;/employee/:uid/:age&#39;, (req, res, next) =&gt; { });</code> eg. <code>/111/30，返回 {&quot;uid&quot;: 111, &quot;age&quot;: 30}</code></li>
</ul>
<blockquote>
<p><strong>注意：</strong><br>当应用越发复杂时，最好利用<code>express.Router()</code>进行路由拆分。<br>express 中间件的执行顺序为注册的先后顺序，因此建议将错误处理中间件在最后注册。</p>
</blockquote>
<h3 id="四、常用中间件"><a href="#四、常用中间件" class="headerlink" title="四、常用中间件"></a>四、常用中间件</h3><table>
<thead>
<tr>
<th>Middleware module</th>
<th>Description</th>
<th>Replaces built-in function (Express 3)</th>
</tr>
</thead>
<tbody>
<tr>
<td>body-parser</td>
<td>Parse HTTP request body. See also: body, co-body, and raw-body.</td>
<td>express.bodyParser</td>
</tr>
<tr>
<td>compression</td>
<td>Compress HTTP responses.</td>
<td>express.compress</td>
</tr>
<tr>
<td>connect-rid</td>
<td>Generate unique request ID.</td>
<td>NA</td>
</tr>
<tr>
<td>cookie-parser</td>
<td>Parse cookie header and populate req.cookies. See also cookies and keygrip.</td>
<td>express.cookieParser</td>
</tr>
<tr>
<td>cookie-session</td>
<td>Establish cookie-based sessions.</td>
<td>express.cookieSession</td>
</tr>
<tr>
<td>cors</td>
<td>Enable cross-origin resource sharing (CORS) with various options.</td>
<td>NA</td>
</tr>
<tr>
<td>csurf</td>
<td>Protect from CSRF exploits.</td>
<td>express.csrf</td>
</tr>
<tr>
<td>errorhandler</td>
<td>Development error-handling/debugging.</td>
<td>express.errorHandler</td>
</tr>
<tr>
<td>method-override</td>
<td>Override HTTP methods using header.</td>
<td>express.methodOverride</td>
</tr>
<tr>
<td>morgan</td>
<td>HTTP request logger.</td>
<td>express.logger</td>
</tr>
<tr>
<td>multer</td>
<td>Handle multi-part form data.</td>
<td>express.bodyParser</td>
</tr>
<tr>
<td>response-time</td>
<td>Record HTTP response time.</td>
<td>express.responseTime</td>
</tr>
<tr>
<td>serve-favicon</td>
<td>Serve a favicon.</td>
<td>express.favicon</td>
</tr>
<tr>
<td>serve-index</td>
<td>Serve directory listing for a given path.</td>
<td>express.directory</td>
</tr>
<tr>
<td>serve-static</td>
<td>Serve static files.</td>
<td>express.static</td>
</tr>
<tr>
<td>session</td>
<td>Establish server-based sessions (development only).</td>
<td>express.session</td>
</tr>
<tr>
<td>timeout</td>
<td>Set a timeout period for HTTP request processing.</td>
<td>express.timeout</td>
</tr>
<tr>
<td>vhost</td>
<td>Create virtual domains.</td>
<td>express.vhost</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>express源码解析</title>
    <url>/2019/03/27/2018/express%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<blockquote>
<p>Express 是一个极简框架，非常灵活可靠，不关注程序架构，不会引入那些无用的垃圾代码。与其他框架相比这种简洁不可避免导致了部分功能缺失。</p>
</blockquote>
<p>Express 对 Node 的封装非常棒，主要来源于以下几个设计：</p>
<ul>
<li>中间件</li>
<li>路由</li>
<li>子应用</li>
<li>API函数易用</li>
</ul>
<blockquote>
<p>express 是一款轻快简洁的 node.js web 框架。其使用范围相当广泛，在web开发中，可以帮助我们快速开发web应用。</p>
</blockquote>
<p>通过 express 可以创建一个项目。 <code>express -e blog</code></p>
<h3 id="一、整体分析"><a href="#一、整体分析" class="headerlink" title="一、整体分析"></a>一、整体分析</h3><p>在 node 中，我们可以轻松启用一个服务器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    res.send(<span class="string">'hello world!'</span>);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;).listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure>
<p>但是在实际web应用开发过程中，我们需要服务器能监听各种不同的请求，并作出各自的处理。而 <strong>express</strong> 做的就是这样的事情。</p>
<p><strong>express</strong> 提供路由、中间件、引擎模板。帮助我们快速开发web应用。</p>
<h3 id="二、中间件-amp-路由"><a href="#二、中间件-amp-路由" class="headerlink" title="二、中间件 &amp; 路由"></a>二、中间件 &amp; 路由</h3><p><strong>中间件</strong> 是一种拦截器的思想，用于在特定的输入输出之前添加一些额外的处理。中间件的设计思想能够为许多架构提供灵活而强大的拓展性。</p>
<p><strong>中间件设计模型：</strong></p>
<ul>
<li><strong>尾递归：</strong> 中间件一个接一个的顺序执行, 习惯于将response响应写在最后一个中间件中；例如<code>express</code>。</li>
<li><strong>洋葱圈：</strong> 支持 <strong>generator</strong>, 执行顺序是“洋葱圈”模型。 例如<code>koa</code>（node web框架）。</li>
</ul>
<p><img src="/images/洋葱圈.png" alt></p>
<p>在 <strong>Express</strong> 中，中间件的本质就是一个函数，主要用于处理请求响应过程中执行一些操作。</p>
<p><img src="/images/express中间件.png" alt></p>
<h3 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h3><ul>
<li><a href="https://juejin.im/post/59bce35f5188257e70531ec0#heading-9" target="_blank" rel="noopener">Express 实战（一）：概览</a></li>
<li><a href="https://juejin.im/post/59bce48ef265da066c22fa3a" target="_blank" rel="noopener">Express 实战（四）：中间件</a></li>
<li><a href="https://juejin.im/post/59c0ef425188257e934966ad" target="_blank" rel="noopener">express源码阅读</a></li>
<li><a href="https://juejin.im/post/5aa345116fb9a028e52d7217" target="_blank" rel="noopener">Express中间件原理详解</a></li>
<li><a href="https://juejin.im/post/5b9a23a45188255c9c751b07" target="_blank" rel="noopener">redux, koa, express 中间件实现对比解析</a></li>
</ul>
]]></content>
      <categories>
        <category>原理说明</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title>https的握手过程</title>
    <url>/2019/04/01/2018/https%E7%9A%84%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>当我们在浏览器的地址栏，敲下 <code>https://www.example.com</code> 到页面内容展示到我们面前的这个过程中，浏览器经历了什么？</p>
</blockquote>
<a id="more"></a>
<h3 id="一、嗅探-VS-加密"><a href="#一、嗅探-VS-加密" class="headerlink" title="一、嗅探 VS 加密"></a>一、嗅探 VS 加密</h3><p>在网络链路的信息传输的过程中，如果通信链路中出现一个 <code>hacker</code>，那么明文展示的通信内容就会被 <code>hacker</code> 嗅探到，甚至通信内容都会被篡改。</p>
<p>为了防止明文泄密，那么就需要对明文进行加密，使得中间人无法获取信息。</p>
<p>目前主要分类两类加密方式：</p>
<ul>
<li><strong>对称加密：</strong> 加密和解密时使用相同的密钥，或是使用两个可以简单地相互推算的密钥。<blockquote>
<p>图示：<code>明文 &lt;-&gt; 密钥 &lt;-&gt; 密文</code><br>常见的对称加密算法有DES、3DES、AES、Blowfish、IDEA、RC5、RC6。<br>优点：加密速度快</p>
</blockquote>
</li>
<li><strong>非对称加密：</strong> 需要一对密钥（公钥和私钥）。任何人都可以拿到公钥进行明文加密，但是只有私钥持有者才能对密文进行解密。<blockquote>
<p>图示：<code>明文 -&gt; 公钥 -&gt; 密文  -&gt; 私钥 -&gt; 明文</code><br>优点：安全性更好 （暴力破解需要时间太长）</p>
</blockquote>
</li>
</ul>
<h3 id="二、认证"><a href="#二、认证" class="headerlink" title="二、认证"></a>二、认证</h3><p>虽然加密可以避免明文直接暴露，但是中间人还是可以欺骗双方的。例如浏览器向服务器请求时，中间人给你他的公钥，伪装成服务器与你通信。</p>
<p>现实生活中，个人可以通过政府发布的身份证进行证明。同样在虚拟的网络中，由大家都信任的 CA 组织，会给每个人出证明（<strong>电子签名(digital signature)</strong>，<strong>电子证书(digital certificate)</strong>）。</p>
<p>CA 组织将其他人的信息和公钥信息，用私钥加密成密文（即电子签名），签署到证书上即为电子证书。其他人通过 CA 的公钥进行解密，即可证明对方身份。在浏览器中，能够决定其他人的证书是否有效的公钥就是 <strong>根证书</strong>。</p>
<blockquote>
<p>虽然加密和认证能保证通信信息的保密性，但是却无法保证通信信息的完整性。 <strong>单向Hash函数</strong>可以把输入变成一个定长的输出串，其特点就是无法从这个输出还原回输入内容，并且不同的输入几乎不可能产生相同的输出，拥有很好的抗碰撞性。因此服务器只要将明文内容做一个Hash运算得到一个Hash值，并一起加密传递过去给客户端。Hacker即便篡改了内容，客户端解密之后发现拿到的内容以及对应计算出来的Hash值与传递过来的不一致，说明这个包的完整性被破坏了。</p>
</blockquote>
<p><img src="/images/一次可靠的通信.png" alt></p>
<h3 id="三、HTTPS三次握手"><a href="#三、HTTPS三次握手" class="headerlink" title="三、HTTPS三次握手"></a>三、HTTPS三次握手</h3><p>https的通信安全是建立在 SSL/TLS 协议上的。其基本过程为：</p>
<blockquote>
<ol>
<li>客户端向服务器端索要公钥并进行验证。</li>
<li>双方协议生成“对话密钥”。</li>
<li>双方通过“对话密钥”进行加密通信。</li>
</ol>
</blockquote>
<p>其中 1、2 两步又被称之为 “握手阶段”，涉及到四次通信，如图所示：</p>
<p><img src="/images/https三次握手.png" alt></p>
<h4 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h4><p>此时客户端向服务器发出加密通信的请求。同时客户端会提供自身信息，如：</p>
<ul>
<li>支持的协议版本</li>
<li>生成<code>session ticket 1</code>用于之后“对话密钥”的随机数</li>
<li>支持的加密方法</li>
<li>支持的压缩方法</li>
<li>请求域名（非必要，针对一台主机存在多个网站，例如虚拟主机用户）</li>
</ul>
<h4 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h4><p>此时服务器收到客户端请求后，向客户端发起响应。回应内容有：</p>
<ul>
<li>确认使用的加密通信的协议版本，如果客户端与服务器支持的版本不一致，服务器关闭加密通道。</li>
<li>服务器生成的随机数<code>session ticket 2</code>，用于之后“对话密钥”</li>
<li>确认使用的加密方法</li>
<li>服务器证书</li>
<li>客服端证书（非必要，一般金融机构只允许认证客户端连入自己的网络时，会向正式客户提供USB密钥，里面就包含了一张客户端证书。）</li>
</ul>
<h4 id="认证阶段"><a href="#认证阶段" class="headerlink" title="认证阶段"></a>认证阶段</h4><p>客户端收到服务器的回应后，首先会验证服务器的证书。如果证书没有问题，客户端会从证书中获取服务器的公钥，同时向服务器发送信息。</p>
<ul>
<li>一个用于服务器公钥加密的随机数<code>session ticket 3</code>（又称为<code>pre-master key</code>），防止窃听。</li>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
<li>握手通知结束，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。</li>
</ul>
<blockquote>
<p>有了这三个随机数，双方就可以利用事先商定的加密方法，各自生成本次会话所用的同一把“会话密钥”。<br>至于需要用到三个随机数的原因为增加随机性，具体可参考：<a href="https://blog.csdn.net/dog250/article/details/5717162" target="_blank" rel="noopener">ssl协议中的dh算法的pre-master-secret</a></p>
</blockquote>
<h4 id="内容传输阶段"><a href="#内容传输阶段" class="headerlink" title="内容传输阶段"></a>内容传输阶段</h4><p>服务器收到客户端的<code>session ticket 3</code>后，计算生成本次会话所用的“会话密钥”。然后向客户端发送消息。</p>
<ul>
<li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li>
<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。</li>
</ul>
<p>自此整个握手阶段完成。之后客户端和服务器进行加密通信阶段。即使用普通的<code>http</code>协议传输用“会话密钥”加密后的内容。</p>
<blockquote>
<p>上述过程中，Client Hello 和 Server Hello阶段均使用明文通信，只有协商密钥时，才使用非对称加密（非常消耗CPU）。通信阶段均采用对称加密。</p>
</blockquote>
<h3 id="四、整个过程"><a href="#四、整个过程" class="headerlink" title="四、整个过程"></a>四、整个过程</h3><p>当按下回车的整个过程，我们可以理解为：</p>
<ol>
<li>浏览器向服务器打招呼，同时提供<strong>随机数1</strong>和自身信息。</li>
<li>服务器向浏览器响应，提供<strong>随机数2</strong>和<strong>证书</strong>，确认<strong>加密方法</strong>。</li>
<li>浏览器对服务器回应的证书进行验证，如果通过则生成<strong>随机数3</strong>和<strong>会话密钥</strong>，并向服务器回应使用证书公钥加密的<strong>随机数3</strong>，否则断开连接。</li>
<li>服务器依据<strong>3个随机数</strong>和<strong>加密方法</strong>生成对应的<strong>会话密钥</strong>，结束整个SSL握手阶段。</li>
<li>浏览器和服务器进行通信，输出响应使用<strong>会话密钥</strong>加密的数据。</li>
</ol>
<h3 id="五、相关讨论"><a href="#五、相关讨论" class="headerlink" title="五、相关讨论"></a>五、相关讨论</h3><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/70" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/70</a></p>
<h3 id="六、相关阅读"><a href="#六、相关阅读" class="headerlink" title="六、相关阅读"></a>六、相关阅读</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/25587986" target="_blank" rel="noopener">HTTPs入门, 图解SSL从回车到握手</a></li>
<li><a href="https://developers.weixin.qq.com/community/develop/article/doc/000046a5fdc7802a15f7508b556413" target="_blank" rel="noopener">一次安全可靠的通信</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html" target="_blank" rel="noopener">SSL/TLS协议运行机制的概述</a></li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>https证书合法性验证</title>
    <url>/2019/04/01/2018/https%E8%AF%81%E4%B9%A6%E5%90%88%E6%B3%95%E6%80%A7/</url>
    <content><![CDATA[<blockquote>
<p>例如：一个新上线网站，购买了 <strong>CA</strong> 证书。用户通过浏览器去访问时，浏览器是如何校验证书的合法性，从而避免被中间人攻击。</p>
</blockquote>
<h3 id="一、证书的安全性"><a href="#一、证书的安全性" class="headerlink" title="一、证书的安全性"></a>一、证书的安全性</h3><ul>
<li>证书存在的目的就是<strong>避免中间人攻击</strong>，避免发生经典的传令兵问题。</li>
<li>证书都是由<strong>CA组织</strong>下认可的<strong>根证书Root</strong>签发的。该组织会对每年每个CA签发的证书进行审核，因此可以保证正常途径签发的证书根是绝对可信的。</li>
<li>证书分为<strong>DV</strong>(Digital Verification)，<strong>OV</strong>(Organization Verification)和<strong>EV</strong>(Extended Verification)几类，其中EV证书最贵，可以在浏览器中看到绿色的就是EV证书。</li>
<li>证书是需要<strong>预装</strong>的，特别是根证书。IE和Chrome是通过内置在Windows系统中的TrustStore来管理根证书（当然自己也可以手动导入自签证书，浏览不会认可的因为有OCSP和CRL–之后细讲）；而Firefox则是内置在自己的浏览中。</li>
</ul>
<h3 id="二、证书的校验"><a href="#二、证书的校验" class="headerlink" title="二、证书的校验"></a>二、证书的校验</h3><p>浏览器在校验证书的合法性时，主要是通过两个方向进行校验的：</p>
<ol>
<li>证书是否为<strong>值得信任</strong>的<strong>有效</strong>证书。所谓信任是指，web服务器的证书是否为信任根（浏览器内置有信任的根证书）或信任根的二级证书机构颁发的。所谓有效是指，web服务器的证书是否在有效期内，是否已被吊销。</li>
<li>web服务器的证书是否为其合法持有者。需要证明对方是否持有<strong>证书对应的私钥</strong>。验证方式有两种：<ul>
<li>对方签名，浏览器用证书对签名进行验证。</li>
<li>使用证书作为信封，判断对方是否能够解开。</li>
</ul>
</li>
</ol>
<p>上述校验过程中，校验证书是否已被吊销需要和 <strong>CA</strong> 关联，其他均可由浏览器完成。验证证书是否吊销可以采用<strong>CRL</strong>黑名单方式或者<strong>OCSP</strong>方式。</p>
<ul>
<li><strong>CRL</strong>黑名单就是定期从CA下载一个名单列表，里面有吊销的证书序列号，自己在本地比对一下就行。优点是效率高。缺点是不实时。</li>
<li><strong>OCSP</strong>是实时连接CA去验证，优点是实时，缺点是效率不高。</li>
</ul>
<h3 id="三、证书的工作原理"><a href="#三、证书的工作原理" class="headerlink" title="三、证书的工作原理"></a>三、证书的工作原理</h3><p>以 <a href="https://www.google.com" target="_blank" rel="noopener">https://www.google.com</a> 为例：</p>
<ol>
<li>浏览器发现协议为 <code>https</code>，握手拿到 google 的证书，先从系统（window）或浏览器内置（Firefox）检查证书链是否正确。</li>
<li>如果验证失败则会拦截。</li>
<li>浏览器尝试查<strong>CRL</strong>(证书吊销列表)和<strong>OCSP</strong>(在线证书检查)。<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>CA不会直接暴露到外网的，如果需要访问CA服务器需要使用硬件Token并且多人在场录像，且只能远程访问。OCSP相当于证书数据库的备份而已是直接暴露在外网的可以通过HTTP或者HTTPS访问。</li>
<li><strong>OCSP</strong>是一种新技术。部分客户端可能不支持，仅支持 <strong>CRL</strong>。</li>
</ul>
</blockquote>
</li>
<li>如果发现证书并没有被吊销或者过期则浏览器对EV证书会显示为绿色，对OV证书则是通过放行。否则弹出通知，该网站不可信。</li>
</ol>
<p><strong>检查流程：</strong></p>
<ol>
<li>客户端发送信息，带上支持的SSL或者TLS版本（不同浏览器支持程度不同）。</li>
<li>服务器返回确认使用的加密通信协议版本以及加密随机数和CA证书。</li>
<li>浏览器验证证书（存在双向验证和单项验证） -&gt; OCSP或者CRL 结合自带truststore。</li>
<li>检查CA证书的根证书颁发机构是否受浏览器信任。</li>
<li>检查CA证书中的证书吊销列表，检查证书是否被吊销。</li>
<li>检查CA证书是否在有效期内。</li>
<li>检查部署CA证书的网站域名与证书颁发的域名是否一致。</li>
<li>浏览器核对该网站是否存在于欺诈网站数据库中。</li>
</ol>
<h3 id="四、相关阅读"><a href="#四、相关阅读" class="headerlink" title="四、相关阅读"></a>四、相关阅读</h3><ul>
<li><a href="https://www.zhihu.com/question/37370216" target="_blank" rel="noopener">浏览器如何验证HTTPS证书的合法性</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25587986" target="_blank" rel="noopener">HTTPs入门, 图解SSL从回车到握手</a></li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql备忘录</title>
    <url>/2018/02/12/2018/mysql%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<h3 id="MYSQL常用命令"><a href="#MYSQL常用命令" class="headerlink" title="MYSQL常用命令"></a>MYSQL常用命令</h3><p>1、 数据库</p>
<ul>
<li><code>show datatables</code> 显示所有数据库。</li>
<li><code>create databse &lt;数据库名&gt;</code> 创建数据库。</li>
<li><code>drop databse &lt;数据库名&gt;</code> 删除制定数据。</li>
<li><code>use &lt;数据库名&gt;</code> 连接某数据库。</li>
</ul>
<p>2、 数据表</p>
<ul>
<li><p><code>create table &lt;表名&gt; ( &lt;字段名1&gt; &lt;类型1&gt; [,..&lt;字段名n&gt; &lt;类型n&gt;])</code> 创建数据表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table MyClass(</span><br><span class="line">id int(4) not null primary key auto_increment,</span><br><span class="line">name char(20) not null,</span><br><span class="line">sex int(4) not null default &apos;0&apos;,</span><br><span class="line">degree double(16,2));</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rename table 原表名 to 新表名;</code> 更新数据表名称。</p>
</li>
<li><code>drop table &lt;表名&gt;</code> 删除数据表，并取消其关联。</li>
<li><code>insert into &lt;表名&gt; [( &lt;字段名1&gt;[,..&lt;字段名n &gt; ])] values ( 值1 )[, ( 值n )]</code>  向指定数据表插入数据。</li>
<li><code>select &lt;字段1，字段2，...&gt; from &lt; 表名 &gt; where &lt; 表达式 &gt; order by &lt;字段&gt; limit 0,2;</code> 选择指定的数据。</li>
<li><code>delete from 表名 where 表达式</code> 删除指定数据。</li>
<li><code>update 表名 set 字段=新值,… where 条件</code> 更新指定的数据。</li>
<li><code>alter table 表名 add字段 类型 其他;</code> 可利用该命令进行字段处理。</li>
</ul>
<p>3、数据备份</p>
<ul>
<li><h3 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h3></li>
<li><p><code>utf_bin</code> 中，<code>bin</code>指的是二进制。而<code>utf_general_ci</code>中<code>ci</code>是 case insensitive，即大小写不敏感的意思。</p>
</li>
<li><code>utf8_unicode_ci</code> 和 <code>utf8_general_ci</code> 对中、英文来说没有实质的差别。<code>utf8_general_ci</code> 校对速度快，但准确度稍差。<code>utf8_unicode_ci</code> 准确度高，但校对速度稍慢。如果你的应用有德语、法语或者俄语，请一定使用<code>utf8_unicode_ci</code> 。一般用 <code>utf8_general_ci</code> 就够了，到现在也没发现问题。</li>
</ul>
]]></content>
      <categories>
        <category>文档备忘录</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>php小结</title>
    <url>/2018/04/09/2018/php%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h2 id="对自己15年所学php内容简单小结"><a href="#对自己15年所学php内容简单小结" class="headerlink" title="对自己15年所学php内容简单小结"></a>对自己15年所学php内容简单小结</h2><h3 id="初识PHP"><a href="#初识PHP" class="headerlink" title="初识PHP"></a>初识PHP</h3><p><strong>PHP</strong>（“PHP: Hypertext Preprocessor”，超文本预处理器的字母缩写）是一种被广泛应用的开放源代码的多用途脚本语言，它可嵌入到 HTML中，尤其适合 web 开发。</p>
<p>PHP 代码是运行在服务端的。</p>
<p>PHP作用领域：</p>
<ol>
<li>服务端脚本。（PHP 解析器（CGI 或者服务器模块）、web 服务器和 web 浏览器）  </li>
<li>命令行脚本。可以编写一段 PHP 脚本，并且不需要任何服务器或者浏览器来运行它。通过这种方式，仅仅只需要 PHP 解析器来执行。</li>
<li>编写桌面应用程序。可以利用 PHP-GTK 来编写这些程序。用这种方法，还可以编写跨平台的应用程序。PHP-GTK 是 PHP 的一个扩展，在通常发布的 PHP 包中并不包含它。</li>
</ol>
<p>php文件的默认拓展名 <code>.php</code></p>
<p>配置信息查询 <code>phpinfo()</code></p>
]]></content>
      <categories>
        <category>自我小结</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>promise</title>
    <url>/2019/03/20/2018/promise/</url>
    <content><![CDATA[<blockquote>
<p>Promise 对象用于表示一个异步操作的最终状态（完成或失败），以及该异步操作的结果值。</p>
</blockquote>
<h3 id="作业队列"><a href="#作业队列" class="headerlink" title="作业队列"></a>作业队列</h3><p>### </p>
<h3 id="实现一个最小程度的promise"><a href="#实现一个最小程度的promise" class="headerlink" title="实现一个最小程度的promise"></a>实现一个最小程度的promise</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CreatePromise</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>._state = <span class="string">'pending'</span>; <span class="comment">// 状态</span></span><br><span class="line">    <span class="keyword">this</span>._dependencies = []; <span class="comment">// 依赖关系</span></span><br><span class="line">    <span class="keyword">this</span>._value = <span class="literal">null</span>; <span class="comment">// 处理数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> cb === <span class="string">'function'</span>) &#123;</span><br><span class="line">        cb &amp;&amp; cb(<span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.fulfill(value);</span><br><span class="line">        &#125;, err =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>.reject(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成</span></span><br><span class="line">CreatePromise.prototype.fulfill = <span class="function"><span class="keyword">function</span> <span class="title">fulfill</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._state !== <span class="string">'pending'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Trying to fulfill a non-pending promise!'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._state = <span class="string">'fulfilled'</span>;</span><br><span class="line">        <span class="keyword">this</span>._value = value;</span><br><span class="line">        <span class="keyword">this</span>._dependencies.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            item.fulfilled &amp;&amp; item.fulfilled(<span class="keyword">this</span>._value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败</span></span><br><span class="line">CreatePromise.prototype.reject = <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._state !== <span class="string">'pending'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Trying to fulfill a non-pending promise!'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._state = <span class="string">'rejected'</span>;</span><br><span class="line">        <span class="keyword">this</span>._value = error;</span><br><span class="line">        <span class="keyword">this</span>._dependencies.forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">            item.rejected &amp;&amp; item.rejected(<span class="keyword">this</span>._value);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加依赖 depned  then?</span></span><br><span class="line">CreatePromise.prototype.depend = <span class="function"><span class="keyword">function</span> <span class="title">depend</span>(<span class="params">onSuccess, onFailure</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> CreatePromise();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 操作未完成，将其放入依赖列表</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._state === <span class="string">'pending'</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._dependencies.push(&#123;</span><br><span class="line">            fulfilled: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">var</span> newValue = onSuccess &amp;&amp; onSuccess(value);</span><br><span class="line">                    result.fulfill(newValue);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    result.reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            rejected: <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    onFailure &amp;&amp; onFailure(error);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                    result.reject(err);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>._state === <span class="string">'rejected'</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                onFailure &amp;&amp; onFailure(<span class="keyword">this</span>._value);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                result.reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>._state === <span class="string">'fulfilled'</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">var</span> newValue = onSuccess &amp;&amp; onSuccess(<span class="keyword">this</span>._value);</span><br><span class="line">                result.fulfill(newValue);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">                result.reject(err);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发处理</span></span><br><span class="line">CreatePromise.prototype.all = <span class="function"><span class="keyword">function</span> <span class="title">all</span>(<span class="params">p1, p2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> CreatePromise();</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="number">0</span>; <span class="comment">// 0 表示都未开始，1 表示有一个成功了 2 表示都成功了 -1 表示有一个失败了</span></span><br><span class="line">    <span class="keyword">var</span> params = [];</span><br><span class="line">    p1.depend(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        flag++;</span><br><span class="line">        params[<span class="number">0</span>] = value;</span><br><span class="line">        <span class="keyword">if</span> (flag === <span class="number">1</span>) &#123;</span><br><span class="line">            result.fulfill(params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag === <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        flag = <span class="number">-1</span>;</span><br><span class="line">        s</span><br><span class="line">        result.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line">    p2.depend(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        flag++;</span><br><span class="line">        params[<span class="number">1</span>] = value;</span><br><span class="line">        <span class="keyword">if</span> (flag === <span class="number">1</span>) &#123;</span><br><span class="line">            result.fulfill(params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag === <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        flag = <span class="number">-1</span>;</span><br><span class="line">        result.reject(err);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">all</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> CreatePromise();</span><br><span class="line">    <span class="keyword">var</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length;</span><br><span class="line">    <span class="keyword">var</span> params = [];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">p, index</span>) </span>&#123;</span><br><span class="line">        p.depend(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            flag++;</span><br><span class="line">            params[index] = value;</span><br><span class="line">            <span class="keyword">if</span> (flag === len) &#123;</span><br><span class="line">                result.fulfill(params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag === <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">            flag = <span class="number">-1</span>;</span><br><span class="line">            result.reject(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有一个成功，便返回成功</span></span><br><span class="line">CreatePromise.prototype.race = <span class="function"><span class="keyword">function</span> <span class="title">race</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> CreatePromise();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> len = <span class="built_in">arguments</span>.length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">p, index</span>) </span>&#123;</span><br><span class="line">        p.depend(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag !== <span class="number">-1</span>) &#123;</span><br><span class="line">                flag = <span class="number">-1</span>;</span><br><span class="line">                result.fulfill(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (flag === <span class="number">-1</span> || flag === len - <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">            flag ++;</span><br><span class="line">            result.reject(err);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>reduce</title>
    <url>/2019/03/06/2018/reduce/</url>
    <content><![CDATA[<p>原问题为：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[ [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>].reduce(<span class="built_in">Math</span>.pow), [].reduce(<span class="built_in">Math</span>.pow) ] <span class="comment">// TypeError</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ary = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>];</span><br><span class="line">ary[<span class="number">10</span>] = <span class="number">10</span>;</span><br><span class="line">ary.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x === <span class="literal">undefined</span>;&#125;); <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> two   = <span class="number">0.2</span></span><br><span class="line"><span class="keyword">var</span> one   = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">var</span> eight = <span class="number">0.8</span></span><br><span class="line"><span class="keyword">var</span> six   = <span class="number">0.6</span></span><br><span class="line">[two - one == one, eight - six == two] <span class="comment">// [true, false]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.isArray( <span class="built_in">Array</span>.prototype ) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span> ([<span class="number">0</span>]) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a == <span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"wut"</span>);</span><br><span class="line">&#125;  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + - + + + - + <span class="number">1</span> <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ary = <span class="built_in">Array</span>(<span class="number">3</span>);</span><br><span class="line">ary[<span class="number">0</span>]=<span class="number">2</span></span><br><span class="line">ary.map(<span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123; <span class="keyword">return</span> <span class="string">'1'</span>; &#125;); <span class="comment">// ['1', undefined, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">111111111111111110000</span>,</span><br><span class="line">    b = <span class="number">1111</span>;</span><br><span class="line">a + b <span class="comment">// 111111111111111110000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = [].reverse;</span><br><span class="line">x(); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>toString()</span><br><span class="line"><span class="number">3.</span>.toString()</span><br><span class="line"><span class="number">3.</span>..toString() <span class="comment">// error, "3", error</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;, b = <span class="built_in">Object</span>.prototype;</span><br><span class="line">[a.prototype === b, <span class="built_in">Object</span>.getPrototypeOf(a) === b] <span class="comment">// [false, true]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; &#125;</span><br><span class="line"><span class="keyword">var</span> oldName = foo.name;</span><br><span class="line">foo.name = <span class="string">"bar"</span>;</span><br><span class="line">[oldName, foo.name] <span class="comment">// ["foo", "foo"]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> parent = <span class="built_in">Object</span>.getPrototypeOf(f);</span><br><span class="line">f.name <span class="comment">// ?</span></span><br><span class="line">parent.name <span class="comment">// ?</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">eval</span>(f.name) <span class="comment">// ?</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">eval</span>(parent.name) <span class="comment">//  ? // ["f", "Empty", "function", error]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> lowerCaseOnly =  <span class="regexp">/^[a-z]+$/</span>;</span><br><span class="line">[lowerCaseOnly.test(<span class="literal">null</span>), lowerCaseOnly.test()] <span class="comment">// [true, true]</span></span><br><span class="line"></span><br><span class="line">[,,,].join(<span class="string">", "</span>) <span class="comment">// ", , "</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">class</span>: <span class="string">"Animal"</span>, <span class="attr">name</span>: <span class="string">'Fido'</span>&#125;;</span><br><span class="line">a.class  <span class="comment">// other  在不同浏览器中效果不同</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"epoch"</span>) <span class="comment">// </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Function</span>.length,</span><br><span class="line">    b = <span class="keyword">new</span> <span class="built_in">Function</span>().length</span><br><span class="line">a === b <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">captureOne</span>(<span class="params">re, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> match = re.exec(str);</span><br><span class="line">  <span class="keyword">return</span> match &amp;&amp; match[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> numRe  = <span class="regexp">/num=(\d+)/ig</span>,</span><br><span class="line">    wordRe = <span class="regexp">/word=(\w+)/i</span>,</span><br><span class="line">    a1 = captureOne(numRe,  <span class="string">"num=1"</span>),</span><br><span class="line">    a2 = captureOne(wordRe, <span class="string">"word=1"</span>),</span><br><span class="line">    a3 = captureOne(numRe,  <span class="string">"NUM=2"</span>),</span><br><span class="line">    a4 = captureOne(wordRe,  <span class="string">"WORD=2"</span>);</span><br><span class="line">[a1 === a2, a3 === a4] <span class="comment">// [true, false]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"2014-03-19"</span>),</span><br><span class="line">    b = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2014</span>, <span class="number">03</span>, <span class="number">19</span>);</span><br><span class="line">[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()] <span class="comment">// [false, false]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">'http://giftwrapped.com/picture.jpg'</span>.match(<span class="string">'.gif'</span>)) &#123;</span><br><span class="line">  <span class="string">'a gif file'</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="string">'not a gif file'</span></span><br><span class="line">&#125; <span class="comment">// 'a gif file'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="相关参考："><a href="#相关参考：" class="headerlink" title="相关参考："></a>相关参考：</h3><ul>
<li><a href="http://javascript-puzzlers.herokuapp.com/" target="_blank" rel="noopener">do you really know JavaScript? 小测验</a></li>
</ul>
<h3 id="自我总结："><a href="#自我总结：" class="headerlink" title="自我总结："></a>自我总结：</h3>]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>Vuex 状态管理</title>
    <url>/2020/06/28/2018/vuex/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前端组件化开发中，一般情况下都是采用单向数据流的方式。即 state -&gt; view -&gt; action -&gt; state。这种方式在多视图情况下，<br>常会涉及多组件之间通信（数据共享）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://vuex.vuejs.org/zh-cn/mutations.html" target="_blank" rel="noopener">Vuex 手册</a></li>
</ul>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="state-单一状态树"><a href="#state-单一状态树" class="headerlink" title="state (单一状态树)"></a>state (单一状态树)</h3><p>即利用一个对象包含全部应用的数据源。</p>
<h5 id="结合vue："><a href="#结合vue：" class="headerlink" title="结合vue："></a>结合vue：</h5><ul>
<li>在vue中，可以利用计算属性来返回某个状态。这样每当状态发生变动时，都会重新计算。不过这种方式会导致组件依赖全局状态单例，同时每个需要state的组件都需频繁导入。</li>
<li>利用 vuex 将 store 从根组件“注入”到每一个子组件中。这样子组件就能通过 <code>this.$store</code>访问。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">    el: &apos;#app&apos;,</span><br><span class="line">    store, // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件</span><br><span class="line">    components,</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>tips:</strong><br>单一组件涉及到多个状态，可以利用<code>mapState</code>辅助函数减少计算属性的重复和冗余。<br>不必要的局部状态最好还是作为组件的一部分。需依据开发进行权衡和确认。</p>
</blockquote>
<h3 id="Getter-（vuex的“计算属性”）"><a href="#Getter-（vuex的“计算属性”）" class="headerlink" title="Getter （vuex的“计算属性”）"></a>Getter （vuex的“计算属性”）</h3><p>合理的利用 Vuex 的 Getter 能更加方便地访问满足条件的state，尤其是列表的 state。</p>
<blockquote>
<p><strong>tips:</strong><br>可以利用 Getter 返回一个函数实现传参。（柯里化）<br>可以利用 mapGetters 辅助函数来对 Getter 建立一个别名。（感觉用处不是很大）</p>
</blockquote>
<h3 id="Mutation-（类似事件）"><a href="#Mutation-（类似事件）" class="headerlink" title="Mutation （类似事件）"></a>Mutation （类似事件）</h3><p>在 Vuex 中更改 state 的唯一方式就是提交 mutation。每个 mutation 都有一个字符串的<strong>事件类型 (type)</strong>和 一个<strong>回调函数 (handler)</strong>。当然不能直接调用一个 mutation handler。要唤醒一个 mutation 可以调用<code>store.commit(type)</code>。 </p>
<p>mutation 必须是同步函数。（同步事务）</p>
<blockquote>
<p><strong>tips:</strong><br>可以向<code>store.commit</code>传入额外的参数实现提交荷载（payload），但是大多数情况下，荷载应该是一个对象，这样既可以包含多个字段，同时也会使得 mutation 更易读。<br>对象风格的提交方式: 提交 mutation 的另一种方式是直接使用包含 type 属性的对象。即<code>store.commit({ type: &#39;increment&#39; })</code>。这样整个对象都作为载荷传给 mutation 函数，因此 handler 保持不变。<br>使用常量替代 mutation 事件类型，能在多人合作时，使得合作者对整个 app 的 mutation 一目了然。<br>在组件中提交 mutation 时，可以使用<code>mapMutations</code>辅助函数将组件中的方法<code>methods</code>映射为<code>store.commit</code>。</p>
</blockquote>
<h3 id="Action-支持异步提交"><a href="#Action-支持异步提交" class="headerlink" title="Action (支持异步提交)"></a>Action (支持异步提交)</h3><p>action提交的是 mutation ，并非直接变更状态。</p>
<p>其中 action 会接受一个与 store 实例具有相同方法和属性的 context 对象。当然 action 和 mutation 一样都不能直接操作，需要通过 <code>store.dispatch</code> 触发。</p>
<blockquote>
<p><strong>tips:</strong><br>actions 支持同样的载荷方式和对象方式进行分发。<br>在组件中分发 action 时，可以使用<code>mapActions</code>辅助函数将组件中的方法<code>methods</code>映射为<code>store.dispatch</code>。<br>注意：组合 action 时，可以利用 promise、action内部调用，以及 async / await 的方式。</p>
</blockquote>
<h3 id="Module-模块"><a href="#Module-模块" class="headerlink" title="Module (模块)"></a>Module (模块)</h3><p>由于整个应用使用的是同一个状态树，当应用过于复杂时，store 对象就会相当臃肿。 vuex中提供 module 将 store 进行分割，每个 module 都拥有自己的 state、getter、mutation、action，甚至是嵌套子模块。</p>
<p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。对于模块内部的 getter，根节点状态会作为第三个参数暴露出来。同样对于模块内部的 action，局部状态通过<code>context.state</code>暴露出来，根节点状态则为<code>context.rootState</code>。</p>
<blockquote>
<p><strong>命名空间：</strong><br>默认情况下，模块内部的 action、mutation 和 getter 是注册在全局命名空间的——这样使得多个模块能够对同一 mutation 或 action 作出响应。<br>如果希望你的模块具有更高的封装度和复用性，你可以通过添加 namespaced: true 的方式使其成为命名空间模块。当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名。</p>
</blockquote>
<p>模块可以进行动态创建。例如 vuex-router-sync 插件就是通过动态注册模块将 vue-router 和 vuex 结合在一起，实现应用的路由状态管理。</p>
]]></content>
      <categories>
        <category>前端开发框架+库</category>
      </categories>
      <tags>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>个人简历</title>
    <url>/2019/04/21/2018/%E4%B8%AA%E4%BA%BA%E7%AE%80%E5%8E%86/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="个人简历访问密码" />
    <label for="pass">个人简历访问密码</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
U2FsdGVkX1+pTE0PWB7/oH+MzELJP4g+DPu6lAjZ+w8WZHZCTYkDy9NnSv21ELM1U/N4l419QScijta1AVFXPUwzHabXibqSG8Vob/oQJbUEFn9A/72wVN7F+05BzWN8Yl3Cco9ki+ycXDbGBM78LfbuaRdTiwi//fZXLzXBHEIp88IwQRchIXZg71a+DIzhwtJO2AFRWf4Ff44+gmh9Fis+NtJPGvab2pnActDB0B2zebFPPXqqJf/fdxftCbeLwvVNaPbcI4QNPYsIKmw+Z/GfzIfnMzThaiiqCEDqIZtr38QGvzwE20TC5ahgwsYX2CZxqdW+f5KtODeVeyOh2mIBEmP44xIefqlJEptMUozS/J0Y8vWG+POXly4LDHPx4PDmMZlq1i7LYbp/TlYzgQ24Rf4Eev7ITbMaRtf/6GVGaXNoWECy+gnYs0S9OEDDKnN4ZbrA/hA3zRce6kwZK73OY1R6okKC+zkfcApBCpdqITsv4rhm/5UYX/+xZgfQ6IyO8jErGhgpzaNvwF1VX3EbsvWBidAiGFY0GaGJhjTOE9lR/Jed/5/BaM3RQhFWC9DKHe9obqN+f776AVPXBPt7jvlQ46Ea4VYuLeXS47krN/Y3bdGjqrE+0ZqP8c5Gcd7+Xj9THva0TUv624B9Gz/XLTFkR9TnvGpB7NhX1Wq9PBmJ+KjdNC+CwgBcPymq+XwAHxOAKKcJQU+nOKDq/3IXPR/g3ms7pK0UvUdtgADPnPJsfNyMvpmr5MyrPNMnop/+vK2ZfnfI0bW6EHYEg6rLlaHRLXPyWiedN73hNTaK4RVei2q3ToqthP5QTO2oLz0tH/rj2tZ1CCQRuQm2YEjGQj4uYgE/B7IPuCeBSV2WfnHzbeg4riE10eOa5K0aiCAeaaTSUv0TBiwaRz0xlvTJJYDfMZ9mz6pyY9S8EDVyeFisbQ2eYWowOCGehWGP+AHwgwfDaGrYjJaw01eBbMTQ0e9VKxqWKNXkbvBUj8hrdr4smCyujAc0BojfgiZ/8vKYoYyU0eJKz3xwsAx0nh26bOXZK9fbLlHeLhVYvfKhafZ/KzWxeYkPKa9TM5QkhM2yZo3OQJrMwoVVdYnL9VoQR2XrABepJc2qHjODykDqEJH2OHMmaXIY9aLQloQ500qYYEVXJ/xFnsCYlJLZC3GKM6bcJoUax0qX3GufvpGT2RpOJC4OAD/vTaIGeo78iqaqM5b22/Hn8YprRGjU0lY0Y3yh3uspRuQa2MWqZvSUaOZowrpXLqVjKG/k3eo6XC/4Mfjetu4hvkYAsXOBbnQPybRAWW8Za4MSHQMDIAR7LFTE0Ikw/oDS1Qb1BTyEPMUKOEZsO1eW7FMblBaosqGLh0PvIUQrO2iHggkG/vp6afAl8SZXLFxxF6F2vkgaNOQvXIwIL79L4rhTRePBi/IQWA9tvWLmjbsTiFKVnLliIge4JCmOqJENtUAw+5eVgqGvnxPoSuT+CoIoENOzBlnt2xJoPT2rwrUWi5Jl+360RNFzGkAettPrv1tIl47mN1bxs/qO8NZ+ezFJB4EctNH1fb+Cf1T5HaKpbpBfK7EFLOK+4cJ7H2My7SJ/8PMz2ns09B7IxOIAIDgS1Hdvet8rckAdUEzyZs3X83yyUyTnzcLSBMznZJ+e5Ypp+m7nWsRJ59J9gJ4bV3iEpHYjgyuoXUZkwfCu2bC/QaCNOA8VRvqa6TtQOJcUsZujkNJO5KfNI/DZzaDvWU8JVoniGu9DT+BhwLKcmFwadOymh5AI5uy5SgaTwbXjo/sMD64L7iOxjtEkjYqK4jwytmoOiMzf6p62qMxW4q8k6rHvoo1onkg9Dioz08U4a84LDMJU5HfHLsvSr737zgtI54nw3kcc7YpgMdp8LE2C1B+pt07Wzwa1+p0hi3fc8dE9IkqAsRu3bgSDeBqVgkKYAK8sEmWFfAzSMjSijf9UCbO6TTHZW81Cs/8cJs47C5Avxs7ZEkVmPfjIeNF2yLmB0YEIut5wBUXdQbZxgtUGrTSoQlO8d30vf8DlLbhHE6upQb8Aq23DPmqTaE79Y7YEqtSMskHYAI85uQ7aMPq9guZ0nSvYryElgjNpJlRHzJeKthfjxpJvvJp00nVsTWmZj3kN0vI3kLb+dZ2TulLGfV9OOhuN8Rytk6s6BKTVOA3NAaM+x8v+TTJP6OBR0eqLxIYQ+NSPMMdXZYEBDr1/b9l4QyPRi+KSPXAYpp8+rPi5Y9/0ej3c7TjEGPvCQ09lRX4+9szrwey7SlZFk8z1rztTybwZqmLV2Ga7dfJKJ62w1tZOSwxuluyO4k5YEdaciuv13Nim1gjBVF8iZyqvBgWzQKNwlZzBlKVA1pmMJMkZwpo9f0Q/QXe0OMf2gKwkpzrsqOV6/p0dXMyVUIFcor/T/YcPEm9rlYqP5HiCllxsGzFeZcGmPZIIr56fkjaqbF921NInbtuitqx1Qg/LN5Jp6RGPCNNRnmMog+iWzbYQekiAxxmMfrIGCqYA1KgPhBXP6aMqBvaOA8Er+KMMzYuNPjCiy9O4Se2L+c4xr+AgTQSOaraNdZ1U/ci6sDwBACu8e2OFUsSdjDYQrr2GBw0AYZGYmyA+IWHFUj/FSOKu14pOXbe6q/De6v6V/bZM4yXsl03rGDAA11a2IdvhstFhEXxEI+NTgTzk6caEz4zJq6M0OqlcKjqxcKo5URpawln605/h9DH3AwO71CUm99iqVLp2LbuDmTcnu8U1t9ZO3ZkG6SoL7l4d95gxZkFhVqcgYibaARxLZTdVM6/FcR60MWcK7xsKI6dnC0dC3B8BiWSZvXJB9/L2YKulnOVRuDms6LgDYM5a/TJA9jN/o3v1lIxcWHlN5r/e7A+2Ouv9q5OlokcKT6fSxTiMBFm2v3XcJfmR2KZdIw3hBXoHLExuj4jRyuVyIlwTBXrzv5T3BfmckpTDTSOjEhstWtfOj9evURcoklbS9q04VP3gqJBV6iptGmEYKfqo5Siv8DdWT7xQz/pw7w3wzL2GgxpVx8EC9c0fRUQXD4ncgThAoksPqIFr+2zdGK9fkFyG4GaKQ5u98SnCfg5LLfyYyye8xuJBGOhbA2TyFl37aEjGTdEoeqWcBJjw4JPImlQ8Brk5qYQf6VPhYPup+aaFFxF4Aqb5COs+Z4dBx19N9U/itWGNGw/jR57w2J6HzcgD4x5QgrMiLXlPw1llmiaaFi7hZopLsciC93LDWet65dpeJuiiE725zT6GRSWVCvhcEw5gvQesXYeNd56gPCAe5IMG/lDmMXcx2y2CKhtmn8Zx5qBQyNAED8NB5FhCewjKOImoJC0zbBPzQwxtsSJDXNk3zsyrH93gSbIKn9FQIrScJWZXla62qmaYVc5ccjvQKs/1nSAUdDTbt3CzevemauhFnnCEtd+uBStLIz9UL3Qo0WeQFuYZSRL73AaVeiBxb1EM4SclaaqRyjHkrTrmYXbQWed1dNpaMsCsQJN4fHpgUN+g7uyIssFoYR6OFArVQT7KI19DDDCFNQV58+IXJoDvVgRQyVt10a72xLapLvvH9ieth/X5D/NQPHHDIODIXcIpE4HI+x9mqOsCS9kispzvc2SFO5D3dKrQ1USsoBmSlSkwo4VeGDiViEklRgLrmx+uryLwOuDDcXNhf4PWdYFBlVxj0B2LJJdwzWX/NExAvJn1N9VXCgH+jAjIhuWO67NKDNdon3cQorDJ3l3a70SONf9k0Xw832fGAteSw/9oBK+UJkvmGlh4yxS+9fi0T/C5UrdSi/SbTWFDyDXvAYn7QGKmyS2KezFrkgQtgqYjyn8QWxVy4oDMMU/Ks3CbK2UVV03KCgV6l8oi1Uh+eZLo7Q5OvH6oukjRwx8TLZ+0wspJS98WEItG6ShF4d+4ZcknulAv47mVy+mH8HPPUV/54BD/lcFyI6wJ7WrGd7AY4u5AJfrQGAd4MVMNJJ9XI2QtTnFiSzRn5QXdOrznnKCL3xNR/r4b9FUDpSALxkvrORFbnCaE6mHunVHMws67d9TSFXMX3uigf6sleYQnggOcLG+OpakoBmAb1jHzGN2984/XncZ+SSF3Uj+FM/D3b8PWvasGLRvEcbIzu6hN39HtVliNXJ8cO38XPqFah3UqL0182dB2l7+joA6biUHkOgIdyXadSdURtJbrwIXiIECky9hcIpOcIW4tPI9mGBsK47oiNuD9HUkQsGMpu0WnacpHerDdD9vDbsFoDT0VbXqyEUfTLFaWCxAgWX7Ci9nQyzsOZoYeE9X173z7FULIb2VcIEFv6ozeAar77SD9hGZDprvN4Cno9AkZ/er2t3wVCSxjMWxvQDZsTQiHgpnuNvJrFg3EH5g9vGOG4hb2V84YyhUMZlq4sRi1UKyIA1ZrMQ3LXEswD0NG6eJNipP1Zl4AFcZnGXCoFgOk7WQK7mP2aBs2vcn+jpCA5pMV6ntDnvCf7VCI130yFxnol9v0NLd9LmeNRQb8gDv5XbhjdZP+y/ZlrvS9SmR+NRgSA/1tRjZEFJF2QHbS5rTbWifOaI2HMNlSwYgDAtxUsWtQgpAtR5wLJ4Zuz4X9uDRDSxsyEtrTd47hTZiNNxbXQnTvjlY9ki8J7h0Of5jRXCT/TqJkkPiS6Yb9l6mNXKsFAGJ5h+fU8LJS5PwFRezs2yEsuc5NwJbWCnkVW8tXfHOkIRqlQmD0HoL7mt8CUqcdi0CYvGVlkRdGkHjbUwhk1yPhDhnVbU7STVuAmTEM8rZEHPj7mT09ehPpsH4tLSMx/mR6Tx4Cn26KBbAHMHUjPXO9tFND61LN4irk60jEPwd6RRDM4hcFuJ8tYAS+F6oZRzwtsxVKMHLBcg0npwkEEQgbVdVco93qnGmy1K+SSWu4T5wFyeeh8Z0Wx53JW6EZ4pMwp9uOP3LoqpaQ4rZNaoCwgaU49NbTG5kC4yE+2q5n6yfYFb9fF7/XgagsH4Few0OPEhKIzf22zaI5VtSH990DKt6TyAmJ5C1w4lWk0QlMw1BpZz3MWmloyNw8sxC222UJyV+XX4LcUu/n5R/6kZ8SqEORI60nnpuGRA/yzDiOh2u1YqiN5L1vQg1KO6dnOj3kg09JV4HDlHdFecySR+lbmfC6rOPC2ade4FVhNdhG1x/XG4JLgXnNnsJ6cIwOqFOZpL4gUkP0voBxBZRuZxw8nKQs2pzpaVp5cWYWok78nvzxoODXfCBImqg2djHVteiB7OU1Ok3rkO/5I1dp/TxAdSwQuAnXXubEiO+33JRxPhfbADcZjsU2kre8CKZ2KR9mFT8hXpgZCiT0v3GOTJZNn8xV6J4/C29Q7d7lrsNViBovEi2tmjRbPHuIieLv3PIp+24qqx2ixCJym4VrZzeHrM20ppUOvOcw3l/23gNtCMkPO+20CYMYXQOM0Dv0fbI34c2B/+ZfwCdh9zrJwyI4rLv2xk8xOKiX7V4vYig9u7OAkbwmsldODI2xFsymDiNuWKymIYxCyDN3jrFZifc6U2JDTGEZegbWMaJNo/JnbV+GA8y57Fgm8RgZ5KBU3JmSDiYSxsQC51LTt8JUEWPgDPArkFggjeDvRpJ91e5uwybIp7lfxRIJ2Ff6GDpVEqPQ8rS317nddYDs6ffI8FzKuqjeKW2Eb/aCHP5l4i01ICBbnUAo3GbMBWWE52vZmcfq3wZa6gAKiy5iGOtqmPmFJl9YajF/63H6M6WOW934jx3GNOmPZfj9iYc+jWaMIBvzef2Bccfw0UxyEjZEDMzpdFpoWszjRTn350gKjrlfPdwUdLWp6XhzY50LPOITlPOomfOVfT8HgdwepGJWlPCkA3sygUNOiymV/UumNoo6zvRIjItGF/FblbKRZIxxzriTBCs4r2WAcU/4yKo+WoBmC4n277PIaqlAQixEt0vBZigcB4Cn587N9sl8rsx/S5QEqZcmN5Fgc38sPXzU2M0fb72HL/H/DQOr+yhfu1U4LY9u8I9crOpnB4z4DN76/EaumW9oPWMggw3fVkOlWeD04qvtFFFVL3zfe6TIJ2P4hUEbOcoXx5IoSEvJIDGEJOlL5lwr04ODzxrrMApzP3mj7lPiawRwsoPQw2XhSBp8q46p97A8TfLuX7+chlx+XHqGZ3Myy2lqAsrokiapwZUjdEEsDhdAvGXivQbPJshKTTEgwKU9p+ODB70ilR1QufwaEw3PkFFdGL9JhLiP9i/bpNVT1GfQDZ4wSfCCaBXqzWy0IZinxSzrbnfVrUgZOvS6dL+AIk0zYc49wJWHMj6h0C3KSi1m4JNIAOehqptUEK6fThoDlUqJehrvbVfjYPbDYRSWubDR/n7t2FYnYZc/oVKS0GNGxJ+dc+WkPdh17KrADG3ELi0ccIJRFbfFlb5nae07oxPx+OM3KOyWAK/dYIkuIhVPpKKBb6gKPrPztj4JBUGU1fKA3LF7Ur7v38gpyyG7KD91k1S8mVClJRoWizlTpr0AIj24akhCI6/eSUCkcNWlejyKtHo+xh76CbcqemN1XMMPvhPEZsg1TKq/2WcC74k5lC2sjLc4ho1EHdOCVsREjtUD0lFxSAPtFAL/T0s7wp5z1WPge47k1YH/mxRxC+wMA37++mPFMivn3LOfkO4bgTLndsfow1BygkZW6nm47Phh+7K7E+a036dM0tb7JfXnWTW8iEAIG4giezI6UOKdE2puU1/2Zo7+RNeG6DlAWhHq/Lrj5NueQbbWg3pqKk/9/GLBuzfuWKe2aLKlYrH6TYBbSpZJeWFVoZsDpdFTq+PjvSPS+YtYhgR63RvKA6GP5s1vOdj0VjTk2MPtYp3lQwnUACJ79jlBI2RFSjHw01nnTlnQoWa4W7LHxzGZ8dHmhJhJnBY0kOPIShViBjlCWbrlVuVNszBagDLl8ylV7z4JCX0rBtpqc70fkJ2GP9Xi+7/dXf1eGzXzIUKVF2q/p7aO5EBGNgJMw9hVPsDLng0WlL0eRKmXH/LUBJpUpnFJArATj5T8NO0zhXKRHMc6vnBH9IICOgi/y+9lVhDWchRNfI1iuFZld9tsuZUWjKDm/61Gu6wIAIjSMvEKUmLdQ0+j+oJx1FTffh9qCah1Ade9w0lXvLzA1CDXSM17V/grraQVw32KSyaTVBbriTAg7hPnW3nrqD97ZBXWRLR44PlynuC3n6Vo7jaODIUbN9QTbpCoNQvtNqzSJB4dgaS0QOMaZWIVEaw2vPpnFCR6rpIYIU0hJ3a67T8GaeRMC73pDP2jsvhzq+tidmBGTQ5rYogBrw/nYWPJMla9PBZyW2XiVmWgEZ/C9h57ifeavLWgig1JYlUCeM8sMjcVA0ia4YQT0FZj6aN79aYArOwxQpxc8cM/qPCb6XHByFMW0rgfW69Un0CHBlIaqEignRmZopdDaf00KJyoAtWfRtLhiaZQrelkKvNyhbXUzFIYFiTYkwDBJPzjP92KUCAtXe4Du6kvhzVR3tgxZ1HukOWBuOYvmX/BY+nqlY6q40wSTb2h2N4xiVTbfw8R8EcyyIG67KuWl0d6WAfaYuM6hU6qnzYSKRD6thLZzoR2psuyLbWTDiH5fa1E+rSDfYZNIrXEEgcipAtuFGvgPt4ZEo885JdYx7OgA7YC/aJqHKtpZRXiQF/6PYpX8tGpSMBIYMcMKAs5DN0tFZjFLgeyg7hu56GJjaoYHIClRAOW8d02i5fGuI/VfhT9JYybiD77+TOoCDnOqOxKZdAv1arLDCr6GPRjeJMCGk+x164wXu85AGemb70ZH71u+EDaeecJqPLJw6pR/f915jG8AncjGuorsyF5Koy5xNvJFLhXujVtiWAdJXXJMqth6Pnntt7MEAhFdlu1WAEfBR5uKzCT1w5DGfNBOiUASvYvQd8cxMacTXlrfNrsjlzSKEm2u9ZzPjQQeQgFGGLvWM1+LFqjy8icgV+yF9kh+FUYVKeguZKIlVTLbXv5UUJ9EcB81/4BJFoGUdhzwjMPiw2+7CpJtB9oMq3B9+uuEKF2UqJ+dc2CQMzt4WuPGELWlYzIMllEFHKAQ3QP2yL0Lyc7xoGg9x6qcalB79uGDh/GbfrQ6PKRfaAvovI7mVRp04NzB4gwwQS+P2+XhG5vBzaoq7kIt/rcyWHnA9li3iTd8aJvVGMkb9NjS5QyJcpXgU4VxekLoFuOPih1EgRNCKdDwA5rXFgcwdM7qY0rlVwOZxVp9h+fzBIZGdWN1wx/Q3G/yCOxIMj53Dmfjl8eA9NaB+gEtknCwJVclAnmAQenP7ylxwPZak7h0oo7Wm0yp35gdKkZpQqLcY3xu5B39AvXp3xuxOsmmfKe/570WMSI2ATA4PzdSS+xqh0kSDELTkLz50QedQyICaiC13RPbFenb4yYEUWkLfHayj0aPUkw5Gz5bAF5QjCcOgcXAIvsZMPXfdGM23t2DfL54eRxgLTYLLgYzWAwTk3rIMW74yQP87iZe97RIVu6OMQCsXm6SqVzH5qRy6b0qEKVP0FGvh9mrrDV9r/UpoNlZFBotWT9xOGGfMd8SUCXpqnAyfpO6QokGGDJ8z7u9yGNQ4Q+wWGdLYu4bEQtZynPPQ842ibRTt0UtTfnYLsaNE05RqWzNOLQXlgIgm6U/XI1cvsmqmlLK0yIzBgLvwfEHKzqx0pksjZmvl9fMIZiaQ6uwZuYNi3ftt+P05UosAuy8y5AM48HQ9ZqbkYxep4WdzJghTg48fEtH8aroOXh4WdRw1OABsOItm34Slc7az+APev5+mPOo11DKPcp1JvZOZf/uK5EO1hBeHTSuDxK2p88dWlnS5wXY2Pwdbp6Li8Rj9PssAAv970rmnlQnYY5gdLJlam7NWHqd/Jfz4VYvi6oNYQ4wikzlyI2RpfOXB+p+7sXCmmUv14TQlIhS4rymn1eWxF/1xURb6R7hRmz6x/5EpJdnXA5yz3wz9n7w26CYbJxxxK+0tAx3pB3bI8QaAYuXjZuCk2d06K1nh6ddvgWG0Vivsntn/FR4gYJy6tob/yGJ2gLkmbDrARfg2uBkX4gFhbg9dX5dPCEz14kWljEozYYrmS12o+AdOJ4N1QDIvGuqhZAK4icQLrt77BR/wyTqobL9FUEPwBaDqqhgj0SDaF9eUpftA7OTKXAE/NnvbVIi+B6xVmsC6SHbd0riMigIFSn9TojZOYkvEbTwO8bSom5ffEBqvyS8SZ76iyG9KL+Z9n2l2E4WXqBdXQOOfwnptemQapXIy4+BsxfX66cJ8fMc2OYnYTcN4B6yrQA2glyG1hkFxmWLfo0oB+++r7AGahvZbsvT8drt0fStRJqi4FJ0z9RCClaQQfdFlqIUcG4tO6MHfV01QxwRNJwdGqVRBrBz1pXUWB/qqOr99btmCfl7ja2QQJvCSwMq9d3sG0Gv3l+hnr91KradwSzTiHx28TSazbw/gW2YhyU/7+5l6EmzldFAXm9GNNx6GRX3CfP0q805ApAdWG+xfIJuKxeae97tWbla7OchjvW6Xpu1AmgKP5/0oZN2L5WJOCSZ3sNUuQLoPuoHpx9H2S06KoF1mzPop2WsmIosdKXIUVjwsq3HXXiBg4fkK7G75imKmjx3Ro5WkuDq9RW9Oa64LC9qzi5wAWGsX+VBgTFpsftzLIDXvXplaR7yx5bd4iHHcu0TOIPycKKaRrlw/xpNIez0p9MmkvsR6sjp+l0FlSbl/aDwpi55K3KpoO3NNcIHEgZljxet5TJm/NyOsx/GEesHY3q6rw5dWi4hB9+mNXxod7EdtSFaxpPeqdoIAuKzRfIQvQOLAcc1F9F6AbzFnsrOpUg5IL+hBhEoTh6SmXOXAEuleSSnyfAb+5zmmVThsTiqUrDM0BG3gCHI9ARmVo231F4EPOYwtrfjCkH4CCk1gcmaD8VG08Uo1G/x8L5PUIcQNMx0Df7x42kPDiTPnoWYS1LVSnPsWs+5WHEiaRJjPvOk9ziJSZGokQ55ByLiCj5bB7SdnM9OcNZ32g0hV8CARBn4HFxi6FQXXDWBxYhId0N4Wl78erGhXX2AqntYjRbPkHAVrBp01Kh5KzJAX8PxL5DY95XfAYjAh7ULQ9cUhjxUM3CdN4XPLTNUcJBtdOp7s1A7sRsierohfrR2QZlKh11d08QPTRXxXON09JEnO6vD6bXUnmNQjf/ZeTpsvJZn+aGr+IhenRAjffTJYihwNeGsDnRlpFomzt4ywOqEFCUlgGLVNcXuN9ljSuhV6hrYfS3ZUZqNcymd4lHl+E9sygc3j8yz9OwplUBdLG/4muM7MZA/+AA23hIgyxqsB28eNJ72NOjpiBSM9lPVgaSzHhDo3fkONztDaiMTcC0tnPV8wPAYy65zt3UnMNv9uWH8ryeHG99aBUcsiPLajTkuEHVyLLxK+3NCOFuezC34SMgOGlVNVtJDInuRPulcVMFLoac4hkBmIj8UWIu7qm/vEOWkDeg/Lt0xDZY9QtoEF4PO5KUJePMKCSMyprdrp4JyESr5lYWftUyPw6DUaiZKWdkm8a7AROcMCHBVfROSDB1eAVqUpzPY5Bv6qJNZYYUQAeQahP8MmOgj5o6M19ztuIwj9y3MhRVJ14tjWSxTCQgX++KAAVfoOdRiJ4rCU35jYwR/HvUZhMdCcpV5Wa9+YsA0kJLsw0gy7kUI+z6AAsq0DSbn/AqVzOFG9HY8Q4tSphOxtG3EYVqu8Ys72SKiirBGUe1HdevA8sfm9t0vvstpcP0PNasnB8Ep0oUOkPxMm5YeDaRxlOW4Y/tu+CVpticWyH7r574cxvjFocmhhV73QIKjN1P2RNhyo+fpKFm9Ty0NKAWXvXAIUzJFYnOJSeE8MyTZU3vjL0SqhS56ERsomiyZKSrgx97sW9ZUMyoC6DLPFjKfrfohoAKpgk3J8mnq4rfbHwD13n49Ik5J5ddgvamyvdEWd3Tr/ib+2O5mBQlOL7fJEc+w2IL83hCm2p79rF31WkPszhm8c4feq8feCvfvO5GH8KKFAxac1XG38v6fdfxycb9Z9J8OYInkb+bToRPkSTZVA7tLMNttBPFgtCiy8Z0BkyrxVhe3wXJJ+f8K3jVFFSHQOpoXzEicrDTnDz+MjE21iqX9U6x3IL5BK5nJlqJQ7XIs+cZrYSchhGRXAfOl/Bf6as94bE13l500fyU4W3bXG+FgcE1+3P8635qx9b8wOKLcdd/s27Wa2INdqdybMcIAte5rIsNiTL7jEw2xmI2CNJv3zBKfgcMYLIvNXT08E+R6fC7faT+YtgusKRAFkbXu+eZtc6N/EQVHwpo3DyYxc71LDaFd3MiSdbvTQ9+Zod1lUTq4LanN/bmExQ21LaTJ+0GLzxPeW4R/h/lBnD8OtJobXoP5gQEDcmBmUA0tvFMBGGSAVvIxwTj7FlOsKIFUbWKaGUvTqj8PHPP2EHGVUwYFc20Hcc4t2H+uEyg3k6SW6NxuBb/K4mV5/WqQBMFXvy9s7C6BLoh/na55OnnXdH2
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>自我反思</category>
      </categories>
  </entry>
  <entry>
    <title>初探react</title>
    <url>/2019/03/25/2018/%E5%88%9D%E6%8E%A2react/</url>
    <content><![CDATA[<blockquote>
<p>react.js 作为一个热门的 JavaScript 库，其用于组件化开发，提升我们的开发效率。现在就让我们走进 react.js</p>
</blockquote>
<h3 id="一、我们需要知道什么"><a href="#一、我们需要知道什么" class="headerlink" title="一、我们需要知道什么"></a>一、我们需要知道什么</h3><p>元素和组件构成 <strong>React</strong> 应用。</p>
<ul>
<li><strong>JSX</strong>:</li>
<li><strong>元素</strong>：元素是构成 React 应用的最小单位，用来描述你在屏幕上看到的内容。元素本身是一个普通对象，构成组件的一部分。</li>
<li><strong>组件</strong>：将 UI 切分为一些独立、可复用的小部件。props只读，保证数据的单向传递</li>
</ul>
<p>官方脚手架 <a href="https://github.com/facebook/create-react-app" target="_blank" rel="noopener">create-react-app</a></p>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul>
<li><a href="https://reactjs.org/" target="_blank" rel="noopener">react官网</a></li>
<li><a href="https://react.docschina.org/" target="_blank" rel="noopener">react中文网</a></li>
</ul>
]]></content>
      <categories>
        <category>前端开发框架+库</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title>伪数组</title>
    <url>/2019/04/02/2018/%E4%BC%AA%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<blockquote>
<p>输出以下代码的执行结果，并加以解释。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">'2'</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="string">'3'</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="string">'length'</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">'splice'</span>: <span class="built_in">Array</span>.prototype.splice,</span><br><span class="line">    <span class="string">'push'</span>: <span class="built_in">Array</span>.prototype.push,</span><br><span class="line">&#125;;</span><br><span class="line">obj.push(<span class="number">1</span>);</span><br><span class="line">obj.push(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure>
<h3 id="一、数组-VS-类数组（Array-like）对象"><a href="#一、数组-VS-类数组（Array-like）对象" class="headerlink" title="一、数组 VS 类数组（Array-like）对象"></a>一、数组 VS 类数组（Array-like）对象</h3><p>在 JavaScript 中，数组就是由 <strong><em>Array</em></strong> 构造出来的对象。区分方式：判断其原型链是否指向 <strong>Array.prototype</strong>（push、pop、shift和join）。</p>
<h3 id="二、Array-prototype-push"><a href="#二、Array-prototype-push" class="headerlink" title="二、Array.prototype.push"></a>二、<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/push" target="_blank" rel="noopener">Array.prototype.push</a></h3><blockquote>
<p>MDN解释为：<br><code>push()</code> 方法将一个或多个元素添加到数组的末尾，并返回该数组的新长度。同时 <code>push</code> 是特意设计为通用的。</p>
</blockquote>
<p><code>push()</code> 根据 <code>length</code> 属性决定从哪里开始插入给定的值。如果 <code>length</code> 不能被转成一个数值，则插入的元素索引为 0，包括 <code>length</code> 不存在时。当 <code>length</code> 不存在时，将会创建它。</p>
<h3 id="三、问题回归"><a href="#三、问题回归" class="headerlink" title="三、问题回归"></a>三、问题回归</h3><p>当一个对象调用 <code>push()</code> 时，对象的 <code>length</code> 属性和插入元素会发生变化。</p>
<p>因此 obj 返回结果为：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object &#123;</span><br><span class="line">    &apos;2&apos;: 1,</span><br><span class="line">    &apos;3&apos;: 2,</span><br><span class="line">    &apos;length&apos;: 4,</span><br><span class="line">    &apos;splice&apos;: Array.prototype.splice,</span><br><span class="line">    &apos;push&apos;: Array.prototype.push,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是当一个对象存在 <code>length</code> 和 <code>splice</code> 时，输出会被转换为一个伪数组。因此最终结果会变为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object(4) [empty × 2, 1, 2, splice: ƒ, push: ƒ]</span><br></pre></td></tr></table></figure>
<p><strong>变形题：</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">'splice'</span>: <span class="built_in">Array</span>.prototype.splice,</span><br><span class="line">    <span class="string">'push'</span>: <span class="built_in">Array</span>.prototype.push,</span><br><span class="line">&#125;;</span><br><span class="line">obj.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Object [1, splice: ƒ, push: ƒ] obj.length -&gt; 1</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="string">'length'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'splice'</span>: <span class="built_in">Array</span>.prototype.splice,</span><br><span class="line">    <span class="string">'push'</span>: <span class="built_in">Array</span>.prototype.push,</span><br><span class="line">&#125;;</span><br><span class="line">obj.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Object [1, splice: ƒ, push: ƒ] obj.length -&gt; 1</span></span><br></pre></td></tr></table></figure>
<h3 id="四、伪数组打印"><a href="#四、伪数组打印" class="headerlink" title="四、伪数组打印"></a>四、伪数组打印</h3><p>当一个对象的 <code>length</code> 属性为数字，同时<code>splice</code>属性为函数时， 对象的函数输出结果就会变成 伪数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = &#123;</span><br><span class="line">    length: <span class="number">1</span>,</span><br><span class="line">    splice: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">&#125;; <span class="comment">// Object [empty, splice: ƒ]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    length: <span class="string">'1'</span>,</span><br><span class="line">    splice: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">&#125;; <span class="comment">// &#123;length: "1", splice: ƒ&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj3 = &#123;</span><br><span class="line">    length: <span class="number">1</span>,</span><br><span class="line">    splice: &#123;&#125;,</span><br><span class="line">&#125;; <span class="comment">// &#123;length: 1, splice: &#123;…&#125;&#125;</span></span><br></pre></td></tr></table></figure>
<p>在 DevTools，就是通过这些来进行判断对象是否为类数组。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">function</span> <span class="title">isArrayLike</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj || <span class="keyword">typeof</span> obj !== <span class="string">'object'</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> obj.splice === <span class="string">'function'</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> len = obj.length;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> len === <span class="string">'number'</span> &amp;&amp; (len &gt;&gt;&gt; <span class="number">0</span> === len &amp;&amp; (len &gt; <span class="number">0</span> || <span class="number">1</span> / len &gt; <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://github.com/ChromeDevTools/devtools-frontend/blob/master/front_end/event_listeners/EventListenersUtils.js#L330" target="_blank" rel="noopener">https://github.com/ChromeDevTools/devtools-frontend/blob/master/front_end/event_listeners/EventListenersUtils.js#L330</a></p>
<h3 id="五、相关讨论"><a href="#五、相关讨论" class="headerlink" title="五、相关讨论"></a>五、相关讨论</h3><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/76" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/76</a></p>
<h3 id="六、对象转数组"><a href="#六、对象转数组" class="headerlink" title="六、对象转数组"></a>六、对象转数组</h3><ul>
<li><code>Array.from()</code> 方法从一个类似数组或可迭代对象中创建一个新的数组实例。</li>
<li><code>Array.prottype.slice.call(arguments)</code> 生成新数组</li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>利用bat第二弹</title>
    <url>/2019/03/26/2018/%E5%88%A9%E7%94%A8bat%E7%AC%AC%E4%BA%8C%E5%BC%B9/</url>
    <content><![CDATA[<blockquote>
<p>在实际问题处理中，我们不可避免地会遇到一些文件或其他操作的批量处理。在 <strong>Linux</strong> 系统中，我们可以利用 <strong>shell</strong> 脚本去完成这些重复的事情，减少一些不必要的操作。<strong>window</strong> 的 <strong>bat</strong>同理。</p>
</blockquote>
<p>有兴趣的同学可以看一下前一篇 </p>
<h3 id="一、系统脚本足够强大吗？"><a href="#一、系统脚本足够强大吗？" class="headerlink" title="一、系统脚本足够强大吗？"></a>一、系统脚本足够强大吗？</h3><p>在处理实际问题时，系统脚本命令能够完全满足我们的需求吗？以 <strong>bat</strong> 为例，在处理一些简单的逻辑时，<strong>dos</strong>能满足我们的需求，但是一旦需要进行一些复杂的逻辑判断，甚至是计算时，<strong>dos</strong>就无能为力了。</p>
<p>例如：一个文件夹内有 1.txt - 100.txt 100个文件，我希望对这些文件重命名为 001.txt - 100.txt。这个时候 <strong>dos</strong> 能处理吗？</p>
<h3 id="二、node-dos"><a href="#二、node-dos" class="headerlink" title="二、node + dos"></a>二、node + dos</h3><p>在 <strong>node.js</strong> 中，我们可以进行复杂的逻辑运算，同时我们也可以利用 <strong>node.js</strong> 执行 <strong>dos</strong> 命令。即通过两者之间的结合，合理利用两者之间的优势，我们可以完成更高难度的操作。</p>
<h3 id="三、看一个场景"><a href="#三、看一个场景" class="headerlink" title="三、看一个场景"></a>三、看一个场景</h3><p>在日常开发中，test 目录下，存在若干个子项目，当前开发项目长期依赖 test 下的子项目，因此希望能有一个脚本支持更新编译这些子项目。</p>
<p><strong>难点：</strong>这些子项目开发过程中的编译均为 <code>npm run dev</code>，当该命令会进行一个 <strong>watch</strong> 操作。</p>
<h3 id="四、设计思路"><a href="#四、设计思路" class="headerlink" title="四、设计思路"></a>四、设计思路</h3><ul>
<li>更新所有子模块代码到最新的 <strong>develop</strong> 分支</li>
<li>依次编译各自子模块，等子模块相关操作完成后，结束该操作，执行下一个模块编译</li>
</ul>
<h3 id="五、相关代码"><a href="#五、相关代码" class="headerlink" title="五、相关代码"></a>五、相关代码</h3><p>run.bat<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">for</span> %%f <span class="keyword">in</span> (a b c d) <span class="keyword">do</span> @call update_module.bat %%f</span><br><span class="line">node ./update/update.js</span><br></pre></td></tr></table></figure></p>
<p>update_module.bat<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">cd</span> %1</span><br><span class="line">git reset --hard</span><br><span class="line">@git checkout develop</span><br><span class="line">@git pull origin develop</span><br><span class="line">@<span class="built_in">cd</span> ../</span><br></pre></td></tr></table></figure></p>
<p>update.js<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; exec &#125; = <span class="built_in">require</span>(<span class="string">'child_process'</span>);</span><br><span class="line"><span class="comment">// https://github.com/pkrumins/node-tree-kill</span></span><br><span class="line"><span class="keyword">const</span> kill = <span class="built_in">require</span>(<span class="string">'./tree-kill'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rootPath = __dirname;</span><br><span class="line"></span><br><span class="line">getAllModules(rootPath)</span><br><span class="line">  .then(<span class="function"><span class="params">list</span> =&gt;</span> &#123;</span><br><span class="line">    buildModules(list, <span class="number">90000</span>)</span><br><span class="line">      .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译模块列表</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">buildModules</span>(<span class="params">list, delayTime</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    <span class="keyword">await</span> buildModule(list[i], delayTime);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译指定模块</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildModule</span>(<span class="params">moduleName, delayTime</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> commond = <span class="string">`cd <span class="subst">$&#123;moduleName&#125;</span> &amp;&amp; npm run dev`</span>;</span><br><span class="line">        <span class="keyword">const</span> child = exec(commond);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'\x1b[36m%s: \x1b[32m%s \x1b[0m %s'</span>, <span class="string">'[start]'</span>, moduleName, commond);</span><br><span class="line">        child.stdout.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`&gt; <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        child.stderr.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'\x1b[31m%s\x1b[0m '</span>, data);</span><br><span class="line">            reject(data);</span><br><span class="line">        &#125;);</span><br><span class="line">        child.on(<span class="string">'exit'</span>, (code, signal) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`child process exit: <span class="subst">$&#123;code&#125;</span> <span class="subst">$&#123;signal&#125;</span>`</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'\x1b[33m[end]\x1b[0m: '</span>, <span class="string">`时间到结束子任务<span class="subst">$&#123;moduleName&#125;</span>`</span>);</span><br><span class="line">            <span class="comment">// child.kill(child.pid); // 子进程无限循环时，无法杀死</span></span><br><span class="line">            kill(child.pid);</span><br><span class="line">        &#125;, delayTime || <span class="number">120000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新模块信息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateModule</span>(<span class="params">moduleName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> commond = <span class="string">`cat update_module.bat <span class="subst">$&#123;moduleName&#125;</span>`</span>;</span><br><span class="line">        <span class="keyword">const</span> child = exec(commond);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'\x1b[36m%s: \x1b[32m%s \x1b[0m %s'</span>, <span class="string">'[start]'</span>, moduleName, commond);</span><br><span class="line">        child.stdout.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`&gt; <span class="subst">$&#123;data&#125;</span>`</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        child.stderr.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'\x1b[31m%s\x1b[0m '</span>, data);</span><br><span class="line">            reject(data);</span><br><span class="line">        &#125;);</span><br><span class="line">        child.on(<span class="string">'exit'</span>, (code, signal) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`child process exit: <span class="subst">$&#123;code&#125;</span> <span class="subst">$&#123;signal&#125;</span>`</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有需要update的模块</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;Array&#125;</span> </span>模块列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAllModules</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> dealModules = [];</span><br><span class="line">    readdir(root)</span><br><span class="line">      .then(<span class="function"><span class="params">files</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> tasks = [];</span><br><span class="line">        files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">let</span> task = isDirectory(path.resolve(root, file));</span><br><span class="line">          tasks.push(task);</span><br><span class="line">          task.then(<span class="function"><span class="params">flag</span> =&gt;</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                dealModules.push(file);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="built_in">Promise</span>.all(tasks)</span><br><span class="line">          .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            resolve(dealModules);</span><br><span class="line">          &#125;)</span><br><span class="line">          .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">            reject(e);</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;)</span><br><span class="line">      .catch(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">        reject(e);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读取一个目录下的所有文件或子目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readdir</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readdir(root, (e, files) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      resolve(files);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 判断某路径是否为文件夹/目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isDirectory</span>(<span class="params">path</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.stat(path, (e, stat) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (stat.isDirectory()) &#123;</span><br><span class="line">        resolve(<span class="literal">true</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(<span class="literal">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>shell编程</category>
      </categories>
      <tags>
        <tag>脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>双向绑定和vuex</title>
    <url>/2019/04/03/2018/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%92%8Cvuex/</url>
    <content><![CDATA[<h3 id="相关参考："><a href="#相关参考：" class="headerlink" title="相关参考："></a>相关参考：</h3><h3 id="自我总结："><a href="#自我总结：" class="headerlink" title="自我总结："></a>自我总结：</h3>]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端模块化</title>
    <url>/2019/04/09/2018/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>从最开始的前后端混写，前后端分离，到现在的大型单页面应用。前端工程化经历了哪些？</p>
</blockquote>
<a id="more"></a>
<h3 id="一、JS模块化的历程"><a href="#一、JS模块化的历程" class="headerlink" title="一、JS模块化的历程"></a>一、JS模块化的历程</h3><p>在ES5及之前，JS并没有模块这一概念。在实际多人开发过程中，为了抽离公共代码，隔离作用域、避免各个开发人员之间的变量冲突，模块化就显得十分必要。</p>
<p>以下JS模块的各个阶段：</p>
<ul>
<li><p><strong>IIFE</strong> 使用<strong>自执行函数</strong>来编写模块化，特点：在一个单独的函数作用域中执行代码，避免变量冲突。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        data:[]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>AMD</strong> 使用<strong>requireJS</strong>来编写模块化，特点：依赖必须提前声明好。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="string">'./index.js'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">code</span>) </span>&#123;</span><br><span class="line">	<span class="comment">// code 就是index.js 返回的内容</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CMD</strong> 使用<strong>seaJS</strong>来编写模块化，特点：支持动态引入依赖文件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;  </span><br><span class="line">  <span class="keyword">var</span> indexCode = <span class="built_in">require</span>(<span class="string">'./index.js'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>CommonJS</strong> nodejs 中自带的模块化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>UMD</strong> 兼容 AMD，CommonJS 模块化语法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">        <span class="comment">// AMD</span></span><br><span class="line">        define([<span class="string">'jquery'</span>], factory);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;</span><br><span class="line">        <span class="comment">// Node, CommonJS之类的</span></span><br><span class="line">        <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">'jquery'</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 浏览器全局变量(root 即 window)</span></span><br><span class="line">        root.returnExports = factory(root.jQuery);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 暴露公共方法</span></span><br><span class="line">    <span class="keyword">return</span> myFunc;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>webpack(require.ensure)</strong> webpack 2.x 版本中的代码分割。</p>
</li>
<li><strong>ES Modules</strong> ES6 引入的模块化，支持import 来引入另一个 js 。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="二、CommonJs"><a href="#二、CommonJs" class="headerlink" title="二、CommonJs"></a>二、CommonJs</h3><p>JavaScript最初被认为只能构建基于浏览器的应用程序，适用面狭窄。而 CommonJs API 却定义了很多普通应用程序（非浏览器）使用的 API，填补这些空白，旨在提供一个类似Python，Ruby和Java标准库。让开发者利用 CommonJS 编写的程序可以在不同的JS解析器和宿主环境中运行。</p>
<p>2009年，美国程序员Ryan Dahl创造了node.js项目，将javascript语言用于服务器端编程。<code>Node</code>采用CommonJS模块规范，构建了node的模块系统。而在浏览器端 <code>browserfy</code> 和 <code>webpack</code>也实现了CommonJS的模块规范。不同点在于服务端的模块加载是运行时同步加载，而浏览器端时通过提前编译打包处理。</p>
<p><code>CommonJS</code>相关特性说明：</p>
<ul>
<li>每个文件都可以是一个模块，有自己的作用域。CommonJS 规范规定，每个模块内部，<code>module</code>变量代表当前模块，<code>module.exports</code>是其对外接口。加载某个模块，其实是加载该模块的<code>module.exports</code>属性。</li>
<li>模块可以多次加载，但是只会在第一次加载时运行一次，然后缓存运行结果，以后的加载，就直接读取缓存结果。要想让模块再次运行，必须清除缓存。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
</ul>
<h3 id="二、AMD-（Asynchronous-Module-Definition）"><a href="#二、AMD-（Asynchronous-Module-Definition）" class="headerlink" title="二、AMD （Asynchronous Module Definition）"></a>二、AMD （Asynchronous Module Definition）</h3><p><code>CommonJS</code>规范加载模块是同步的，即加载完成后，才进行后续的操作。而浏览器环境由于资源并不在本地，加载相对 node 环境较慢，因此必须采用非同步的方式。AMD规范使用 <code>define</code> 定义模块，允许非同步加载模块，指定回调函数。</p>
<p><code>AMD</code>相关特性：</p>
<ul>
<li>提前声明好依赖</li>
<li>模块加载异步，指定回调函数。</li>
</ul>
<p>引入</p>
<blockquote>
<p>其中 CMD 就是兼容 CommonJS 和 AMD 的形式，让开发者可以在浏览器环境中使用 CommonJS 的形式。<br>CMD 对依赖的模块延迟执行，依赖可就近书写，等到需要时再引入这个依赖。</p>
</blockquote>
<h3 id="相关讨论："><a href="#相关讨论：" class="headerlink" title="相关讨论："></a>相关讨论：</h3><ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/28" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/28</a></li>
</ul>
<h3 id="相关阅读"><a href="#相关阅读" class="headerlink" title="相关阅读"></a>相关阅读</h3><ul>
<li><a href="https://blog.csdn.net/xixi880928/article/details/51768469" target="_blank" rel="noopener">js模块化编程之彻底弄懂CommonJS和AMD/CMD！</a></li>
<li><a href="https://www.processon.com/view/link/5c8409bbe4b02b2ce492286a#outline" target="_blank" rel="noopener">模块化思维导图</a></li>
<li><a href="https://blog.csdn.net/dadadeganhuo/article/details/86777249" target="_blank" rel="noopener">前端中的模块化</a></li>
<li><a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">CommonJS规范</a></li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title>宏任务和微任务</title>
    <url>/2019/03/21/2018/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<p><a href="/data/聊聊JS异步.pptx">PPT</a></p>
<h3 id="一、调用栈"><a href="#一、调用栈" class="headerlink" title="一、调用栈"></a>一、调用栈</h3><h3 id="二、事件循环"><a href="#二、事件循环" class="headerlink" title="二、事件循环"></a>二、事件循环</h3><h3 id="三、作业队列和-Promise"><a href="#三、作业队列和-Promise" class="headerlink" title="三、作业队列和 Promise"></a>三、作业队列和 Promise</h3><h3 id="四、相关文章推荐"><a href="#四、相关文章推荐" class="headerlink" title="四、相关文章推荐"></a>四、相关文章推荐</h3><ul>
<li><a href="https://juejin.im/post/5a05b4576fb9a04519690d42" target="_blank" rel="noopener">https://juejin.im/post/5a05b4576fb9a04519690d42</a></li>
<li><a href="https://juejin.im/post/5a102e656fb9a044fd1158c6" target="_blank" rel="noopener">https://juejin.im/post/5a102e656fb9a044fd1158c6</a></li>
<li><a href="https://juejin.im/post/5a221d35f265da43356291cc" target="_blank" rel="noopener">https://juejin.im/post/5a221d35f265da43356291cc</a></li>
<li><a href="https://juejin.im/entry/56cc0bcf8ac2470053b7c5ab?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github" target="_blank" rel="noopener">https://juejin.im/entry/56cc0bcf8ac2470053b7c5ab?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github</a></li>
<li><a href="https://juejin.im/post/5c0d148af265da612637fa76" target="_blank" rel="noopener">https://juejin.im/post/5c0d148af265da612637fa76</a></li>
</ul>
]]></content>
      <categories>
        <category>基础原理</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>setTimeout、Promise、Async/Await 的区别</title>
    <url>/2019/02/28/2018/%E5%90%84%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h3 id="相关参考："><a href="#相关参考：" class="headerlink" title="相关参考："></a>相关参考：</h3><ul>
<li><a href="https://juejin.im/post/5b191d585188257d831e338e" target="_blank" rel="noopener">async await、Promise、setTimeout执行顺序</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">async</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener">await</a></li>
<li><a href="https://github.com/xitu/gold-miner/blob/master/TODO/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with.md" target="_blank" rel="noopener">JavaScript 是如何工作的: 事件循环和异步编程的崛起 + 5个如何更好的使用 async/await 编码的技巧</a></li>
</ul>
<h3 id="相关问题参考"><a href="#相关问题参考" class="headerlink" title="相关问题参考"></a>相关问题参考</h3><h4 id="执行先后顺序-setTimeout、Promise、Async-Await-对比"><a href="#执行先后顺序-setTimeout、Promise、Async-Await-对比" class="headerlink" title="执行先后顺序 setTimeout、Promise、Async/Await 对比"></a>执行先后顺序 setTimeout、Promise、Async/Await 对比</h4><p>下面函数的执行顺序为？<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>);</span><br><span class="line">    <span class="keyword">await</span> async2();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'async2'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'start'</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise1'</span>);</span><br><span class="line">    resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise2'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'end'</span>);</span><br></pre></td></tr></table></figure></p>
<p>node v10.13.0运行结果<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">end</span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure></p>
<h3 id="调用顺序问题解析："><a href="#调用顺序问题解析：" class="headerlink" title="调用顺序问题解析："></a>调用顺序问题解析：</h3><p><strong>async</strong></p>
<blockquote>
<p>async function name([param[, param[, … param]]]) { statements }</p>
</blockquote>
<p><code>async</code> 会定义一个返回 AsyncFunction 对象的异步函数。即以 <code>async</code> 声明的函数，会隐式地返回一个 <code>Promise</code> 对象。当这个 <code>async</code> 函数返回一个值时，<code>Promise</code> 的 <code>resolve</code> 方法会负责传递这个值；当 <code>async</code> 函数抛出异常时，<code>Promise</code> 的 <code>reject</code> 方法也会传递这个异常值。</p>
<p><strong>await</strong></p>
<blockquote>
<p>[return_value] = await expression;</p>
</blockquote>
<p><code>await</code> 操作符用于等待一个 <code>Promise</code> 对象。它返回 <code>Promise</code> 对象的处理结果。如果等待的不是 <code>Promise</code> 对象，则返回该值本身。</p>
<blockquote>
<p>注意：<br><code>await</code> 只能在异步函数 <code>async function</code> 中使用。<br>如果你希望并行等待两个或者是更多的 <code>Promise</code> 对象，你必须使用<code>Promise.then</code>，而不是<code>await</code>。</p>
</blockquote>
<p><strong>队列任务优先级：</strong><code>promise.Trick()</code> &gt; <code>promise的回调</code> &gt; <code>setTimeout</code> &gt; <code>setImmediate</code></p>
<p>因此上述代码可以理解成：（部分用语可能不准确）</p>
<p>在同步执行阶段：<br><code>async1</code>执行到<code>await async2()</code>时，<code>sync2()</code>返回一个<code>Promise</code>, 其<code>resolve</code>放入到回调队列中，跳出<code>async1</code>，执行<code>new promise</code>的<code>resolve</code>时，该<code>resolve</code>也会被放入回调队列中。然后执行到<code>console.log(&#39;end&#39;);</code>，此时同步执行结束。</p>
<p><strong>重点（执行回调队列）</strong>：<br>此时<code>async2()</code>返回的 Promise的<code>resolve</code>会被执行，即执行<code>await async2()</code>，此时<code>await</code>的<code>Promise</code>的<code>resolve</code>会被放入到新回调队列。此时原回调队列中<code>new promise</code>的<code>resolve</code>会被执行，<code>promise2</code>字符被打印，原回调队列执行完毕。</p>
<p>执行新回调队列：<br><code>await</code>的<code>Promise</code>的<code>resolve</code>被执行，<code>console.log(&#39;async1 end&#39;)</code>执行。<code>async1()</code>返回的<code>Promise</code>的<code>resolve</code>会被放入到新回调队列。</p>
<p>所有回调队列执行完毕，<code>setTimeout</code>执行。</p>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>库存管理相关页面优化思考</title>
    <url>/2019/03/13/2018/%E5%BA%93%E5%AD%98%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3%E9%A1%B5%E9%9D%A2%E4%BC%98%E5%8C%96%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="请先输入文章密码" />
    <label for="pass">请先输入文章密码</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
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
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>自我反思</category>
      </categories>
  </entry>
  <entry>
    <title>异步编程</title>
    <url>/2019/03/05/2018/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>JavaScript 是单线程的，而为了避免耗时较为严重的任务影响整体任务，异步编程就显得尤为重要了。</p>
<h3 id="相关参考文章："><a href="#相关参考文章：" class="headerlink" title="相关参考文章："></a>相关参考文章：</h3><ul>
<li><a href="https://juejin.im/post/5a05b4576fb9a04519690d42" target="_blank" rel="noopener">对引擎、运行时和调用栈的概述</a></li>
<li><a href="https://github.com/xitu/gold-miner/blob/master/TODO/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code.md" target="_blank" rel="noopener">深入 V8 引擎以及 5 个写出更优代码的技巧</a></li>
<li><a href="https://github.com/xitu/gold-miner/blob/master/TODO/how-javascript-works-memory-management-how-to-handle-4-common-memory-leaks.md" target="_blank" rel="noopener">内存管理以及四种常见的内存泄漏的解决方法</a></li>
<li><a href="https://github.com/xitu/gold-miner/blob/master/TODO/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with.md" target="_blank" rel="noopener">JavaScript 是如何工作的: 事件循环和异步编程的崛起 + 5个如何更好的使用 async/await 编码的技巧</a></li>
<li><p><a href="https://juejin.im/entry/56cc0bcf8ac2470053b7c5ab?utm_source=gold-miner&amp;utm_medium=readme&amp;utm_campaign=github" target="_blank" rel="noopener">Promise 是如何工作的?</a></p>
</li>
<li><p><a href="https://juejin.im/post/5c0d148af265da612637fa76" target="_blank" rel="noopener">理解异步JavaScript</a></p>
</li>
<li><a href="http://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">JavaScript 运行机制详解：再谈Event Loop</a></li>
</ul>
<h3 id="一、JavaScript是如何工作的"><a href="#一、JavaScript是如何工作的" class="headerlink" title="一、JavaScript是如何工作的"></a>一、JavaScript是如何工作的</h3><ul>
<li>V8 引擎 （chrome &amp; ndoe）（将 JavaScript 代码直接编译为机器码）</li>
<li>运行时 （宿主环境）（web APIs）</li>
<li>单线程 （多线程 - 死锁）</li>
<li>事件驱动</li>
<li>回调队列</li>
</ul>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><ul>
<li>作业队列（Job Queue）</li>
</ul>
<h3 id="运行时-宿主环境"><a href="#运行时-宿主环境" class="headerlink" title="运行时 宿主环境"></a>运行时 宿主环境</h3>]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>底层原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据埋点</title>
    <url>/2019/04/08/2018/%E6%95%B0%E6%8D%AE%E5%9F%8B%E7%82%B9/</url>
    <content><![CDATA[<blockquote>
<p>在前端进行数据埋点时，常使用 <strong>1x1</strong> 像素的透明 <strong>gif</strong> 图片进行数据传输，这么做相对于一般的请求有哪些优势呢？</p>
</blockquote>
<h3 id="一、前端监控"><a href="#一、前端监控" class="headerlink" title="一、前端监控"></a>一、前端监控</h3><p>前端监控，其实是在满足一定条件后，由Web页面将<strong>用户信息</strong>（UA/鼠标点击位置/页面报错/停留时长/etc）<strong>上报给服务器</strong>的过程。一般是将上报数据用 url_encode（百度统计/CNZZ）或JSON编码（神策/诸葛io）为字符串，通过url参数传递给服务器，然后在服务器端统一处理。</p>
<p><strong>这套流程的关键在于：</strong></p>
<ol>
<li>收集到用户信息；</li>
<li>将收集到的数据上报服务器。也就是说，只要能上报数据，无论是请求GIF文件还是请求js文件或者是调用页面接口，服务器端其实并不关心具体的上报方式。</li>
</ol>
<blockquote>
<p>前端埋点主要是讲用户信息上报给服务器，不需要服务器做出消息体响应。</p>
</blockquote>
<p>事实上向服务器端上报数据有多种方式，可以通过请求接口，请求普通文件，或者请求图片资源的方式进行。</p>
<ul>
<li>接口（<strong>GET</strong>、<strong>POST</strong>、<strong>HEAD</strong>…）</li>
<li>普通文件 （<strong>JS</strong>、<strong>CSS</strong>、<strong>TTF</strong>…）</li>
<li>图片 （<strong>JEPG</strong>、<strong>BMP</strong>、<strong>PNG</strong>、<strong>GIF</strong>…）</li>
</ul>
<h3 id="二、1x1像素gif图片埋点优势"><a href="#二、1x1像素gif图片埋点优势" class="headerlink" title="二、1x1像素gif图片埋点优势"></a>二、<code>1x1</code>像素<code>gif</code>图片埋点优势</h3><ul>
<li>不存在跨域问题。埋点域名不一定是当前域名，为了避免出现跨域问题，排除ajax接口方式。</li>
<li>不需要操作DOM，性能更好。请求图片只需要在 js 中 <code>new</code> 一个 <code>Image</code> 对象就能发起请求，同时还不会造成阻塞。这也是请求普通文件所不具备的。</li>
<li>节约体积，节省流量。<strong>1x1</strong>像素是最小的合法图片，同时<strong>gif</strong>格式的图片，其最小文件相对于其他格式的最小文件需要的字节数更少。</li>
</ul>
<blockquote>
<p>图片请求不占用 Ajax 请求限额</p>
</blockquote>
<h3 id="三、相关讨论"><a href="#三、相关讨论" class="headerlink" title="三、相关讨论"></a>三、相关讨论</h3><ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/87" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/87</a></li>
</ul>
<h3 id="四、相关阅读"><a href="#四、相关阅读" class="headerlink" title="四、相关阅读"></a>四、相关阅读</h3><ul>
<li><a href="https://mp.weixin.qq.com/s/v6R2w26qZkEilXY0mPUBCw?utm_source=tuicool&amp;utm_medium=referral" target="_blank" rel="noopener">为什么前端监控要用GIF打点</a></li>
<li><a href="https://www.sitepoint.com/using-beacon-image-github-website-email-analytics/" target="_blank" rel="noopener">Using a Beacon Image for GitHub, Website and Email Analytics</a></li>
<li><a href="https://segmentfault.com/q/1010000000146284/a-1020000000146319" target="_blank" rel="noopener">用隐藏的img，通过src的调用后台逻辑有什么好处？</a></li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>数组扁平去重排序</title>
    <url>/2019/03/05/2018/%E6%95%B0%E7%BB%84%E6%89%81%E5%B9%B3%E5%8E%BB%E9%87%8D%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<blockquote>
<p>已知如下数组：<br>var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];<br>编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组</p>
</blockquote>
<h3 id="问题初步解答："><a href="#问题初步解答：" class="headerlink" title="问题初步解答："></a>问题初步解答：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [ [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, [<span class="number">11</span>, <span class="number">12</span>, [<span class="number">12</span>, <span class="number">13</span>, [<span class="number">14</span>] ] ] ], <span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<h3 id="相关参考文章："><a href="#相关参考文章：" class="headerlink" title="相关参考文章："></a>相关参考文章：</h3><ul>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FAdvanced-Frontend%2FDaily-Interview-Question%2Fissues%2F8" target="_blank" rel="noopener">第11题：将数组扁平化并去除其中重复数据，最终得到一个升序且不重复的数组</a></li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>模块循环引用</title>
    <url>/2019/04/10/2018/%E6%A8%A1%E5%9D%97%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>前端模块化</p>
<h3 id="看一个栗子"><a href="#看一个栗子" class="headerlink" title="看一个栗子"></a>看一个栗子</h3><p>在 node 环境下，a 加载了 b，而 b 又加载了 a。这种情况下，会出现什么效果呢？<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line">exports.x = <span class="string">'a1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'a.js '</span>, <span class="built_in">require</span>(<span class="string">'./b.js'</span>).x);</span><br><span class="line">exports.x = <span class="string">'a2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line">exports.x = <span class="string">'b1'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'b.js '</span>, <span class="built_in">require</span>(<span class="string">'./a.js'</span>).x);</span><br><span class="line">exports.x = <span class="string">'b2'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'main.js '</span>, <span class="built_in">require</span>(<span class="string">'./a.js'</span>).x);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'main.js '</span>, <span class="built_in">require</span>(<span class="string">'./b.js'</span>).x);</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>基础原理</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>深度优先遍历和广度优先</title>
    <url>/2019/02/26/2018/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88/</url>
    <content><![CDATA[<h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/9" target="_blank" rel="noopener">第五题：介绍下深度优先遍历和广度优先遍历，如何实现？</a></li>
</ul>
<h3 id="个人总结："><a href="#个人总结：" class="headerlink" title="个人总结："></a>个人总结：</h3><h4 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h4><p>深度优先遍历（Depth-First-Search），是搜索算法的一种，它沿着树的深度遍历树的节点，尽可能深地搜索树的分支。当节点v的所有边都已被探寻过，将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已探寻源节点到其他所有节点为止，如果还有未被发现的节点，则选择其中一个未被发现的节点为源节点并重复以上操作，直到所有节点都被探寻完成。</p>
<p>简单点来说的话就是：</p>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>理财书籍推荐</title>
    <url>/2018/01/28/2018/%E7%90%86%E8%B4%A2%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h2 id="富爸爸穷爸爸"><a href="#富爸爸穷爸爸" class="headerlink" title="富爸爸穷爸爸"></a>富爸爸穷爸爸</h2><h2 id="有钱人和你想的不一样"><a href="#有钱人和你想的不一样" class="headerlink" title="有钱人和你想的不一样"></a>有钱人和你想的不一样</h2><h2 id="听富翁讲故事"><a href="#听富翁讲故事" class="headerlink" title="听富翁讲故事"></a>听富翁讲故事</h2><h2 id="牛奶可乐经济学"><a href="#牛奶可乐经济学" class="headerlink" title="牛奶可乐经济学"></a>牛奶可乐经济学</h2><h2 id="泥鸽靶"><a href="#泥鸽靶" class="headerlink" title="泥鸽靶"></a>泥鸽靶</h2><h2 id="股票作手回忆录"><a href="#股票作手回忆录" class="headerlink" title="股票作手回忆录"></a>股票作手回忆录</h2><h2 id="黄金游戏"><a href="#黄金游戏" class="headerlink" title="黄金游戏"></a>黄金游戏</h2><h2 id="隔壁的百万富翁"><a href="#隔壁的百万富翁" class="headerlink" title="隔壁的百万富翁"></a>隔壁的百万富翁</h2><h2 id="小狗钱钱"><a href="#小狗钱钱" class="headerlink" title="小狗钱钱"></a>小狗钱钱</h2>]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端适配</title>
    <url>/2018/05/18/2018/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/</url>
    <content><![CDATA[<h2 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h2><p>简单的理解，viewport是严格等于浏览器的窗口。在桌面浏览器中，viewport就是浏览器窗口的宽度高度。但在移动端设备上就有点复杂。</p>
<p>移动端的viewport太窄，为了能更好为CSS布局服务，<code>viewport</code>分为两种类型，一种被称之为<code>visual viewport</code>虚拟视图，另一种则为<code>layout viewport</code>布局视图。简单来说布局视图就是你手机屏幕的大小，而虚拟视图的大小则是你屏幕当前显示的部分页面。通常情况下，布局视图不会发生变化，而虚拟视图则会受页面缩放的影响变化。</p>
<p>因此在进行移动端开发时，一般会通过<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;&gt;</code>进行设置，使得设备宽度等于视窗宽度，同时禁止用户进行缩放，便于更好地呈现页面效果。</p>
<p>除此之外，<strong>device pixels 物理像素</strong>（物理像素是物理意义上的绝对宽度）和 <strong>css pixels</strong>（css像素是一种相对像素）之间的差别也会影响到移动端页面的展示效果。</p>
<ul>
<li><a href="https://www.w3cplus.com/css/viewports.html" target="_blank" rel="noopener">viewport适配</a></li>
<li><a href="https://www.w3cplus.com/blog/tags/333.html" target="_blank" rel="noopener">css单位相关</a></li>
<li><a href="http://www.cnblogs.com/shxydx/articles/2856882.html" target="_blank" rel="noopener">移动端 meta</a></li>
</ul>
<h2 id="手淘的解决方案-手淘的移动端适配历史"><a href="#手淘的解决方案-手淘的移动端适配历史" class="headerlink" title="手淘的解决方案(手淘的移动端适配历史)"></a>手淘的解决方案(手淘的移动端适配历史)</h2><h4 id="flexible"><a href="#flexible" class="headerlink" title="flexible"></a><a href="https://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="noopener">flexible</a></h4><p>手淘针对存在的多种适配，选择一种尺寸作为设计和开发基准，之后前端进行适配。</p>
<p><img src="/images/rem-6.jpg" alt="手淘适配模式"></p>
]]></content>
      <categories>
        <category>WEB前端基础</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>警察与小偷</title>
    <url>/2019/03/04/2018/%E8%AD%A6%E5%AF%9F%E4%B8%8E%E5%B0%8F%E5%81%B7/</url>
    <content><![CDATA[<p>之前在论坛上看到说有这样一道面试（二面）题目：</p>
<p><img src="/images/警察与小偷.png" alt></p>
<h3 id="相关答案；"><a href="#相关答案；" class="headerlink" title="相关答案；"></a>相关答案；</h3><p>警察先到B点，小偷只能到E。<br>然后警察到C，小偷只能到A。<br>然后警察到F，小偷不管是到E还是B都会被抓。</p>
<h3 id="进一步分析："><a href="#进一步分析：" class="headerlink" title="进一步分析："></a>进一步分析：</h3><p>（假设 + 反推）</p>
<p>假设警察能抓到小偷。</p>
<p>那么抓到前需要将小偷逼到一个角落，同时让小偷先移动。（不然始终会有一个距离）</p>
<p>A与D，B与C对称，对比A、B、E和F点，只有当警察处于F点，小偷处于A点时，这时候小偷要移动才会被抓。<br>即这一步的上一步是，小偷被逼到A点，而警察可以到达F点的位置。考虑到小偷会躲避警察，那么警察此时应该处于C点。</p>
<p>而小偷能到达A点，其上一步应该是在E点。（在B点的情形之后进行遍历）</p>
<p>结合当前警察与小偷的位置，警察到C点后，小偷必然会到E点，满足了之前需要的假设步骤了。</p>
<p>因此警察能抓到小偷是true。</p>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>思维趣题</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2019/04/01/2018/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<p>原问题为：什么是防抖和节流？有什么区别？如何实现？</p>
<h3 id="相关参考："><a href="#相关参考：" class="headerlink" title="相关参考："></a>相关参考：</h3><ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/5" target="_blank" rel="noopener">第三题：节流和防抖的个人见解</a></li>
<li><a href="https://yuchengkai.cn/docs/frontend/#%E9%98%B2%E6%8A%96" target="_blank" rel="noopener">防抖</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/22" target="_blank" rel="noopener">JavaScript专题之跟着 underscore 学防抖</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/26" target="_blank" rel="noopener">JavaScript专题之跟着 underscore 学节流</a></li>
</ul>
<h3 id="自我总结："><a href="#自我总结：" class="headerlink" title="自我总结："></a>自我总结：</h3><h4 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h4><p>高频事件触发后, n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间。</p>
<p>实现思路：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">func, awit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> timeout;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> me = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">Array</span>.protoType.slice.apply(<span class="built_in">arguments</span>);</span><br><span class="line">        timeout &amp;&amp; clearTimeout(timeout);</span><br><span class="line">        timeout = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            timeout = <span class="literal">null</span>;</span><br><span class="line">            func.apply(me, args);</span><br><span class="line">        &#125;, awit);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h4><p>高频事件触发后，但在n秒内只会执行一次，所以节流会稀释函数的执行频率</p>
<blockquote>
<p>防抖和节流区别：</p>
<p>假设一个用户一直触发这个函数，且每次触发函数的间隔小于wait，防抖的情况下只会调用一次，而节流的 情况会每隔一定时间（参数wait）调用函数。</p>
</blockquote>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>2019前端思考</title>
    <url>/2019/03/14/2019-1/2019%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/</url>
    <content><![CDATA[<div id="hbe-security">
  <div class="hbe-input-container">
  <input type="password" class="hbe-form-control" id="pass" placeholder="请先输入文章密码" />
    <label for="pass">请先输入文章密码</label>
    <div class="bottom-line"></div>
  </div>
</div>
<div id="decryptionError" style="display: none;">Incorrect Password!</div>
<div id="noContentError" style="display: none;">No content to display!</div>
<div id="encrypt-blog" style="display:none">
U2FsdGVkX19JeKcDxwmWHSIaRe5VIheD9b6kpBMbly570eTH0qfWR9DsLJ1W4+XJ05C5UFJAVTe8nF6543TpzAYI3JDT13mpELjRea2kkJ8sAqDKGG1oTKtB16qRXriGok+ehayl3707YJqCstck/yYm5UIlA/Sa/YLUZvkN5kLqFScbKkqvU/79rZyLfikNdLOhqgQB6ti6sMZalvBB/gGisumhttwXTzvoLyCG2i8I68dDNbgS4Vo41uC/EZSXB0JmUuVE034LmoWB/g+vPacf8mbmZyIrEMYQQ0Ocofmo17tDwddqWsXDnHb/TAGjeQqzwqITT63WdN4fjQfURVD6F8rPGr9yvZXOeos20iqrK1RCKvZZIbWvEHH50+3PyR53UG1F+rsO/DfWisYVxaqvZx0cgV8RIvmi2G8PUy05NePCCD3/PKR4W0VzzmYOXjvQuSB05JZJcsaIZ4XtvwYYfrbZ5pWIWwylrO+9+AS+uAxNAFOancet2llSQE2p4IJyHYnKxk3jI32a9LRo90IA4eIVtL2FPjug/9ENZhv5dEvLcba4yTkUfpaMlEaUUR6Q+Sr9xjg4wN9HbhbpoHjzQinCet4I0rN2+qTUuC0YlBr6v/ZMhVjxhYsr1b+BXvvj+D7pmqhI6+uWIX1TgwXdws/T3GFqsKtr9U6+1YgN3zpt8e1doSu4a2nrwBGr/2t8204+X4qkrMEx2VK31so50oRVwQDrYo+s6VDo/fV5pvrSorOOb6ShksVU+VM6Fro0eXmpSKIcpWpPOzCvDslm6Jf11NyP+66Bn2boHO4xiKlShNJU1dHdY2vetHZl8SnLap+UFU2Lq56KdflMt0StK6eXwxHD2nV8RYaFJaM2rCX5G94kef2W1NYCt55M4iv1Qy9ZqsAOrSqBHIZtAtCdQ3M+XbGVFj2jgTsLV7FEmEj4unfbE0p0xLoqqFBOKwbVQyJcq3TItAFAD1WIKD2hTbuGaTHQMJ4vZDQIF+YTpk9eArtVcKL0ZVr8oMXTfj5b9dFRyLCKhi4DXXQMxQ/ElbhurgiXYf/TO0hERKDbAPIwskzYqX5wkn6WFeaqDZ5hZs91bL3Piv2k69pmmbDX7LADipmixixyAiLuL38zxFAq3V3Sf+R3HBQtE3CTn2JDBFSjkALzhvrX01YB2sNGHc2/Z9misG4qbh/V/+9eX3xbOXr5D96+Rk00tF8k5AVcyjLyfxFmVATU7bpXaIJI/O8cnNcWClNd46Fhpbv+aMcRWjyiU1RCR5rpI9q+QQ8+Ag3QvlaQpFsMAnbY9GDmS+KtauyStZQZbaJiMYYBrfA1nPtK8gF4dW/3D2BVfjEBh3KIqktoeWA6i7t75VqgLRk5zwFUXZjYad43D53GzcyYsNZ5NRZ0X6kT6nO6OnLAsXKDxfhAJ33i7Tbc204cr3N2vFvMfs/yyQyTxr+IQNL9ihf5+8Voub1bWAqdHb4VQfmmynQCtu0pT6hUm9jxf3lUQT8vKZ23f7/UpvGM8LSoy3D3Rq3ORWxuSOWVnAIqyMjM+UN8Jf1bzZ9HHmBYCNRtdnJmhQWA2YJgJ2LeUWkAYIGSj0vYplZzc7OLHDVMdJ/rIabJl9qT9CEg/aQBOXqr8y/F5Y3JdQpnPtN8B/EmkKG/M/YDL70FaVuVUUJZ/QeNGBUfw1rO4tjKwvK6JJL9gTTVC9QobaAS3LZc3xOs7ECjXaG0Tyx9z0Z0pq34y/Ud8zkGpytM1g9ZEPH0PRWhvYSIYy+mgg4FbbLkshjI9+TmOo9G9Iu/i4SVRhtHQbj4+wFdBCuUTCu/ZhIX4zo79MTgNbwkmTcJRFPcHjE/DJ5zUAfw29ZECz7v2UthzI7Akkk2JoT2h+pgIUq53xtAJxLXq/sIC6+Fx9v5bPmw7Bq8p82kOl8tUKTB
</div>
<script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>自我反思</category>
      </categories>
  </entry>
  <entry>
    <title>CSS隐藏效果对比</title>
    <url>/2019/04/18/2019-1/CSS%E9%9A%90%E8%97%8F%E6%95%88%E6%9E%9C%E5%AF%B9%E6%AF%94/</url>
    <content><![CDATA[<blockquote>
<p>分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景。</p>
</blockquote>
<h3 id="相关讨论："><a href="#相关讨论：" class="headerlink" title="相关讨论："></a>相关讨论：</h3><ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/100" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/100</a></li>
</ul>
<h3 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h3><ul>
<li><a href></a></li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6箭头函数</title>
    <url>/2019/04/19/2019-1/ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<blockquote>
<p>箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？</p>
</blockquote>
<h3 id="相关讨论："><a href="#相关讨论：" class="headerlink" title="相关讨论："></a>相关讨论：</h3><ul>
<li><h3 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h3></li>
<li><p><a href></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>css初始化样式</title>
    <url>/2019/05/28/2019-1/css%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%B7%E5%BC%8F/</url>
    <content><![CDATA[<p>因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。</p>
<a id="more"></a>
<h3 id="一、说明"><a href="#一、说明" class="headerlink" title="一、说明"></a>一、说明</h3><p><code>* {padding: 0; margin: 0;}</code> 这种初始化的方式，在应用较大、css样式较多时，<code>*</code> 会将所有便签初始化一次。</p>
<ul>
<li><a href="https://www.jianshu.com/p/beabef833bfe" target="_blank" rel="noopener">CSS样式初始化代码</a></li>
</ul>
<h3 id="二、示例-tabao"><a href="#二、示例-tabao" class="headerlink" title="二、示例(tabao)"></a>二、示例(tabao)</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*css 初始化 */</span></span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">hr</span>, <span class="selector-tag">p</span>, <span class="selector-tag">blockquote</span>, <span class="selector-tag">dl</span>, <span class="selector-tag">dt</span>, <span class="selector-tag">dd</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">li</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">form</span>, <span class="selector-tag">fieldset</span>, <span class="selector-tag">legend</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">textarea</span>, <span class="selector-tag">th</span>, <span class="selector-tag">td</span> &#123; <span class="attribute">margin</span>:<span class="number">0</span>; <span class="attribute">padding</span>:<span class="number">0</span>; &#125; </span><br><span class="line"><span class="selector-tag">body</span>, <span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font</span>:<span class="number">12px</span>/<span class="number">1.5</span>tahoma, arial, \<span class="number">5</span>b8b\<span class="number">4</span>f53; &#125; </span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>, <span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>&#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125; </span><br><span class="line"><span class="selector-tag">address</span>, <span class="selector-tag">cite</span>, <span class="selector-tag">dfn</span>, <span class="selector-tag">em</span>, <span class="selector-tag">var</span> &#123; <span class="attribute">font-style</span>:normal; &#125; </span><br><span class="line"><span class="selector-tag">code</span>, <span class="selector-tag">kbd</span>, <span class="selector-tag">pre</span>, <span class="selector-tag">samp</span> &#123; <span class="attribute">font-family</span>:couriernew, courier, monospace; &#125; </span><br><span class="line"><span class="selector-tag">small</span>&#123; <span class="attribute">font-size</span>:<span class="number">12px</span>; &#125; </span><br><span class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> &#123; <span class="attribute">list-style</span>:none; &#125; </span><br><span class="line"><span class="selector-tag">a</span> &#123; <span class="attribute">text-decoration</span>:none; &#125; </span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">text-decoration</span>:underline; &#125; </span><br><span class="line"><span class="selector-tag">sup</span> &#123; <span class="attribute">vertical-align</span>:text-top; &#125; </span><br><span class="line"><span class="selector-tag">sub</span>&#123; <span class="attribute">vertical-align</span>:text-bottom; &#125; </span><br><span class="line"><span class="selector-tag">legend</span> &#123; <span class="attribute">color</span>:<span class="number">#000</span>; &#125; </span><br><span class="line"><span class="selector-tag">fieldset</span>, <span class="selector-tag">img</span> &#123; <span class="attribute">border</span>:<span class="number">0</span>; &#125; </span><br><span class="line"><span class="selector-tag">button</span>, <span class="selector-tag">input</span>, <span class="selector-tag">select</span>, <span class="selector-tag">textarea</span> &#123; <span class="attribute">font-size</span>:<span class="number">100%</span>; &#125; </span><br><span class="line"><span class="selector-tag">table</span> &#123; <span class="attribute">border-collapse</span>:collapse; <span class="attribute">border-spacing</span>:<span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">/*css初始化完成*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>css垂直居中</title>
    <url>/2019/04/11/2019-1/css%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<p>在前一篇 <a href="/2019/04/11/2019-1/css水平居中/" title="css水平居中">css水平居中</a> 中，我们了解到了 CSS 水平布局的几种方式。那么如果一个元素需要垂直居中，那么又该怎么利用 CSS 实现呢？</p>
<a id="more"></a>
<h3 id="一、实现方式"><a href="#一、实现方式" class="headerlink" title="一、实现方式"></a>一、实现方式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>DOME<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-table表格-table-cell-vertical-aligin"><a href="#1-table表格-table-cell-vertical-aligin" class="headerlink" title="1. table表格 table-cell + vertical-aligin"></a>1. table表格 <code>table-cell + vertical-aligin</code></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-绝对定位-absolute-transform"><a href="#2-绝对定位-absolute-transform" class="headerlink" title="2. 绝对定位 absolute + transform"></a>2. 绝对定位 <code>absolute + transform</code></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translatY</span>(-<span class="number">50%</span>);    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-flex布局-flex-align-items"><a href="#3-flex布局-flex-align-items" class="headerlink" title="3. flex布局 flex + align-items"></a>3. flex布局 <code>flex + align-items</code></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">align-items</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-grid表格-grid-align-self"><a href="#4-grid表格-grid-align-self" class="headerlink" title="4. grid表格 grid + align-self"></a>4. grid表格 <code>grid + align-self</code></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、补充说明"><a href="#二、补充说明" class="headerlink" title="二、补充说明"></a>二、补充说明</h3><p>以上均是考虑到页面内容不定高的情况。事实上如果子元素宽度确定，也可以直接用<code>padding</code>、<code>magin</code>计算的方式使其垂直居中。</p>
<p><a href="/examples/css/垂直居中.html">实例页面</a></p>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css居中布局</tag>
      </tags>
  </entry>
  <entry>
    <title>css水平垂直居中</title>
    <url>/2019/04/11/2019-1/css%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<blockquote>
<p>如何让一个div元素在它的父容器中垂直水平居中呢？</p>
</blockquote>
<ul>
<li><a href="/2019/04/11/2019-1/css水平居中/" title="css水平居中">css水平居中</a></li>
<li><a href="/2019/04/11/2019-1/css垂直居中/" title="css垂直居中">css垂直居中</a>
</li>
</ul>
<a id="more"></a>
<h3 id="一、实现方式"><a href="#一、实现方式" class="headerlink" title="一、实现方式"></a>一、实现方式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>DOME<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-行内元素特性-table-cell-vertical-align-inline-block-text-align"><a href="#1-行内元素特性-table-cell-vertical-align-inline-block-text-align" class="headerlink" title="1. 行内元素特性 table-cell + vertical-align + inline-block + text-align"></a>1. 行内元素特性 <code>table-cell + vertical-align + inline-block + text-align</code></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-绝对定位-absolute-transform"><a href="#2-绝对定位-absolute-transform" class="headerlink" title="2. 绝对定位 absolute + transform"></a>2. 绝对定位 <code>absolute + transform</code></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-flex布局-flex-justify-content-align-items"><a href="#3-flex布局-flex-justify-content-align-items" class="headerlink" title="3. flex布局 flex + justify-content + align-items"></a>3. flex布局 <code>flex + justify-content + align-items</code></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-grid布局-grid-justify-self-align-self"><a href="#3-grid布局-grid-justify-self-align-self" class="headerlink" title="3. grid布局 grid + justify-self + align-self"></a>3. grid布局 <code>grid + justify-self + align-self</code></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">justify-self</span>: center;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、补充说明"><a href="#二、补充说明" class="headerlink" title="二、补充说明"></a>二、补充说明</h3><p>以上均是考虑到页面内容不定宽高的情况。事实上如果父元素和子元素宽高度确定，也可以直接用<code>padding</code>、<code>magin</code>计算的方式使其垂直居中。</p>
<p><a href="/examples/css/水平垂直居中.html">实例页面</a></p>
<blockquote>
<p>注意 <code>disply: table-cell;</code> 的元素，不支持设置 <code>width: 100%;</code>; 如果想实现 <code>width: 100%;</code> 的效果最好给其设置一个 <code>disply: table;</code> 的元素。</p>
</blockquote>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css居中布局</tag>
      </tags>
  </entry>
  <entry>
    <title>css水平居中</title>
    <url>/2019/04/11/2019-1/css%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD/</url>
    <content><![CDATA[<div style="width: 300px; background-color: #ccc; display: flex;"><div style="background-color: #000; color: #fff;margin: 0 auto;">DOME</div></div>

<p>在 CSS 中，如何让一个元素水平居中，即如何实现水平居中布局？长话短说，让我们一起来看下吧。</p>
<a id="more"></a>
<h3 id="一、实现方式"><a href="#一、实现方式" class="headerlink" title="一、实现方式"></a>一、实现方式</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>DOME<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1-行内元素特性-inline-block-text-align"><a href="#1-行内元素特性-inline-block-text-align" class="headerlink" title="1. 行内元素特性 inline-block + text-align"></a>1. 行内元素特性 <code>inline-block + text-align</code></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-块级表格-table-margin"><a href="#2-块级表格-table-margin" class="headerlink" title="2. 块级表格  table + margin"></a>2. 块级表格  <code>table + margin</code></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-绝对定位-absolute-transform"><a href="#3-绝对定位-absolute-transform" class="headerlink" title="3. 绝对定位  absolute + transform"></a>3. 绝对定位  <code>absolute + transform</code></h4><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>); <span class="comment">/* 相对自身 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-flex"><a href="#3-flex" class="headerlink" title="3. flex"></a>3. flex</h4><h5 id="1-flex-justify-content"><a href="#1-flex-justify-content" class="headerlink" title="1. flex + justify-content"></a>1. <code>flex + justify-content</code></h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-flex-margin"><a href="#2-flex-margin" class="headerlink" title="2. flex + margin"></a>2. <code>flex + margin</code></h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-gird"><a href="#4-gird" class="headerlink" title="4. gird"></a>4. gird</h4><h5 id="1-gird-justify-content"><a href="#1-gird-justify-content" class="headerlink" title="1. gird + justify-content"></a>1. <code>gird + justify-content</code></h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: gird;</span><br><span class="line">    <span class="attribute">justify-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-gird-margin"><a href="#2-gird-margin" class="headerlink" title="2. gird + margin"></a>2. <code>gird + margin</code></h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: gird;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、补充说明"><a href="#二、补充说明" class="headerlink" title="二、补充说明"></a>二、补充说明</h3><p>以上均是考虑到页面内容不定宽的情况。事实上如果元素的子元素宽度确定，可以直接用<code>margin: 0 auto;</code>使其水平居中。</p>
<p><a href="/examples/css/水平居中.html">实例页面</a></p>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>css居中布局</tag>
      </tags>
  </entry>
  <entry>
    <title>img宽度调整</title>
    <url>/2019/04/23/2019-1/img%E5%AE%BD%E5%BA%A6%E8%B0%83%E6%95%B4/</url>
    <content><![CDATA[<blockquote>
</blockquote>
<h3 id="一、实现思路"><a href="#一、实现思路" class="headerlink" title="一、实现思路"></a>一、实现思路</h3><h3 id="相关讨论："><a href="#相关讨论：" class="headerlink" title="相关讨论："></a>相关讨论：</h3><ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/105" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/105</a></li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>冒泡排序</title>
    <url>/2019/04/15/2019-1/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="相关讨论："><a href="#相关讨论：" class="headerlink" title="相关讨论："></a>相关讨论：</h3><ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/94" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/94</a></li>
</ul>
<h3 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h3><ul>
<li><a href></a></li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>token原理</title>
    <url>/2019/04/24/2019-1/token%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="一、token"><a href="#一、token" class="headerlink" title="一、token"></a>一、token</h3><h4 id="举个栗子："><a href="#举个栗子：" class="headerlink" title="举个栗子："></a>举个栗子：</h4><p>如何在客户端与服务器断开连接后，客户端不直接存储用户的账号和密码的情况下，实现自动登录，即避免用户多次输入登录。（持久化登录）</p>
<h4 id="token机制："><a href="#token机制：" class="headerlink" title="token机制："></a>token机制：</h4><ol>
<li>客户端通过，账户和密码请求登录。</li>
<li>服务器收到请求，验证账户密码。验证成功后，签发一个字符串<code>token</code>（包含部分用户信息和过期时间）给客户端。</li>
<li>客户端请求时，带上<code>token</code>。</li>
<li>服务器收到请求后，验证<code>token</code>，通过则返回对应数据，否则给出错误信息。</li>
</ol>
<p><strong>用户匹配</strong>：在实际使用中通过添加用户的少量信息，如 <code>useId</code>，就能将 <code>token</code> 与用户进行关联。 </p>
<h4 id="token校验："><a href="#token校验：" class="headerlink" title="token校验："></a>token校验：</h4><p><code>token</code>虽然可以持久化登录，但是服务器又该怎么确保<code>token</code>的正确性呢？（防止伪造）</p>
<ul>
<li><strong>防伪造</strong>：服务器利用私钥对一些不敏感的信息加密生成签名，将签名和数据拼接作为token的一部分。例如 JWT，参考<a href="http://blog.leapoahead.com/2015/09/06/understanding-jwt/" target="_blank" rel="noopener">JSON Web Token - 在Web应用间安全地传递信息</a>。</li>
<li><strong>干扰码</strong>：服务器生成 <code>token</code> 时，可以使用客户端的UA作为干扰码对数据加密。客户端请求时，服务器可以使用UA对<code>token</code>解密。</li>
<li><strong>有效期</strong>：通过加入有效期，使得 <code>token</code> 仅在一段时间内有效，这样能尽量减少损失。</li>
</ul>
<h4 id="token刷新："><a href="#token刷新：" class="headerlink" title="token刷新："></a>token刷新：</h4><p><strong><code>token</code> 过期机制：</strong></p>
<ul>
<li>服务器缓存<code>token</code>及对应的过期时间，需要服务器更新过期时间，<code>token</code>就会再次有效。</li>
<li><code>token</code>中包含有过期时间。需要重新生成 <code>token</code>。</li>
</ul>
<p>当 <code>token</code> 过期了，如果客户端希望刷新 <code>token</code> 的话，需要重新引入数据来验证。一种是让用户重新输入账号密码。另一种方式就是使用摘要。即在生成 <code>token</code> 的同时，生成 <code>token</code> 的摘要，一起返回给客户端，类似于微信登录的 refresh_token。</p>
<h3 id="二、相关讨论："><a href="#二、相关讨论：" class="headerlink" title="二、相关讨论："></a>二、相关讨论：</h3><ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/106" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/106</a></li>
</ul>
<h3 id="三、相关阅读："><a href="#三、相关阅读：" class="headerlink" title="三、相关阅读："></a>三、相关阅读：</h3><ul>
<li><a href="https://blog.csdn.net/maocai008/article/details/79064542" target="_blank" rel="noopener">关于token、签名、加密的一点理解</a></li>
<li><a href="https://www.jianshu.com/p/e0ac7c3067eb" target="_blank" rel="noopener">Token - 服务端身份验证的流行方案</a></li>
<li><a href="https://ninghao.net/blog/2834" target="_blank" rel="noopener">基于 Token 的身份验证：JSON Web Token</a></li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>取交集</title>
    <url>/2019/04/22/2019-1/%E5%8F%96%E4%BA%A4%E9%9B%86/</url>
    <content><![CDATA[<blockquote>
<p>给定两个数组，写一个方法来计算它们的交集。<br>例如：给定 nums1 = [1, 2, 2, 1]，nums2 = [2, 2]，返回 [2, 2]</p>
</blockquote>
<h3 id="一、初步解答"><a href="#一、初步解答" class="headerlink" title="一、初步解答"></a>一、初步解答</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIntersection</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    num1.forEach(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num2.indexOf(num) !== <span class="number">-1</span>) &#123;</span><br><span class="line">            result.push(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIntersection</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1.filter(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> num2.includes(num);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、易错点"><a href="#二、易错点" class="headerlink" title="二、易错点"></a>二、易错点</h3><p>举个反例： <code>num1 = [1, 1]; num2 = [1];</code></p>
<p>对于这种情况，要么利用空间换取时间，要么提高时间复杂度</p>
<ul>
<li>空间换时间：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIntersection</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> maps = &#123;&#125;;</span><br><span class="line">    <span class="keyword">const</span> result = [];</span><br><span class="line">    num1.forEach(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maps[num]) &#123;</span><br><span class="line">            maps[num] += <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            maps[num] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    num2.forEach(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maps[num]) &#123;</span><br><span class="line">            result.push(num);</span><br><span class="line">            maps[num] -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>不使用额外空间：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getIntersection</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1.filter(<span class="function"><span class="params">num</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> index = num2.indexOf(num);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index !== <span class="number">-1</span>) &#123;</span><br><span class="line">            num2.splice(index, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、相关讨论："><a href="#三、相关讨论：" class="headerlink" title="三、相关讨论："></a>三、相关讨论：</h3><ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/102" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/102</a></li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个lazyman</title>
    <url>/2019/04/16/2019-1/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAlazyman/</url>
    <content><![CDATA[<blockquote>
<p>请设计一个 <code>LazyMan</code> 类，实现以下功能。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">LazyMan(<span class="string">'Tony'</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">'Tony'</span>).sleep(<span class="number">10</span>).eat(<span class="string">'lunch'</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">'Tony'</span>).eat(<span class="string">'lunch'</span>).sleep(<span class="number">10</span>).eat(<span class="string">'dinner'</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating diner</span></span><br><span class="line"></span><br><span class="line">LazyMan(<span class="string">'Tony'</span>).eat(<span class="string">'lunch'</span>).eat(<span class="string">'dinner'</span>).sleepFirst(<span class="number">5</span>).sleep(<span class="number">10</span>).eat(<span class="string">'junk food'</span>);</span><br><span class="line"><span class="comment">// Hi I am Tony</span></span><br><span class="line"><span class="comment">// 等待了5秒...</span></span><br><span class="line"><span class="comment">// I am eating lunch</span></span><br><span class="line"><span class="comment">// I am eating dinner</span></span><br><span class="line"><span class="comment">// 等待了10秒...</span></span><br><span class="line"><span class="comment">// I am eating junk food</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="一、试题分析"><a href="#一、试题分析" class="headerlink" title="一、试题分析"></a>一、试题分析</h3><p><code>LazyMan</code> 类具有的特点有：</p>
<ul>
<li>无需<code>new</code>关键字便可创建对象。</li>
<li>所有方法支持链式调用。</li>
<li><code>eat</code> 方法并不是立即执行。</li>
</ul>
<h3 id="二、我的实现"><a href="#二、我的实现" class="headerlink" title="二、我的实现"></a>二、我的实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LazyMan</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> LazyMan)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LazyMan(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.delayTime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">this</span>.tasks = [];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi I am <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">this</span>._ready();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LazyMan.prototype._ready = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`等待了<span class="subst">$&#123;<span class="keyword">this</span>.delayTime&#125;</span>秒...`</span>);</span><br><span class="line">            <span class="keyword">this</span>._doTasks();</span><br><span class="line">        &#125;, <span class="keyword">this</span>.delayTime * <span class="number">1000</span>);</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LazyMan.prototype._doTasks = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> tasks = <span class="keyword">this</span>.tasks;</span><br><span class="line">    <span class="keyword">if</span> (tasks.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">const</span> &#123;delayTime, callback&#125; = tasks[<span class="number">0</span>];</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        callback &amp;&amp; callback();</span><br><span class="line">        tasks.shift();</span><br><span class="line">        <span class="keyword">this</span>._doTasks();</span><br><span class="line">    &#125;, delayTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LazyMan.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">foods</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(&#123;</span><br><span class="line">        delayTime: <span class="number">0</span>,</span><br><span class="line">        callback() &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`I am eating <span class="subst">$&#123;foods&#125;</span>`</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LazyMan.prototype.sleep = <span class="function"><span class="keyword">function</span> (<span class="params">seconds</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (seconds &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.tasks.push(&#123;</span><br><span class="line">            delayTime: seconds * <span class="number">1000</span>,</span><br><span class="line">            callback() &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`等待了<span class="subst">$&#123;seconds&#125;</span>秒...`</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LazyMan.prototype.sleepFirst = <span class="function"><span class="keyword">function</span> (<span class="params">seconds</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (seconds &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.delayTime = seconds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、实现思路细节优化"><a href="#三、实现思路细节优化" class="headerlink" title="三、实现思路细节优化"></a>三、实现思路细节优化</h3><ul>
<li><code>eat</code>、<code>sleep</code>、<code>sleepFirst</code> 均会向任务列表插入回调</li>
<li>简化整个任务队列的执行</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">LazyMan</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> LazyMan)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LazyMan(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.tasks = [];</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Hi I am <span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span>`</span>);</span><br><span class="line">    <span class="comment">// 让任务队列注册后自动执行</span></span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.next();</span><br><span class="line">    &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LazyMan.prototype.next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> task = <span class="keyword">this</span>.tasks.shift();</span><br><span class="line">    task &amp;&amp; task();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LazyMan.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params">foods</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tasks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`I am eating <span class="subst">$&#123;foods&#125;</span>`</span>);</span><br><span class="line">        <span class="keyword">this</span>.next();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LazyMan.prototype.sleep = <span class="function"><span class="keyword">function</span> (<span class="params">seconds</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (seconds &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.tasks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`等待了<span class="subst">$&#123;seconds&#125;</span>秒...`</span>);</span><br><span class="line">                <span class="keyword">this</span>.next();</span><br><span class="line">            &#125;, seconds * <span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LazyMan.prototype.sleepFirst = <span class="function"><span class="keyword">function</span> (<span class="params">seconds</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (seconds &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.tasks.unshift(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`等待了<span class="subst">$&#123;seconds&#125;</span>秒...`</span>);</span><br><span class="line">                <span class="keyword">this</span>.next();</span><br><span class="line">            &#125;, seconds * <span class="number">1000</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、相关讨论："><a href="#四、相关讨论：" class="headerlink" title="四、相关讨论："></a>四、相关讨论：</h3><ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/98" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/98</a></li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>无缝轮播</title>
    <url>/2019/04/28/2019-1/%E6%97%A0%E7%BC%9D%E8%BD%AE%E6%92%AD/</url>
    <content><![CDATA[<p>轮播图，前端开发中常见的UI交互。而无缝轮播，其实上就是将第一张图片或轮播区的内容，复制放置到最后，当最后的图片，也就是第一张图被轮播到视图区时，将第一张替换过来，用户感觉不到视觉差异，实现无缝效果。</p>
<p><img src="/images/无缝轮播.webp" alt></p>
<h3 id="一、实现："><a href="#一、实现：" class="headerlink" title="一、实现："></a>一、实现：</h3><p><a href="/examples/demo/无缝轮播.html">demo</a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="二、相关讨论："><a href="#二、相关讨论：" class="headerlink" title="二、相关讨论："></a>二、相关讨论：</h3><ul>
<li><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/108" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/108</a></li>
</ul>
<h3 id="三、相关阅读："><a href="#三、相关阅读：" class="headerlink" title="三、相关阅读："></a>三、相关阅读：</h3><ul>
<li><a href="https://www.jianshu.com/p/d3c650a5c994" target="_blank" rel="noopener">原生JavaScript无缝轮播图特效</a></li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
  </entry>
  <entry>
    <title>函数式编程</title>
    <url>/2019/07/22/2019-2/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<p>什么是函数式编程，函数式编程能为我们解决什么问题？</p>
<a id="more"></a>
<h3 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h3><p><strong>函数式编程</strong> 是一种 <strong>编程范式</strong>，是编程的一种方法论。其中常见的编程范式有 <strong>命令式编程</strong>、<strong>函数式编程</strong>和<strong>逻辑式编程</strong>。</p>
<p><strong>命令式编程</strong> 是对 <strong>计算机硬件的一种抽象</strong>，拥有 变量（存储单元），表达式（内存引用、数学运算）和控制语句（跳转指令）。通过将达到目的的步骤详情的描述出来，交给程序处理。即命令式程序就是一个冯诺依曼机的 <strong>指令序列</strong>。</p>
<p>而 <strong>函数式编程</strong> 则是对<strong>数学的抽象</strong>，将运算过程描述为一种 <strong>表达式求值</strong>。</p>
<p>简单来说就是，<strong>命令式编程关心解决问题的步骤，而函数式编程关心数据的映射</strong> （该映射规则只关心输入，相同的输入总是获得一致的输出）。</p>
<p>举个例子对比一下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// demo 计算 1 + 2 - 3 + 4</span></span><br><span class="line"><span class="comment">// 命令行式</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">1</span> + <span class="number">2</span>;</span><br><span class="line">a = a - <span class="number">3</span>;</span><br><span class="line">a = a + <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subtract</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line">add(subtract(add(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>), <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了避免代码过于 <strong>横向拓展</strong>，陷入“回调地狱”，建议进行 <strong>链式优化</strong> 或 <strong>Promise模式</strong>。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// loadash 链式写法</span></span><br><span class="line"><span class="keyword">const</span> utils = &#123;</span><br><span class="line">    chain (n) &#123;</span><br><span class="line">        <span class="keyword">this</span>._temp = n;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    add (b) &#123;</span><br><span class="line">        <span class="keyword">this</span>._temp += b;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    substract (b) &#123;</span><br><span class="line">        <span class="keyword">this</span>._temp += b;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">utils.chain(<span class="number">1</span>).add(<span class="number">2</span>).subtract(<span class="number">3</span>).add(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>
<h4 id="1-函数式编程的本质："><a href="#1-函数式编程的本质：" class="headerlink" title="1. 函数式编程的本质："></a>1. 函数式编程的本质：</h4><ul>
<li>函数是一等公民（函数与其他数据类型一样，处于平等地位，能进行赋值和传参）</li>
<li>引用透明 &amp; 没有副作用（函数的运行不依赖外部状态，也不会修改外部状态）</li>
<li>不可变性（函数保持独立，不会对输入参数进行变更，只返回新的值）</li>
</ul>
<p><strong>函数式编程具有的好处有：</strong></p>
<ul>
<li>语义更加清晰</li>
<li>可复用性更高</li>
<li>可维护性好（函数保持独立，没有副作用，每一个函数都可视作一个单元，进行测试和调试）</li>
<li>易于“并发”，不会造成资源争用（不依赖外部状态）</li>
</ul>
<p>不过由于函数参数的不可变性，纯函数编程语言是无法实现循环的，只能通过递归的方式解决迭代问题，这使得函数式编程严重依赖递归。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n === <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> factorial(n - <span class="number">1</span>) * n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这样的递归调用有更高的开销和局限（调用栈深度），可以尽量把递归写成尾递归的方式，编译器会自动优化为循环。</p>
</blockquote>
<h3 id="二、常见函数式编程模型"><a href="#二、常见函数式编程模型" class="headerlink" title="二、常见函数式编程模型"></a>二、常见函数式编程模型</h3><h4 id="1-高阶函数（Higher-order-function）"><a href="#1-高阶函数（Higher-order-function）" class="headerlink" title="1. 高阶函数（Higher-order function）"></a>1. 高阶函数（Higher-order function）</h4><blockquote>
<p>接受或返回一个函数的函数被称为高阶函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// map 映射将集合的每一项都做了相同转换处理</span></span><br><span class="line">arr.map(<span class="function"><span class="params">n</span> =&gt;</span> ++n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">const</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">    result.push(++i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-闭包（Closure）"><a href="#2-闭包（Closure）" class="headerlink" title="2. 闭包（Closure）"></a>2. 闭包（Closure）</h4><blockquote>
<p>可以保留局部变量不被释放的代码块，被称为一个闭包。闭包存在内、外两层函数，同时内层函数对外层函数的局部变量进行了引用。</p>
</blockquote>
<p>例如斐波那契数列，可利用闭包缓存运算结果：<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建闭包</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fibonacciSequence</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data = [<span class="number">1</span>, <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> sequence = <span class="function"><span class="params">n</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!data[n]) &#123;</span><br><span class="line">            data[n] = sequence(n - <span class="number">1</span>) + sequence(n - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sequence = fibonacciSequence();</span><br><span class="line"><span class="built_in">console</span>.log(sequence(<span class="number">6</span>));  <span class="comment">// 13</span></span><br><span class="line"><span class="built_in">console</span>.log(sequence(<span class="number">5</span>));  <span class="comment">// 8</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>闭包的主要用于持久化变量，并利用这些变量做缓存或者持久化变量。但是持久化变量会持续占用内存空间，易造成内存浪费，一般需要进行额外的手动清除。</p>
</blockquote>
<h4 id="3-柯里化（Currying）"><a href="#3-柯里化（Currying）" class="headerlink" title="3. 柯里化（Currying）"></a>3. 柯里化（Currying）</h4><blockquote>
<p>给定一个函数的部分参数，生成一个接受其他参数的新函数，即为柯里化。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取相对于 BASE 的路径</span></span><br><span class="line"><span class="keyword">const</span> BASE = <span class="string">'/path/to/base'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般写法</span></span><br><span class="line"><span class="keyword">const</span> aPath = path.relative(BASE, <span class="string">'/a'</span>);</span><br><span class="line"><span class="keyword">const</span> bPath = path.relative(BASE, <span class="string">'/b'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// _.parical 改写</span></span><br><span class="line"><span class="keyword">const</span> relativeFromBase = _.partial(path.relative, BASE);</span><br><span class="line"><span class="keyword">const</span> aPath = relativeFromBase(<span class="string">'/a'</span>);</span><br><span class="line"><span class="keyword">const</span> bPath = relativeFromBase(<span class="string">'/b'</span>);</span><br></pre></td></tr></table></figure>
<p>本例中 <code>aPath</code> 和 <code>bPath</code> 不用再关心 <code>BASE</code> 路径。<strong>柯里化可以使我们只关心函数的部分参数，使函数的用途更加清晰，调用更加简单。</strong></p>
<h4 id="4-组合（Composing）"><a href="#4-组合（Composing）" class="headerlink" title="4. 组合（Composing）"></a>4. 组合（Composing）</h4><blockquote>
<p>将多个函数的能力合并，创造一个新的函数，便是组合。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组中每个单词大写，做 Base64</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'pen'</span>, <span class="string">'apple'</span>, <span class="string">'applypen'</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一般写法 (其中一种)</span></span><br><span class="line"><span class="keyword">const</span> rs = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> w <span class="keyword">of</span> arr)&#123;</span><br><span class="line">  rs.push(btoa(w.toUpperCase()));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(rs);</span><br><span class="line"></span><br><span class="line"><span class="comment">// _.flow 改写</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">'pen'</span>, <span class="string">'apple'</span>, <span class="string">'applypen'</span>];</span><br><span class="line"><span class="keyword">const</span> upperAndBase64 = _.partialRight(_.map, _.flow(_.upperCase, btoa));</span><br><span class="line"><span class="built_in">console</span>.log(upperAndBase64(arr));</span><br></pre></td></tr></table></figure>
<p>_.flow 将转大写和转 Base64 的函数的能力合并，生成一个新的函数。方便作为参数函数或后续复用。</p>
<h4 id="5-函数式组件"><a href="#5-函数式组件" class="headerlink" title="5. 函数式组件"></a>5. 函数式组件</h4><blockquote>
<p>一个函数就是一个组件，其入参为渲染的上下文，返回值则是渲染好的 HTML。</p>
</blockquote>
<p>对于函数式组件而言，其特点有：</p>
<ul>
<li><code>Stateless</code>，组件自身没有状态</li>
<li><code>Instanceless</code>，组件自身也没有实例，即 <code>this</code>。</li>
<li>无生命周期</li>
</ul>
<blockquote>
<p>当组件不涉及内部状态，只是用于数据渲染时，函数式组件更轻量，性能更好。具体内容可参考 <code>React</code> 和 <code>Vue</code> 的函数式组件。</p>
</blockquote>
<h3 id="三、自己眼中的函数式编程"><a href="#三、自己眼中的函数式编程" class="headerlink" title="三、自己眼中的函数式编程"></a>三、自己眼中的函数式编程</h3><p>我理解的函数式编程，是 <strong>以函数为载体，进行数据的映射处理</strong>，其独立而不受外界影响。虽然函数式编程有很多优点和场景，但是在开发过程中，我们不应该拘泥于这一种编程思维，而应该多对比思考其他思想，甚至多种结合进行设置。</p>
<blockquote>
<p>此处警醒自己不要钻牛角尖</p>
</blockquote>
<h3 id="四、参考文章"><a href="#四、参考文章" class="headerlink" title="四、参考文章"></a>四、参考文章</h3><ul>
<li><a href="http://www.ruanyifeng.com/blog/2012/04/functional_programming.html" target="_blank" rel="noopener">函数式编程初探 - 阮一峰</a></li>
<li><a href="http://taobaofed.org/blog/2017/03/16/javascript-functional-programing/" target="_blank" rel="noopener">我眼中的 JavaScript 函数式编程 - 淘宝 FED</a>  (推荐阅读)</li>
<li><a href="https://www.zhihu.com/question/28292740" target="_blank" rel="noopener">什么是函数式思维 - 知乎问答</a></li>
<li><a href="https://juejin.im/post/5b38f4bef265da59bc2cb921" target="_blank" rel="noopener">Vuejs函数式组件，你值得拥有</a></li>
</ul>
]]></content>
      <categories>
        <category>基础原理</category>
      </categories>
      <tags>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>前端开发规范</title>
    <url>/2019/06/26/2019-2/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
    <content><![CDATA[<p>一个良好的开发规范能够给代码一个更好的可读性、复用性、拓展性。</p>
<a id="more"></a>
<h3 id="一、JavaScript-命名规范"><a href="#一、JavaScript-命名规范" class="headerlink" title="一、JavaScript 命名规范"></a>一、JavaScript 命名规范</h3><ul>
<li>变量使用<code>有意义</code>且<code>常用</code>的单词，尽量<code>简短</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">const</span> yyyymmdstr = moment().format(<span class="string">'YYYY/MM/DD'</span>);</span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">const</span> currentDate = moment().format(<span class="string">'YYYY/MM/DD'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>每个常量需要<code>大写</code>，同时有意义</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad: 其他人知道 86400000 的意思吗？</span></span><br><span class="line">setTimeout( blastOff, <span class="number">86400000</span> );</span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">const</span> MILLISECOND_IN_A_DAY = <span class="number">86400000</span>;</span><br><span class="line">setTimeout( blastOff, MILLISECOND_IN_A_DAY );</span><br></pre></td></tr></table></figure>
<ul>
<li>对象属性避免无意义命名</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">    carMake: <span class="string">'Honda'</span>,</span><br><span class="line">    carModel: <span class="string">'Accord'</span>,</span><br><span class="line">    carColor: <span class="string">'Blue'</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">const</span> car = &#123;</span><br><span class="line">    make: <span class="string">'Honda'</span>,</span><br><span class="line">    model: <span class="string">'Accord'</span>,</span><br><span class="line">    color: <span class="string">'Blue'</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数名需要体现其作用（建议和一个函数仅处理一件事规则相匹配，这样函数的表达才更加具体）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emailClients</span>(<span class="params"> clients </span>) </span>&#123;</span><br><span class="line">    clients.forEach( <span class="function"><span class="params">client</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> clientRecord = database.lookup( client );</span><br><span class="line">        <span class="keyword">if</span> ( clientRecord.isActive() ) &#123;</span><br><span class="line">            email( client );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Good: </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emailActiveClients</span>(<span class="params"> clients </span>) </span>&#123;</span><br><span class="line">    clients</span><br><span class="line">        .filter( isActiveClient )</span><br><span class="line">        .forEach( email );</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isActiveClient</span>(<span class="params"> client </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> clientRecord = database.lookup( client );    </span><br><span class="line">    <span class="keyword">return</span> clientRecord.isActive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二、JavaScript-开发规范"><a href="#二、JavaScript-开发规范" class="headerlink" title="二、JavaScript 开发规范"></a>二、JavaScript 开发规范</h3><ul>
<li><code>一个方法只做一件事</code>。（这是一条在软件工程领域流传久远的规则，遵循这条规则能让你的代码可读性更好，也便于后续重构）</li>
<li>函数参数使用默认值（可以和解构参数相配合）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">    name = name || <span class="string">'Jack'</span>;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// good:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name = <span class="string">'Jack'</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数参数最好2个或更少（如果参数超过两个，建议使用ES6的解构语法）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">name, sex, desc</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// good:</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span> (<span class="params">&#123;name, sex, desc&#125;</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>避免使用全局方法（如需使用请添加一个命名空间）</li>
<li><code>删除重复代码，合并相似函数</code> （方便后期维护，但是不建议盲目合并）</li>
<li><code>删除弃用代码</code> （项目迭代过程中，如果功能变更导致的弃用代码，请删除，不要只是注释！！！）</li>
<li>尽可能地支持链式调用（能使得代码简洁优雅）</li>
<li>不要过度优化 (现代浏览器已经在底层做了很多优化，过去的很多优化方案都是无效的，会浪费你的时间。)</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Bad:</span></span><br><span class="line"><span class="comment">// 现代浏览器已对此( 缓存 list.length )做了优化。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = list.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Good:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用 <code>Promise</code> 或 <code>Async/Await</code> 代替回调</li>
</ul>
<h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul>
<li><a href="https://juejin.im/post/5d0e11196fb9a07eee5ed6d2" target="_blank" rel="noopener">[译] 如何写出漂亮的 JavaScript 代码</a></li>
</ul>
]]></content>
      <categories>
        <category>前端方案</category>
      </categories>
      <tags>
        <tag>开发规范</tag>
      </tags>
  </entry>
  <entry>
    <title>图片懒加载及异常处理</title>
    <url>/2019/05/31/2019-2/%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<p>在日常页面开发中，常常会涉及到图片的展示。有时候当图片资源过多时，我们希望能将图片延迟加载，同时当图片加载失败后，能用一张默认图片去代替其进行展示。其效果如图所示：</p>
<a id="more"></a>
<p><img src="/images/img-load.gif" alt></p>
<h3 id="一、图片懒加载"><a href="#一、图片懒加载" class="headerlink" title="一、图片懒加载"></a>一、图片懒加载</h3><p>其实图片懒加载的核心思想很简单：</p>
<ol>
<li>通过预先将图片的src资源指向一张小图片或空，并通过 <code>data-src</code> 来记录其实际图片地址。</li>
<li>通过延迟加载或监听滚动事件（图片出现在可视区域中）， 将 <code>data-src</code> 属性值赋值给 <code>src</code> 实现图片的懒加载。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(&#123;</span><br><span class="line">    $imgs.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $img = $(<span class="keyword">this</span>);</span><br><span class="line">        $img.src = $img.attr(<span class="string">'data-src'</span>);</span><br><span class="line">    &#125;);  </span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 500ms 防抖动，避免回调频繁执行，影响性能</span></span><br><span class="line">$(<span class="built_in">window</span>).on(<span class="string">'scroll'</span>, _.debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> $<span class="built_in">window</span> = $(<span class="built_in">window</span>); </span><br><span class="line">    <span class="keyword">var</span> top = <span class="built_in">parseInt</span>($<span class="built_in">window</span>.height()) + <span class="built_in">parseInt</span>($<span class="built_in">window</span>.scrollTop());</span><br><span class="line">    $imgs.each(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> $img = $(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">var</span> oSrc = $img.attr(<span class="string">'data-src'</span>);</span><br><span class="line">        <span class="keyword">if</span> (!oSrc) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> ($img.offset().top &lt; top) &#123;</span><br><span class="line">            $img.src = oSrc;</span><br><span class="line">            $img.attr(<span class="string">'data-src'</span>, <span class="string">''</span>);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;, <span class="number">500</span>));</span><br></pre></td></tr></table></figure>
<h3 id="二、图片加载错误处理"><a href="#二、图片加载错误处理" class="headerlink" title="二、图片加载错误处理"></a>二、图片加载错误处理</h3><p>有些时候，由于网络请求或是资源问题，导致图片资源请求失败，这时图片会展示为非常难看的效果（破碎的图片）。这时可以通过监听图片的 <code>onerror</code> 时间来处理。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $img.src = <span class="string">'default.jpg'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了避免默认图片也加载失败时，图片资源无限执行的情况，可以利用 jQuery 的 <code>one()</code> api 接口绑定一个一次性的 <code>onerror</code> 事件。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$img.one(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $img.src = <span class="string">'default.jpg'</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>tip:</strong> 在加载图片时，我们可以利用创建一个不在 渲染树 中的 Img 元素来加载图片资源。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oSrc = $img.attr(<span class="string">'data-src'</span>);</span><br><span class="line"><span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    $img.src = oSrc;</span><br><span class="line">&#125;;</span><br><span class="line">img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.debug(<span class="string">'图片加载失败:'</span>, img.src);</span><br><span class="line">    <span class="comment">// 此时 $img src 依然为默认图，如果图片是否替换判断不为 data-src ，可不进行清空</span></span><br><span class="line">    $img.attr(<span class="string">'data-src'</span>, <span class="string">''</span>);</span><br><span class="line">&#125;;</span><br><span class="line">img.src = oSrc;</span><br></pre></td></tr></table></figure>
<h3 id="三、利用-background-size-属性代替-img-标签"><a href="#三、利用-background-size-属性代替-img-标签" class="headerlink" title="三、利用 background-size 属性代替 img 标签"></a>三、利用 <code>background-size</code> 属性代替 <code>img</code> 标签</h3><p>大多数的时候，图片所处位置的宽高都是固定的。但是图片实际的宽高都是未知的，图片宽高的设置方式有：</p>
<ol>
<li>直接将 <code>img</code> 的宽高设置为 <code>img { width: 100%; height: 100%; }</code>可能会出现图片严重失真。</li>
<li>通过设置最大宽高的方式 <code>img { max-width: 100%; max-height: 100%; }</code> 会出现上下或左右的留白，同时当资源图片宽高小于容器时，留白更多。</li>
</ol>
<p><code>background-size: cover;</code> 能够对图片最大程度的利用，不存在留白和图片失真的问题。不过该方式会存在图片资源的损失（图片不能完全展示）。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.img</span> &#123;</span><br><span class="line">    <span class="attribute">background-repeat</span>: no-repeat;</span><br><span class="line">    <span class="attribute">background-size</span>: cover;</span><br><span class="line">    <span class="attribute">background-position</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="四、利用-Vue-实现一个图片处理指令"><a href="#四、利用-Vue-实现一个图片处理指令" class="headerlink" title="四、利用 Vue 实现一个图片处理指令"></a>四、利用 Vue 实现一个图片处理指令</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    bind(el, binding) &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span><br><span class="line">            img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                el.style.backgroundImage = <span class="string">`url(<span class="subst">$&#123;binding.value&#125;</span>)`</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">            img.onerror = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="built_in">console</span>.debug(<span class="string">'图片加载失败:'</span>, img.src);</span><br><span class="line">            &#125;;</span><br><span class="line">            img.src = binding.value;</span><br><span class="line">        &#125;, <span class="number">0</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>完整示例代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>图片懒加载处理<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.img-group</span> &#123;</span></span><br><span class="line">            display: flex;</span><br><span class="line">            width: 800px;</span><br><span class="line">            flex-wrap: wrap;</span><br><span class="line">            list-style-type: none;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.img-item</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">flex</span>: 0 0 33<span class="selector-class">.3</span>%;</span></span><br><span class="line">            height: 100px;</span><br><span class="line">            background-color: aquamarine;</span><br><span class="line">            background-position: center;</span><br><span class="line">            background-repeat: no-repeat;</span><br><span class="line">            background-size: cover;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="selector-class">.img-item</span><span class="selector-pseudo">:nth-child(odd)</span> &#123;</span></span><br><span class="line">            background-color: chocolate;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">"tpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"img-group"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"img-item"</span> <span class="attr">v-for</span>=<span class="string">"img in imgs"</span> <span class="attr">v-img</span>=<span class="string">" img"</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">        el: <span class="string">'#app'</span>,</span></span><br><span class="line"><span class="javascript">        template: <span class="string">'#tpl'</span>,</span></span><br><span class="line">        data() &#123;</span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> &#123;</span></span><br><span class="line">                imgs: [</span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167593089/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167593090/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167593092/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167593093/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167593095/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167595616/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167595617/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167595618/0'</span>,</span></span><br><span class="line"><span class="javascript">                    <span class="string">'http://inews.gtimg.com/newsapp_match/0/9167595619/0'</span></span></span><br><span class="line">                ],</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;,</span><br><span class="line">        directives: &#123;</span><br><span class="line">            img: &#123;</span><br><span class="line">                bind(el, binding) &#123;</span><br><span class="line"><span class="javascript">                    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="keyword">const</span> img = <span class="built_in">document</span>.createElement(<span class="string">'img'</span>);</span></span><br><span class="line"><span class="javascript">                        img.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                            el.style.backgroundImage = <span class="string">`url(<span class="subst">$&#123;binding.value&#125;</span>)`</span>;</span></span><br><span class="line">                        &#125;;</span><br><span class="line"><span class="javascript">                        img.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                            <span class="built_in">console</span>.debug(<span class="string">'图片加载失败:'</span>, img.src);</span></span><br><span class="line">                        &#125;;</span><br><span class="line">                        img.src = binding.value;</span><br><span class="line">                    &#125;, 0);</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="五、图片优化"><a href="#五、图片优化" class="headerlink" title="五、图片优化"></a>五、图片优化</h3><p>如果是前端资源图片的话，还可以做图片做一些其他优化：</p>
<ul>
<li>压缩图片，降低图片大小 （<a href="https://zhitu.isux.us/" target="_blank" rel="noopener">智图：一个图片优化平台</a>）</li>
<li>响应式请求图片资源（高清屏请求 @2x 图片 ， 一般屏幕 请求 @x 图片，控制图片尺寸，从而缩减图片大小）</li>
<li>减少图片 http 请求次数（雪碧图）</li>
<li>利用字体库代替图标 （canvas 、svg 绘图替代图标）</li>
</ul>
<p>具体细节说明可以参考： <a href="https://juejin.im/post/59a7725b6fb9a02497170459" target="_blank" rel="noopener">web前端优化之图片优化</a> </p>
]]></content>
      <categories>
        <category>前端方案</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器的回流和重绘</title>
    <url>/2019/06/17/2019-2/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/</url>
    <content><![CDATA[<h3 id="一、浏览器渲染"><a href="#一、浏览器渲染" class="headerlink" title="一、浏览器渲染"></a>一、浏览器渲染</h3><p>在了解浏览器的回流和重绘之前，我们先来了解下浏览器的渲染过程。该图来源于<a href="https://segmentfault.com/a/1190000017329980" target="_blank" rel="noopener">你真的了解回流和重绘吗</a></p>
<p><img src="https://image-static.segmentfault.com/408/885/4088852130-5afbe6c95934b_articlex" alt></p>
<p><img src="https://image-static.segmentfault.com/422/377/4223770356-5abdb235cdd7d_articlex" alt></p>
<p>简化图如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">HTML--&gt;DOM</span><br><span class="line">CSS--&gt;CSSOM</span><br><span class="line">DOM--&gt;RenderTree</span><br><span class="line">CSSOM--&gt;RenderTree</span><br><span class="line">RenderTree--&gt;paint</span><br></pre></td></tr></table></figure>
<p>从上面的图中，我们可以看到，整个浏览器的渲染过程有：</p>
<ol>
<li>浏览器会把 <code>HTML</code> 解析成 <code>DOM</code>，把 <code>CSS</code> 解析成 <code>CSSOM</code>。</li>
<li><code>DOM</code> 和 <code>CSSOM</code> 合并就产生了 <code>Render Tree</code>。</li>
<li>浏览器依据 <code>Render Tree</code> 就能获取所有节点的样式，计算各节点元素在页面上的大小和位置，并将其绘制到页面上。</li>
</ol>
<blockquote>
<p><strong>补充说明：</strong></p>
<ul>
<li>浏览器使用流式布局模型 (Flow Based Layout)，因此只需要对 <code>Render Tree</code> 计算遍历一次就可以。（<code>table</code> 及其内部元素除外，它们可能需要多次计算，通常要花同等元素的3倍时间）</li>
<li><code>Render Tree</code> 不包含隐藏的节点。（例如 <code>display: none;</code> 的节点，还有 <code>head</code>、<code>script</code>、<code>meta</code>、<code>link</code> 节点）</li>
<li>Display: 将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，此处不再展开）</li>
</ul>
</blockquote>
<h3 id="二、回流"><a href="#二、回流" class="headerlink" title="二、回流"></a>二、回流</h3><p>当 <code>Render Tree</code> 中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。（即构建渲染树，计算变化节点在设备视口 viewport 内的确切位置的计算阶段）</p>
<h4 id="导致回流的操作："><a href="#导致回流的操作：" class="headerlink" title="导致回流的操作："></a>导致回流的操作：</h4><ul>
<li>页面首次渲染（<code>Render Tree</code> 构建）</li>
<li>浏览器窗口大小发生改变</li>
<li>增加或移除样式表</li>
<li>元素尺寸或位置发生改变</li>
<li>元素内容变化（文字数量或图片大小等等）</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的DOM元素</li>
<li>激活CSS伪类（例如：:hover）</li>
<li>查询某些属性或调用某些方法</li>
</ul>
<h4 id="浏览器的优化机制："><a href="#浏览器的优化机制：" class="headerlink" title="浏览器的优化机制："></a>浏览器的优化机制：</h4><p>由于每次重排都会造成额外的计算消耗，因此现代的大多数浏览器会通过队列化修改并批量执行来优化重排的过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>，比如当你访问以下属性或者使用以下方法：</p>
<ul>
<li>clientWidth、clientHeight、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>width、height</li>
<li>getComputedStyle()</li>
<li>getBoundingClientRect()</li>
</ul>
<p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列</strong>。如果要使用它们，最好将值缓存起来。</p>
<h3 id="三、重绘"><a href="#三、重绘" class="headerlink" title="三、重绘"></a>三、重绘</h3><p>当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<code>color</code>、<code>background-color</code>、<code>visibility</code> 等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>
<blockquote>
<p><strong>注意：</strong> 回流必将引起重绘，而重绘不一定会引起回流。</p>
</blockquote>
<h3 id="四、如何减少性能影响"><a href="#四、如何减少性能影响" class="headerlink" title="四、如何减少性能影响"></a>四、如何减少性能影响</h3><p>通过减少回流和重绘，能减少程序对于浏览器的性能的压力。</p>
<h4 id="css"><a href="#css" class="headerlink" title="css"></a>css</h4><ul>
<li>避免使用 <code>table</code> 布局。</li>
<li>尽可能在 <code>DOM</code> 树的最末端改变 <code>class</code>。（减少不必要的影响）</li>
<li>避免设置多层内联样式。</li>
<li>将动画效果应用到 <code>position</code> 属性为 <code>absolute</code> 或 <code>fixed</code> 的元素上。</li>
<li>避免使用 <code>CSS</code> 表达式（例如：<code>calc()</code>）。</li>
</ul>
<h4 id="javascript"><a href="#javascript" class="headerlink" title="javascript"></a>javascript</h4><ul>
<li>避免频繁操作样式，最好一次性重写 <code>style</code>属性，或者将样式列表定义为 <code>class</code> 并一次性更改 <code>class</code> 属性。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line">el.style.padding = <span class="string">'5px'</span>;</span><br><span class="line">el.style.height = <span class="string">'100px'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">el.style.cssText += <span class="string">'padding: 5px; height: 100px;'</span>;</span><br><span class="line"></span><br><span class="line">el.className += <span class="string">' active'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>DOM</code> 元素“离线处理”：</strong> 避免频繁操作 <code>DOM</code>，创建一个 <code>documentFragment</code>，在它上面应用所有 <code>DOM</code> 操作，最后再把它添加到文档中。也可以先为元素设置 <code>display: none;</code>，操作结束后再把它显示出来。因为在 <code>display</code> 属性为 <code>none</code>的元素上进行的 <code>DOM</code> 操作不会引发回流和重绘。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* DocumentFragment 文档片段缓存操作 回流一次 */</span></span><br><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line"><span class="comment">// todo ...</span></span><br><span class="line">el.appendChild(fragment); <span class="comment">// 回流</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* cloneNode(true or false) &amp; replaceChild 回流一次 */</span></span><br><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">div.style.width = <span class="string">'100px'</span>;</span><br><span class="line"><span class="comment">// todo ...</span></span><br><span class="line">el.parentNode.replaceChild(div, el); <span class="comment">// 回流</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* display: none; 回流两次 */</span></span><br><span class="line">el.style.display = <span class="string">'none'</span>; <span class="comment">// 回流</span></span><br><span class="line">el.style.width = <span class="string">'100px'</span>;</span><br><span class="line"><span class="comment">// todo ...</span></span><br><span class="line">el.sty;e.display = <span class="string">'block'</span>; <span class="comment">// 回流</span></span><br></pre></td></tr></table></figure>
<ul>
<li>避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。</li>
<li>对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li>
</ul>
<h3 id="五、参考文章"><a href="#五、参考文章" class="headerlink" title="五、参考文章"></a>五、参考文章</h3><ul>
<li><a href="https://juejin.im/post/5a9923e9518825558251c96a" target="_blank" rel="noopener">浏览器的回流与重绘 (Reflow &amp; Repaint)</a></li>
<li><a href="https://www.zhangxinxu.com/wordpress/2010/01/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98%EF%BC%9Acss%E6%80%A7%E8%83%BD%E8%AE%A9javascript%E5%8F%98%E6%85%A2%EF%BC%9F/" target="_blank" rel="noopener">回流与重绘：CSS性能让JavaScript变慢？</a></li>
<li><a href="https://www.html.cn/archives/4996" target="_blank" rel="noopener">页面重绘和回流以及优化</a></li>
<li><a href="https://segmentfault.com/a/1190000017329980" target="_blank" rel="noopener">你真的了解回流和重绘吗</a></li>
</ul>
]]></content>
      <categories>
        <category>基础原理</category>
      </categories>
      <tags>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title>set和map</title>
    <url>/2019/04/25/es6/set%E5%92%8Cmap/</url>
    <content><![CDATA[<blockquote>
<p>请介绍 Set \ Map 之间的区别？</p>
</blockquote>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>JS 中的对象（<code>Object</code>），本质是键值对的集合（Hash结构），传统上只能使用字符串作为键值（限制）。为了解决对象的这种限制，<code>ES6</code> 提供了 <code>Map</code> 数据结构。<br><code>Map</code> 类似于对象，也是键值对的集合，但是“键”不再仅限于字符串，包括各种类型的值（包括对象）都能作为 <code>Map</code> 的键。简单来说就是，<code>Object</code> 是 <strong>字符串 - 值</strong>，而 <code>Map</code> 是 <strong>值 - 值</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;&#125;;</span><br><span class="line">object[<span class="literal">false</span>] = <span class="number">1</span>; <span class="comment">// object['false']</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">    [<span class="string">'true'</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="literal">true</span>, <span class="number">2</span>]</span><br><span class="line">]);</span><br><span class="line">map.size <span class="comment">// 2</span></span><br><span class="line">map.has(<span class="string">'true'</span>) <span class="comment">// true</span></span><br><span class="line">map.get(<span class="string">'true'</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="相关讨论："><a href="#相关讨论：" class="headerlink" title="相关讨论："></a>相关讨论：</h3><ul>
<li><h3 id="相关阅读："><a href="#相关阅读：" class="headerlink" title="相关阅读："></a>相关阅读：</h3></li>
<li><p><a href></a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>每日一题</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-06-17</title>
    <url>/2020/06/17/fe-daily/2020-06-17/</url>
    <content><![CDATA[<h2 id="每日学习一点小知识："><a href="#每日学习一点小知识：" class="headerlink" title="每日学习一点小知识："></a>每日学习一点小知识：</h2><ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/2524" target="_blank" rel="noopener">websocket是如何做心跳检测、数据加密、身份验证的？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/2525" target="_blank" rel="noopener">使用css如何设置背景虚化？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/2526" target="_blank" rel="noopener">js源代码压缩都有哪些方法？它们的压缩原理分别是什么？</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/2527" target="_blank" rel="noopener">对于用户的隐私你是如何看待的？</a></li>
</ul>
<a id="more"></a>
<h2 id="使用-css3-实现背景虚化"><a href="#使用-css3-实现背景虚化" class="headerlink" title="使用 css3 实现背景虚化"></a>使用 css3 实现背景虚化</h2><p>假设现在存在这样一个场景：产品需要你将某一宣传页面背景图片虚化，但是宣传内容不能受影响，如何处理？</p>
<p>对应的页面结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span> <span class="attr">class</span>=<span class="string">"p-header"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"hd-content"</span>&gt;</span>这是我的相关内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.p-header</span> &#123;</span><br><span class="line">	<span class="attribute">background</span>: <span class="built_in">url</span>(./test.jpg) center/cover no-repeat;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.hd-content</span> &#123;</span><br><span class="line">	<span class="attribute">padding</span>: <span class="number">20px</span>;</span><br><span class="line">	<span class="attribute">line-height</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="实现方式："><a href="#实现方式：" class="headerlink" title="实现方式："></a>实现方式：</h3><ul>
<li>利用 CSS3 blur 滤镜 <code>filter: blur(1px);</code></li>
<li>利用 SVG 滤镜</li>
<li>利用 canvas 进行图片转换</li>
</ul>
<blockquote>
<p>参考文章：</p>
<ul>
<li><a href="https://www.zhangxinxu.com/wordpress/2013/11/css-svg-image-blur/" target="_blank" rel="noopener">小tip: 使用CSS将图片转换成模糊(毛玻璃)效果</a></li>
<li><a href="https://juejin.im/post/5bcc0367e51d453c4655e83c" target="_blank" rel="noopener">CSS设置背景模糊</a></li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>每日学习</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
        <tag>js</tag>
        <tag>软技能</tag>
      </tags>
  </entry>
  <entry>
    <title>2020-06-16</title>
    <url>/2020/06/16/fe-daily/2020-06-16/</url>
    <content><![CDATA[<h2 id="每日学习一点小知识："><a href="#每日学习一点小知识：" class="headerlink" title="每日学习一点小知识："></a>每日学习一点小知识：</h2><ul>
<li>[html] <a href="https://github.com/haizlin/fe-interview/issues/2520" target="_blank" rel="noopener">http 和 websocket 能共用一个端口吗？为什么？</a></li>
<li>[css] <a href="https://github.com/haizlin/fe-interview/issues/2521" target="_blank" rel="noopener">举例说明background-repeat的新属性值：round和space的作用是什么？</a></li>
<li>[js] <a href="https://github.com/haizlin/fe-interview/issues/2522" target="_blank" rel="noopener">不用 + eval Function 实现加法</a></li>
<li>[软技能] <a href="https://github.com/haizlin/fe-interview/issues/2523" target="_blank" rel="noopener">让你去重构一个很老旧但很重要的系统，你的方法论是什么？</a></li>
</ul>
<a id="more"></a>
<h2 id="http-和-websocket-能共用一个端口吗？为什么？"><a href="#http-和-websocket-能共用一个端口吗？为什么？" class="headerlink" title="http 和 websocket 能共用一个端口吗？为什么？"></a>http 和 websocket 能共用一个端口吗？为什么？</h2><p>先说结论，<strong>YES！</strong> http 可以和 WebSocket 共用同一个端口。</p>
<p>http 和 WebSocket 都是应用层的协议。而端口是写在传输层协议上的，无论是 http 还是 WebSocket 都是基于 TCP 协议的。具体一点的话，可以理解为当客户端和服务器通信时会通过双方的 IP 和端口形成一条通信管道（抽象就是双方按照给定地址发送信息包给对方），在这条通信管道中会根据需要创建 N 个 TCP 连接，这些连接有的是用 http 协议，有的是用 WebSocket。</p>
<p><strong>使用 Node.js 实现 http 和 WebSocket 共用同一个端口：</strong></p>
<h2 id="举例说明background-repeat的新属性值：round和space的作用是什么？"><a href="#举例说明background-repeat的新属性值：round和space的作用是什么？" class="headerlink" title="举例说明background-repeat的新属性值：round和space的作用是什么？"></a>举例说明background-repeat的新属性值：round和space的作用是什么？</h2><h2 id="不用-eval-Function-实现加法"><a href="#不用-eval-Function-实现加法" class="headerlink" title="不用 + eval Function 实现加法"></a>不用 + eval Function 实现加法</h2><h2 id="让你去重构一个很老旧但很重要的系统，你的方法论是什么？"><a href="#让你去重构一个很老旧但很重要的系统，你的方法论是什么？" class="headerlink" title="让你去重构一个很老旧但很重要的系统，你的方法论是什么？"></a>让你去重构一个很老旧但很重要的系统，你的方法论是什么？</h2>]]></content>
      <categories>
        <category>每日学习</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
        <tag>js</tag>
        <tag>软技能</tag>
      </tags>
  </entry>
  <entry>
    <title>前端·学习笔记</title>
    <url>/2020/12/18/fe/%E5%89%8D%E7%AB%AF%C2%B7%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>学习记录未知的事物，努力扩大自己的小圈子。（学而时习之，不亦说乎）</p>
</blockquote>
<a id="more"></a>
<!-- toc -->
<h2 id="常用小技巧"><a href="#常用小技巧" class="headerlink" title="常用小技巧"></a>常用小技巧</h2><ul>
<li><p><a href="https://zhuanlan.zhihu.com/p/304360774?utm_source=com.facishare.fsneice&amp;utm_medium=social&amp;utm_oi=46648013094912" target="_blank" rel="noopener">写 JS 逻辑判断，不要只知道用 if-else 和 switch - 知乎</a></p>
<blockquote>
<p><strong>小结：</strong> 可以利用键值对（object / map）处理复杂的逻辑判断，便于后续维护。【多重判断时，Map 比 Object 更加适合处理】</p>
</blockquote>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不同身份、不同状态处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">identity, status</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> actions = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">            [<span class="regexp">/^guest_[1-4]$/</span>, () =&gt; &#123;<span class="built_in">console</span>.log(<span class="string">'操作1'</span>)&#125;],</span><br><span class="line">            [<span class="regexp">/^guest_.*$/</span>, () =&gt; &#123;<span class="built_in">console</span>.log(<span class="string">'操作2'</span>)&#125;],</span><br><span class="line">            [<span class="regexp">/^master_[2-3]$/</span>, () =&gt; &#123;<span class="built_in">console</span>.log(<span class="string">'操作3'</span>)&#125;],</span><br><span class="line">            [<span class="regexp">/^master_.*$/</span>, () =&gt; &#123;<span class="built_in">console</span>.log(<span class="string">'操作4'</span>)&#125;],</span><br><span class="line">        ]);</span><br><span class="line">    &#125;)();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> curRule = <span class="string">`<span class="subst">$&#123;identity&#125;</span>_<span class="subst">$&#123;status&#125;</span>`</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> [rule, action] <span class="keyword">of</span> actions.entries()) &#123;</span><br><span class="line">        <span class="comment">// 优先匹配原则</span></span><br><span class="line">        <span class="keyword">if</span> (rule.test(curRule)) &#123;</span><br><span class="line">            action.call(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>等待更多… ^ ^</p>
</li>
</ul>
<h2 id="对比思考"><a href="#对比思考" class="headerlink" title="对比思考"></a>对比思考</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/337296578" target="_blank" rel="noopener">继承 vs 组合：哪一个更适合你的 JavaScript 项目 - 知乎</a><ul>
<li>小结： <ul>
<li>继承：子类借用父类除私有属性方法外的所有公共和受保护的属性和方法。（JavaScript 中，子对象常借用父对象的构造函数（自身新属性）和原型链上的方法）  </li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>每日一学</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.extend()和extends选项</title>
    <url>/2021/02/01/vue/extend/</url>
    <content><![CDATA[<p>Vue.extend() 使用基础 Vue 构造器，创建一个“子类”。参数是一个包含组件选项的对象。其中 data 属性必须是一个函数（这样每个组件的实例的 data 才能是独立的）。</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Demo = Vue.extend(&#123;</span><br><span class="line">    template: <span class="string">'&lt;p&gt;&#123;&#123;text&#125;&#125;&lt;/p&gt;'</span>,</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            text: <span class="string">'你好'</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>extends 选项允许声明扩展另一个组件 (可以是一个简单的选项对象或构造函数)，而无需使用 Vue.extend。这主要是为了便于扩展单文件组件。其功能类似 mixins</p>
<p>例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> CompA = &#123; ... &#125;</span><br><span class="line"><span class="comment">// 在没有调用 `Vue.extend` 时候继承 CompA</span></span><br><span class="line"><span class="keyword">var</span> CompB = &#123;</span><br><span class="line">  extends: CompA,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个简易的 MVVM 双向数据绑定</title>
    <url>/2019/07/01/2019-2/%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AAMVVM/</url>
    <content><![CDATA[<p>如果你想了解 MVVM 双向数据绑定，那你之前最好有 Angular.js/React.js/Vue.js 等工具库的使用经验，便于理解。</p>
<a id="more"></a>
<h3 id="一、实现思路"><a href="#一、实现思路" class="headerlink" title="一、实现思路"></a>一、实现思路</h3><p>要实现一个 mvvm 双向数据绑定，我们需要实现以下几点：</p>
<ul>
<li>实现一个数据监听器 <code>Observer</code>，能够对数据对象的所有属性进行监听，当数据变更时能通过发布者通知所有订阅者。</li>
<li>实现一个指令和模板的解析器 <code>Compile</code>，能对各个元素节点进行扫描解析，将对应的数据模板替换成对应的数据，并且更新到视图上。</li>
<li>利用订阅者 <code>Watcher</code> 连接 <code>Observer</code> 和 <code>Compile</code>，使得监听数据变更时，视图能变化。视图绑定数据变化时，数据对象也能进行相应的变化。</li>
<li>提供一个 MVVM 函数，支持以上三个能力。</li>
</ul>
<p>流程示意图：</p>
<p><img src="/images/mvvm.png" alt></p>
<h3 id="二、具体实现"><a href="#二、具体实现" class="headerlink" title="二、具体实现"></a>二、具体实现</h3><h4 id="1-实现数据监听-Observer"><a href="#1-实现数据监听-Observer" class="headerlink" title="1. 实现数据监听 Observer"></a>1. 实现数据监听 <code>Observer</code></h4><p>利用 <code>Object.defineProperty</code> 拦截 <code>data</code> 数据变化。</p>
<p><strong>监听者 observer.js</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(data) &#123;</span><br><span class="line">        <span class="keyword">this</span>.observer(data);</span><br><span class="line">    &#125;</span><br><span class="line">    observer(data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!data || <span class="keyword">typeof</span> data !== <span class="string">'object'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="keyword">this</span>.defineReactive(data, key, data[key]);</span><br><span class="line">            <span class="comment">// 深度递归</span></span><br><span class="line">            <span class="keyword">this</span>.observer(data[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义响应式操作，此处的 value 不可省略，否则直接 get data[key] 会陷入死循环</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param  <span class="type">&#123;Object&#125;</span> </span>data 需要进行数据劫持的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param  <span class="type">&#123;String&#125;</span> </span>key  需要进行数据劫持的属性</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    defineReactive(data, key, value) &#123;</span><br><span class="line">        <span class="comment">// 订阅所有变更</span></span><br><span class="line">        <span class="keyword">const</span> dep = <span class="keyword">new</span> Dependence();</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">            <span class="comment">// 可删除</span></span><br><span class="line">            configurable: <span class="literal">true</span>,</span><br><span class="line">            <span class="comment">// 可枚举</span></span><br><span class="line">            enumerable: <span class="literal">true</span>,</span><br><span class="line">            <span class="keyword">set</span>: (newVal) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (newVal !== value) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.observer(newVal);<span class="comment">// 避免新值变更为 object 后没有监听</span></span><br><span class="line">                    value = newVal;</span><br><span class="line">                    <span class="comment">// 通知所有订阅者</span></span><br><span class="line">                    dep.notify();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>发布者 dependence.js</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dependence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="comment">// 订阅者列表</span></span><br><span class="line">        <span class="keyword">this</span>.subs = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    addSub(sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.add(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    removeSub(sub) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.delete(sub);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知所有订阅者</span></span><br><span class="line">    notify() &#123;</span><br><span class="line">        <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">            sub.update();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每当 <code>data</code> 数据发生变更时，<code>setter</code> 拦截器都会通知发布者，从而通知所有相关的订阅者。</p>
<h4 id="2-实现DOM编译-Compile"><a href="#2-实现DOM编译-Compile" class="headerlink" title="2. 实现DOM编译 Compile"></a>2. 实现DOM编译 <code>Compile</code></h4><p><code>Compile</code> 主要负责模板的解析和初始化页面视图。</p>
<p>由于在解析过程涉及到多次dom元素的操作，为了避免引起页面的多次回流，我们可以利用 <code>fragment</code> 文档片段进行处理，处理结束后再将 <code>fragment</code> 插入原来的节点中。</p>
<p><strong>编译者 compiler.js</strong><br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compile</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(el, vm) &#123;</span><br><span class="line">        <span class="keyword">this</span>.el = <span class="keyword">this</span>.getElementNode(el);</span><br><span class="line">        <span class="keyword">this</span>.vm = vm;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.el) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.render();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * core方法</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    render() &#123;</span><br><span class="line">        <span class="comment">// 1、把这些真实的 Dom 移动到内存中，即 fragment（文档碎片）</span></span><br><span class="line">        <span class="keyword">const</span> fragment = <span class="keyword">this</span>.node2fragment(<span class="keyword">this</span>.el);</span><br><span class="line">        <span class="comment">// 2、将模板中的指令中的变量和 &#123;&#123;&#125;&#125; 中的变量替换成真实的数据</span></span><br><span class="line">        <span class="keyword">this</span>.compile(fragment);</span><br><span class="line">        <span class="comment">// 3、把编译好的 fragment 再塞回页面中</span></span><br><span class="line">        <span class="keyword">this</span>.el.appendChild(fragment);</span><br><span class="line">    &#125;</span><br><span class="line">    node2fragment(el) &#123;</span><br><span class="line">        <span class="comment">// 创建文档碎片</span></span><br><span class="line">        <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">        <span class="comment">// 第一个子节点</span></span><br><span class="line">        <span class="keyword">let</span> firstChild;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环取出根节点中的节点并放入文档碎片中，此时该节点脱离DOM树</span></span><br><span class="line">        <span class="keyword">while</span> (firstChild = el.firstChild) &#123;</span><br><span class="line">            fragment.appendChild(firstChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fragment;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析文档碎片</span></span><br><span class="line">    compile(fragment) &#123;</span><br><span class="line">        <span class="comment">// 获取当前节点的所有子节点，包括文本节点</span></span><br><span class="line">        <span class="keyword">const</span> childNodes = <span class="built_in">Array</span>.from(fragment.childNodes);</span><br><span class="line"></span><br><span class="line">        childNodes.forEach(<span class="function"><span class="params">node</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isElementNode(node)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.compile(node);</span><br><span class="line">                <span class="keyword">this</span>.compileElement(node);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.compileText(node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    compileElement(node) &#123;</span><br><span class="line">        <span class="comment">// 获取当前节点的属性</span></span><br><span class="line">        <span class="keyword">const</span> attrs = <span class="built_in">Array</span>.from(node.attributes);</span><br><span class="line"></span><br><span class="line">        attrs.forEach(<span class="function"><span class="params">attr</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// 判断该元素属性是否为指令</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.isDirective(attr.name)) &#123;</span><br><span class="line">                <span class="comment">// 获取指令对应表达式</span></span><br><span class="line">                <span class="keyword">let</span> exp = attr.value;</span><br><span class="line">                <span class="keyword">let</span> [, type] = attr.name.split(<span class="string">'-'</span>);</span><br><span class="line">                type = <span class="string">`<span class="subst">$&#123;type&#125;</span>Handle`</span>;</span><br><span class="line">                <span class="keyword">this</span>[type] &amp;&amp; <span class="keyword">this</span>[type](node, <span class="keyword">this</span>.vm, exp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    compileText(node) &#123;</span><br><span class="line">        <span class="keyword">let</span> exp = node.textContent;</span><br><span class="line">        <span class="keyword">let</span> reg = <span class="regexp">/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g</span>;</span><br><span class="line">        <span class="comment">// 将文本的编译视作默认指令 v-text</span></span><br><span class="line">        <span class="keyword">if</span> (reg.test(exp)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.textHandle(node, <span class="keyword">this</span>.vm, exp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * 辅助方法</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    isElementNode(node) &#123;</span><br><span class="line">        <span class="keyword">return</span> node.nodeType === <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    getElementNode(el) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.isElementNode(el) ?</span><br><span class="line">            el :</span><br><span class="line">            <span class="built_in">document</span>.querySelector(el);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断属性是否为指令</span></span><br><span class="line">    isDirective(name) &#123;</span><br><span class="line">        <span class="keyword">return</span> name.includes(<span class="string">'v-'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     * 指令处理</span></span><br><span class="line"><span class="comment">     * ------------------------------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    modelHandle(node, vm, exp) &#123; <span class="comment">// 输入框处理</span></span><br><span class="line">        <span class="keyword">const</span> updateFn = <span class="function">(<span class="params">node, value</span>) =&gt;</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 这里应该加一个监控，数据变化了应该调用这个watch的callbak</span></span><br><span class="line">        <span class="keyword">new</span> Watcher(vm, exp, (newVal, oldVal) =&gt; &#123;</span><br><span class="line">            <span class="comment">// 当值变化后会调用callback将新值传递过来()</span></span><br><span class="line">            updateFn(node, utils.getVal(vm, exp));</span><br><span class="line">        &#125;);</span><br><span class="line">        node.addEventListener(<span class="string">'input'</span>, (e) =&gt; &#123;</span><br><span class="line">            <span class="keyword">let</span> newValue = e.target.value;</span><br><span class="line">            utils.setVal(vm, exp, newValue);</span><br><span class="line">        &#125;);</span><br><span class="line">        updateFn(node, utils.getVal(vm, exp));</span><br><span class="line">    &#125;</span><br><span class="line">    textHandle(node, vm, exp) &#123;</span><br><span class="line">        <span class="keyword">let</span> updateFn = <span class="function">(<span class="params">node, value</span>) =&gt;</span> &#123;</span><br><span class="line">            node.textContent = value;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">let</span> value = utils.getTextVal(vm, exp);</span><br><span class="line"></span><br><span class="line">        exp.replace(<span class="regexp">/\&#123;\&#123;([^&#125;]+)\&#125;\&#125;/g</span>, (...arg) =&gt; &#123;</span><br><span class="line">            <span class="keyword">new</span> Watcher(vm, arg[<span class="number">1</span>], (newVal, oldVal) =&gt; &#123;</span><br><span class="line">                <span class="comment">// 如果数据变化了，文本节点需要重新获取依赖的数据，更新文本中的内容</span></span><br><span class="line">                updateFn(node, utils.getTextVal(vm, exp));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;)</span><br><span class="line">        updateFn(node, value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-实现依赖收集-Watcher"><a href="#3-实现依赖收集-Watcher" class="headerlink" title="3. 实现依赖收集 Watcher"></a>3. 实现依赖收集 <code>Watcher</code></h4><blockquote>
<p><strong>依赖收集：</strong></p>
<p>新增订阅者时，将当前订阅者赋值给一个全局变量，之后触发相关联的数据的 <code>getter</code>，<code>getter</code> 就能将全局变量中包含的订阅者添加到相关的订阅者列表中。</p>
</blockquote>
<blockquote>
<p><strong>连接 <code>Observer</code> 和 <code>Compile</code>：</strong></p>
<p>当 <code>Compile</code> 解析指令或数据模板时，发现有效指令或数据模板时，可新增一个订阅者相应的变化，并在回调中做出对应的处理。</p>
</blockquote>
<p><strong>订阅者 watcher.js</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">	<span class="keyword">constructor</span>(vm, exp, callback) &#123;</span><br><span class="line">		<span class="keyword">this</span>.vm = vm;</span><br><span class="line">		<span class="keyword">this</span>.exp = exp;</span><br><span class="line">		<span class="comment">// 存储生成编译结果的函数</span></span><br><span class="line">		<span class="keyword">this</span>.callback = callback;</span><br><span class="line">		<span class="comment">// 存储当前编译结果</span></span><br><span class="line">		<span class="keyword">this</span>.value = <span class="keyword">this</span>.get();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">get</span>() &#123;</span><br><span class="line">		<span class="comment">// 通过触发该数据的getter函数，将watch添加到dep中</span></span><br><span class="line">		Dependence.target = <span class="keyword">this</span>;</span><br><span class="line">		<span class="keyword">const</span> value = utils.getVal(<span class="keyword">this</span>.vm, <span class="keyword">this</span>.exp);</span><br><span class="line">		Dependence.target = <span class="literal">null</span>;</span><br><span class="line">		<span class="keyword">return</span> value;</span><br><span class="line">	&#125;</span><br><span class="line">	update() &#123;</span><br><span class="line">		<span class="keyword">const</span> newVal = <span class="keyword">this</span>.get();</span><br><span class="line">		<span class="keyword">const</span> oldVal = <span class="keyword">this</span>.value;</span><br><span class="line">		<span class="keyword">if</span> (oldVal !== newVal) &#123;</span><br><span class="line">			<span class="keyword">this</span>.value = newVal;</span><br><span class="line">			<span class="keyword">this</span>.callback &amp;&amp; <span class="keyword">this</span>.callback(newVal, oldVal)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>observer.js 新增</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    defineReactive(data, key, value) &#123;</span><br><span class="line">        <span class="comment">// 订阅所有变更</span></span><br><span class="line">        <span class="keyword">const</span> dep = <span class="keyword">new</span> Dependence();</span><br><span class="line">        <span class="built_in">Object</span>.defineProperty(data, key, &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">get</span>: () =&gt; &#123;</span><br><span class="line">                <span class="comment">// 利用全局变量新增相关订阅者</span></span><br><span class="line">            	Dependence.target &amp;&amp; dep.addSub(Dependence.target);</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-提供入口构造函数-MVVM"><a href="#4-提供入口构造函数-MVVM" class="headerlink" title="4. 提供入口构造函数 MVVM"></a>4. 提供入口构造函数 <code>MVVM</code></h4><p>mvvm.js<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MVVM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">        <span class="keyword">this</span>.$data = options.data();</span><br><span class="line">        <span class="comment">// 数据劫持</span></span><br><span class="line">        <span class="keyword">new</span> Observer(<span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="comment">// 数据代理</span></span><br><span class="line">        <span class="keyword">this</span>.proxyData(<span class="keyword">this</span>.$data);</span><br><span class="line">        <span class="comment">// 元素存在，则进行挂载</span></span><br><span class="line">        <span class="keyword">if</span> (options.el) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mount(options.el);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据代理，方便调用</span></span><br><span class="line"><span class="comment">     * 可通过修改 vm.test 间接修改 vm.$data.test 的值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param  <span class="type">&#123;Object&#125;</span> </span>data vm.$data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    proxyData(data) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> data) &#123;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">                <span class="keyword">get</span>() &#123;</span><br><span class="line">                    <span class="keyword">return</span> data[key]</span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="keyword">set</span>(newValue) &#123;</span><br><span class="line">                    data[key] = newValue;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 元素挂载，进行初始化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param  <span class="type">&#123;[type]&#125;</span> </span>el [description]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    mount(el) &#123;</span><br><span class="line">        <span class="keyword">new</span> Compile(el, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h3><p>相关源码地址：<a href="https://github.com/yiqingfeng/blog-code" target="_blank" rel="noopener">请访问</a></p>
<h4 id="参考阅读"><a href="#参考阅读" class="headerlink" title="参考阅读"></a>参考阅读</h4><ul>
<li><a href="https://github.com/DMQ/mvvm" target="_blank" rel="noopener">https://github.com/DMQ/mvvm</a></li>
</ul>
]]></content>
      <categories>
        <category>基础原理</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>VUE</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript学习笔记·2</title>
    <url>/2020/04/21/2020/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B72/</url>
    <content><![CDATA[<p>了解 TypeScript 并加以使用，可以帮助我们提高代码的质量。本文主要是对官方文档上的内容进行个人理解后的知识收集，想了解更详细内容，推荐 <a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener">TypeScript官网</a>。</p>
<blockquote>
<p><strong>tip:</strong> 在学习了解 TypeScript 的内容时，最好自己去实践一下。</p>
</blockquote>
<a id="more"></a>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>在软件程序开发设计中，为了提高程序有较好的可读性和健壮性，会将相似的逻辑进行集中统一处理，构建可复用的组件。同理在 TypeScript 中，我们可以利用 <code>泛型</code> 创建可重用的组件/数据类型等。</p>
<p>在 TypeScript 中，泛型支持：</p>
<ul>
<li>泛型函数</li>
<li>泛型接口</li>
<li>泛型类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface GenericIdentityFn&lt;T&gt; &#123;</span><br><span class="line">    (arg: T): T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function identity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line">let myIdentity: GenericIdentityFn&lt;number&gt; = identity;</span><br><span class="line">identity(1);</span><br><span class="line">identity(&apos;a&apos;);</span><br><span class="line">myIdentity(1);</span><br><span class="line">// myIdentity(&apos;a&apos;); // error!</span><br><span class="line"></span><br><span class="line">class GenericNumber&lt;T&gt; &#123;</span><br><span class="line">    zeroValue: T;</span><br><span class="line">    add: (x: T, y: T) =&gt; T;</span><br><span class="line">&#125;</span><br><span class="line">let myGenericNumber = new GenericNumber&lt;number&gt;();</span><br><span class="line">myGenericNumber.zeroValue = 1;</span><br><span class="line">// myGenericNumber.zeroValue = &apos;a&apos;; // error!</span><br></pre></td></tr></table></figure>
<h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><p>虽然在使用 <code>泛型</code> 中，如果我们知道要操作的数据具有那些属性，并希望进行相应操作的话，需要对类型变量 T 进行约束。这种情况下，可以通过定义一个接口来描述约束条件，并利用这个接口和 <code>extends</code> 关键字实现约束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function loggingIdentity&lt;T&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);  // Error: T doesn&apos;t have .length</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Lengthwise &#123;</span><br><span class="line">    length: number;</span><br><span class="line">&#125;</span><br><span class="line">function loggingIdentity2&lt;T extends Lengthwise&gt;(arg: T): T &#123;</span><br><span class="line">    console.log(arg.length);  // Now we know it has a .length property, so no more error</span><br><span class="line">    return arg;</span><br><span class="line">&#125;</span><br><span class="line">loggingIdentity(&#123;length: 10, value: 3&#125;); // ok</span><br><span class="line">loggingIdentity2(3); // error</span><br></pre></td></tr></table></figure>
<!--可以传入任意类型数据，但是如果操作了 `泛型` 类型变量的属性防范-->
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>声明的泛型类型参数，可以被另一个类型参数所约束，例如下面获取对象属性的实例中，key</li>
</ul>
</blockquote>
<p>待补充<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getProperty(obj: T, key: K) &#123;</span><br><span class="line">    return obj[key];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let x = &#123; a: 1, b: 2, c: 3, d: 4 &#125;;</span><br><span class="line"></span><br><span class="line">getProperty(x, &quot;a&quot;); // okay</span><br><span class="line">getProperty(x, &quot;m&quot;); // error: Argument of type &apos;m&apos; isn&apos;t assignable to &apos;a&apos; | &apos;b&apos; | &apos;c&apos; | &apos;d&apos;.</span><br></pre></td></tr></table></figure></p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>在编程过程中，为了便于代码阅读和后续维护。我们可以使用枚举清晰地表达意图，与其他内容加以区分。</p>
<p>TypeScript 支持数字和基于字符串的枚举。使用的时候可以通过访问枚举的属性/名字访问枚举成员。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 数字枚举</span><br><span class="line">enum Direction &#123;</span><br><span class="line">	Up = 1,</span><br><span class="line">	Down,		// 等价于 Down = 2</span><br><span class="line">	Left = 10,</span><br><span class="line">	Right,		// 等价于 Right = 11</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const test = 12;</span><br><span class="line">enum E &#123;</span><br><span class="line">	A = test,</span><br><span class="line">	B, // error: Enum member must have initializer. 即常量成员不允许紧随计算的成员</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 字符串枚举</span><br><span class="line">enum Direction &#123;</span><br><span class="line">    Up = &quot;UP&quot;,</span><br><span class="line">    Down = &quot;DOWN&quot;,</span><br><span class="line">    Left = &quot;LEFT&quot;,</span><br><span class="line">    Right = &quot;RIGHT&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>需要注意的是：</strong></p>
<ul>
<li>数字枚举中，第一个成员默认为 0。其中未赋值的成员相对于之前有值的成员 <strong>自增长</strong>。</li>
<li>如果在数字枚举中，利用计算的或者常量成员时，不允许不带初始化器的枚举（在正常的枚举里，没有初始化方法的成员被当成 <strong>常数成员</strong>）置于其后。</li>
<li>与数字枚举不同的是，字符串枚举没有 <strong>自增长行为</strong>。</li>
<li>在使用枚举的过程中，不建议使用 <strong>异构枚举</strong>（即混合数字和字符串的枚举）。</li>
<li>枚举不同于接口，枚举是在 <strong>运行时真正存在的对象</strong>。</li>
<li>在枚举中，除了可以通过枚举成员的名字去访问对应的枚举值，也能够通过枚举值 <strong>反向映射</strong> 到枚举名字。这是因为枚举类型会被编译成一个包含正向映射（name -&gt; value）和反向映射（value -&gt; name）的对象。</li>
<li>在枚举上使用 <code>const</code> 修饰符的话，可以声明 <strong>常量枚举</strong>。常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。 常量枚举成员在使用的地方会被内联进来。 之所以可以这么做是因为，常量枚举不允许包含计算成员。</li>
<li>多文件模块中，对于外部已经存在枚举，可以使用 <strong>外部枚举</strong> 用于描述已存在的枚举类型。</li>
</ul>
</blockquote>
<h3 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h3><p>在 TypeScript 中，对于没有明确指明类型的地方，类型推论会帮助提供类型。</p>
<p>在类型推论过程中，如果需要从表达式中推断类型，TypeScript 会使用这些表达式来推断出一个 <strong>最佳通用类型</strong>。除了表达式外，TypeScript类型推论也可能按照 <strong>上下文</strong> 进行推论。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let x = &apos;2&apos;; // x 被推断为字符串</span><br><span class="line">let y: string = x + 1; // OK！ x 为字符串，计算后的结果也是字符串</span><br><span class="line"></span><br><span class="line">let zoo = [new Rhino(), new Elephant(), new Snake()]; // zoo 没有找到最佳通用类型，被推断为联合数组类型 (Rhino | Elephant | Snake)[]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>备注：</p>
<p>此处的内容理解得不是很清楚，感觉就是在说 TypeScript 会推论没有声明数据类型的地方，然后进行数据类型校验。</p>
</blockquote>
<h3 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h3><p><strong>结构类型</strong> 是一种只使用其成员描述类型的方式。TypeScript 使用结构类型系统的方式来描述。</p>
<p>TypeScript结构化类型系统的基本规则是：</p>
<ul>
<li>如果 <code>x</code> 要兼容 <code>y</code>，那么 <code>y</code> 至少具有与 <code>x</code> 相同的属性。</li>
<li>当比较两个函数 <code>x</code> 和 <code>y</code> 时，首先会检查它们的参数列表，<code>x</code> 的每个参数必须能在 <code>y</code> 中找到对应类型的参数。（比较时只看类型不看参数名称，具体可看示例2）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Name &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let p: Name;</span><br><span class="line">p = new Person(); // ok</span><br><span class="line"></span><br><span class="line">let y = &#123; name: &apos;Alice&apos;, location: &apos;Seattle&apos; &#125;;</span><br><span class="line">p = y; // ok, 这个比较过程是递归进行的，检查每个成员及子成员</span><br></pre></td></tr></table></figure>
<p>示例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let x = (a: number) =&gt; 0;</span><br><span class="line">let y = (b: number, s: string) =&gt; 0;</span><br><span class="line"></span><br><span class="line">y = x; // OK</span><br><span class="line">x = y; // Error</span><br></pre></td></tr></table></figure>
<h3 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h3><p>常用的高级类型有：</p>
<ul>
<li>交叉类型</li>
<li>联合类型</li>
<li>枚举类型</li>
<li><code>this</code>类型（在接口、类中，声明 <code>this</code> 返回，可用于链式调用场景）</li>
<li>索引类型</li>
</ul>
<h4 id="交叉类型"><a href="#交叉类型" class="headerlink" title="交叉类型"></a>交叉类型</h4><p>在 TypeScript 中，交叉类型用于将多个类型合并为一个类型，使其包含所有类型的特性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 交叉类型</span><br><span class="line">function extend&lt;T, U&gt;(first: T, second: U): T &amp; U &#123;</span><br><span class="line">    let result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">    for (let id in first) &#123;</span><br><span class="line">        (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    for (let id in second) &#123;</span><br><span class="line">        if (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">            (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">    constructor(public name: string) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">interface Loggable &#123;</span><br><span class="line">    log(): void;</span><br><span class="line">&#125;</span><br><span class="line">class ConsoleLogger implements Loggable &#123;</span><br><span class="line">    log() &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var jim = extend(new Person(&quot;Jim&quot;), new ConsoleLogger());</span><br><span class="line">console.log(jim.name);</span><br><span class="line">jim.log();</span><br></pre></td></tr></table></figure>
<h4 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h4><p>联合类型在使用上不同于交叉类型，其常用于表示一个值可以是多种类型之一。使用 <code>|</code> 分隔每个类型。如果一个值是联合类型，访问时只能访问此联合类型中所有类型的共有成员。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UnionType &#123;</span><br><span class="line">	constructor (public type: string | number) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">let ut: UnionType;</span><br><span class="line">ut = new UnionType(&apos;hello&apos;);</span><br><span class="line">ut.type.slice(1); // error</span><br><span class="line"></span><br><span class="line">(&lt;string&gt;ut.type).slice(1);</span><br><span class="line"></span><br><span class="line">function isString (type: string | number): type is string &#123;</span><br><span class="line">	return (&lt;string&gt; type).slice !== undefined;</span><br><span class="line">&#125;</span><br><span class="line">if (isString(ut.type)) &#123;</span><br><span class="line">	ut.type.slice(1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (typeof ut.type === &apos;string&apos;) &#123;</span><br><span class="line">	ut.type.slice(1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于在联合类型中，希望访问该类型特有的成员，可以使用一下几种方法：</p>
<ul>
<li>如果明确知道了联合类型的具体类型，可以使用类型断言。</li>
<li>可以使用类型谓词，谓词为 <code>parameterName is Type</code> 这种形式， <code>parameterName</code> 必须是来自于当前函数签名里的一个参数名。</li>
<li><code>typeof</code> 类型保护：在 TypeScript 中，<code>typeof</code> 能被识别为一个类型保护。只有两种形式能被识别：<code>typeof v === &quot;typename&quot;</code> 和 <code>typeof v !== &quot;typename&quot;</code>， <code>&quot;typename&quot;</code> 必须是 <code>&quot;number&quot;</code>， <code>&quot;string&quot;</code>， <code>&quot;boolean&quot;</code> 或 <code>&quot;symbol&quot;</code>。 但是TypeScript并不会阻止你与其它字符串比较，语言不会把那些表达式识别为类型保护。</li>
<li><code>instanceof</code> 类型保护：类似于 <code>typeof</code>类型保护，TypeScript 会将其细化为其构造签名。</li>
</ul>
</blockquote>
<h4 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h4><p>类型别名会给一个类型起个新名字。 类型别名有时和接口很像，但是可以作用于原始值，联合类型，元组以及其它任何你需要手写的类型。</p>
<blockquote>
<p>个人感受：</p>
<p>类型别名最好配合联合类型或是交叉类型使用。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Name = string;</span><br><span class="line">type NameResolver = () =&gt; string;</span><br><span class="line">type NameOrResolver = nu | NameResolver;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>类型别名和接口区别：</p>
<ul>
<li>接口创建了新名称，可以在其它任何地方使用，而类型别名并没有创建新名字。</li>
<li>类型别名不能被 extends和 implements</li>
<li>接口不能用来描述一个联合类型或是元组类型</li>
</ul>
</blockquote>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><p>在 TypeScript 中可以通过，<strong>索引类型查询</strong> （<code>keyof T</code>） 和 <strong>索引访问 操作符</strong>（<code>T[K]</code>）进行类型判断处理。</p>
<blockquote>
<p>新版本貌似去掉了 keyof 关键词</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function pluck&lt;T, K extends keyof T&gt;(o: T, names: K[]): T[K][] &#123;</span><br><span class="line">  return names.map(n =&gt; o[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    age: number;</span><br><span class="line">&#125;</span><br><span class="line">let person: Person = &#123;</span><br><span class="line">    name: &apos;Jarid&apos;,</span><br><span class="line">    age: 35</span><br><span class="line">&#125;;</span><br><span class="line">let strings: string[] = pluck(person, [&apos;name&apos;]); // ok, string[]</span><br></pre></td></tr></table></figure>
<h3 id="Symbols"><a href="#Symbols" class="headerlink" title="Symbols"></a>Symbols</h3><p>自 ECMAScript 2015 起，<code>symbol</code> 成为了一种新的原生类型，就像 <code>number</code> 和 <code>string</code> 一样。</p>
<p>Symbols 是不可改变且唯一的。同时 Symbols 也可以用做对象的键值。在 ECMAScript 目前无私有属性的情况，下也用于定义私有属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sym2 = Symbol(&quot;key&quot;);</span><br><span class="line">let sym3 = Symbol(&quot;key&quot;);</span><br><span class="line"></span><br><span class="line">sym2 === sym3; // false, symbols是唯一的</span><br><span class="line"></span><br><span class="line">const name = Symbol()</span><br></pre></td></tr></table></figure>
<p>事实上，除了用户自定义的 symbol，语言内部也内置了一些 symbol 行为。其中 <code>for..of</code> 会遍历可迭代的对象，调用对象上的 <code>Symbol.iterator</code> 方法。</p>
<blockquote>
<p>需要注意的是：</p>
<p>当生成目标为ES5或ES3，迭代器只允许在Array类型上使用。 在非数组值上使用 for..of语句会得到一个错误，就算这些非数组值已经实现了Symbol.iterator属性。</p>
</blockquote>
]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript学习笔记·1</title>
    <url>/2020/04/07/2020/TypeScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%C2%B71/</url>
    <content><![CDATA[<p>了解 TypeScript 并加以使用，可以帮助我们提高代码的质量。本文主要是对官方文档上的内容进行个人理解后的知识收集，想了解更详细内容，推荐 <a href="https://www.typescriptlang.org/docs/handbook/basic-types.html" target="_blank" rel="noopener">TypeScript官网</a>。</p>
<blockquote>
<p><strong>tip:</strong> 在学习了解 TypeScript 的内容时，最好自己去实践一下。</p>
</blockquote>
<a id="more"></a>
<h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>在 TS 中，需要使用变量时，最好提前说明变量的类型。目前支持的类型有：</p>
<ul>
<li><strong>布尔值</strong> <code>let isBoolean: boolean = true;</code></li>
<li><strong>数字</strong> <code>let maxNum: number = 10;</code> (除了10进制外，还支持16进制、2进制和8进制字面量)</li>
<li><strong>字符串</strong> <code>let name: string = &#39;nimo&#39;;</code></li>
<li><strong>数组</strong> <code>let arr: number[] = [1, 2, 3];</code> 或 <code>let arr: Array&lt;number&gt; = [1, 2, 3]</code>;</li>
<li><strong>元组 Tuple</strong>：表示一个已知元素数量和类型的数组。 <code>let arr1: [string, number] = [&#39;hi&#39;, 12];</code> （当访问元组的元素超过预设边界时，该元素的类型会变为一个联合类型）</li>
<li><p><strong>枚举 Enum</strong>: 更为友好的赋值。</p>
  <figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">enmu Color &#123;Red, Green, Blue&#125;;</span><br><span class="line"><span class="keyword">let</span> bookColor: Color = Color.Green;</span><br><span class="line"><span class="comment">// 等价于 let bookColor: Color = Color[1];</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Any</strong>: 任意类型，主要在编程无法确认变量类型的情况下，支持动态设置。 <code>let resData: any = response.data;</code></p>
</li>
<li><strong>Void</strong>: 空类型，常用于无返回值的函数。<code>function warn(): void {}</code></li>
<li><strong>Null &amp; Undefined</strong>: 在 <code>--strictNullChecks</code> 模式下，它们只能被赋值给自己和 <code>void</code>。</li>
<li><strong>Never</strong>：表示永不存值，常用于会抛出异常或根本不存在返回值的函数表达式或者箭头函数  <code>const error: Function = function (msg): never { throw new Error(msg); }; };</code></li>
<li><strong>Object</strong>: 非原始类型，即 number，string，boolean，symbol，null 或 undefined 之外的类型。</li>
<li><strong>类型断言</strong>：对于明确了解的值的类型，可以使用类型断言进行类型转换，但不进行特殊数据检查和解构，它只会在编译阶段有效。其方式有：</li>
</ul>
<blockquote>
<ul>
<li>“尖括号”:</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let data: any = &apos;string&apos;;</span><br><span class="line">let len: number = (&lt;string&gt;data).length;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>“as 语法”：</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let data: any = &apos;string&apos;;</span><br><span class="line">let len: number = (data as string).length;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 TypeScript 中，可以将数组设置为只读，其效果与数组泛型 <code>Array&lt;Type&gt;</code> 相似，只是去掉了所有可变的方法，确保数组创建后不能被修改。 eg. <code>let arr: ReadonlyArray&lt;number&gt; = [1, 2, 3, 4];</code></p>
</blockquote>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>在 <code>ECMAScript</code> 中， <code>var</code> 变量声明的方式，作用于函数作用域，存在变量提升，同时容易引起误解。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 变量提升、函数作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getX</span>(<span class="params">hasInit</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasInit) &#123;</span><br><span class="line">        <span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line">getX(<span class="literal">true</span>); <span class="comment">// undefined</span></span><br><span class="line">getX(<span class="literal">false</span>); <span class="comment">// 10</span></span><br><span class="line">x <span class="comment">// Uncaught ReferenceError: x is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同一函数作用域</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;, <span class="number">100</span> * i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印结果并非我们期待的：0 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure>
<h4 id="let"><a href="#let" class="headerlink" title="let"></a>let</h4><p><code>let</code> 是 <strong>块级作用域</strong>（也叫词法作用域），在区块之外是不能访问的，同时也不能在声明之前进行读写操作（即虽然声明的变量始终存在于区块内，但是在声明前的代码区块都是属于 <strong>“暂时性死区”</strong>）。</p>
<p>在使用 <code>let</code> 的过程中，不能像 <code>var</code> 一样，使用 <code>let</code> 声明一个变量多次，也不能同时 <code>let</code> 和 <code>var</code> 声明同一个变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// let x = x; // Uncaught SyntaxError: Identifier 'x' has already been declared</span></span><br><span class="line">    <span class="comment">// console.log(a); // Uncaught ReferenceError: Cannot access 'a' before initialization</span></span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> b = x * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// console.log(b); // Uncaught ReferenceError: b is not defined</span></span><br><span class="line">    <span class="comment">// let a = 10; // Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br><span class="line">    <span class="comment">// var a = 20; // Uncaught SyntaxError: Identifier 'a' has already been declared</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果在嵌套的块级作用域，在不同的块级中，<code>let</code> 声明同名变量的话，内层的变量会 <strong>屏蔽</strong> 之前的变量。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let sum = 0;</span><br><span class="line">for (let i = 0; i &lt; matrix.length; i++) &#123;</span><br><span class="line">    let currentRow = matrix[i];</span><br><span class="line">    for (let i = 0; i &lt; currentRow.length; i++) &#123;</span><br><span class="line">        sum += currentRow[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p><code>const</code> 类似于 <code>let</code>，不同之处在于 <code>const</code> 声明的变量被赋值后就不能再改变。实际上 const 变量内部状态是可以修改的。</p>
<p>在 <code>typeScript</code> 中，请尽量使用 <code>let</code> 和 <code>const</code> 替代 <code>var</code> 。这样更容易推测数据的流动。</p>
<blockquote>
<p>除了 <code>let</code> 和 <code>const</code> 变量声明，<code>typescript</code> 还支持 ES6 语法中的，解析运算符和拓展运算符，支持 数组解构、对象解构 </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 数组解构 */</span></span><br><span class="line"><span class="keyword">let</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="built_in">console</span>.log(first); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(rest); <span class="comment">// [ 2, 3, 4 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对象解构 */</span></span><br><span class="line"><span class="keyword">let</span> &#123; a, ...restObj &#125; = &#123; <span class="attr">a</span>: <span class="string">'bax'</span>, <span class="attr">b</span>: <span class="number">101</span>, <span class="attr">c</span>: <span class="number">12</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 属性重命名 */</span></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">a</span>: s1, <span class="attr">b</span>: s2&#125;: &#123;<span class="attr">a</span>: string, <span class="attr">b</span>: number&#125; = &#123;<span class="attr">a</span>: <span class="string">'1'</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(s1); <span class="comment">// '1'</span></span><br><span class="line"><span class="built_in">console</span>.log(s2); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Waring</strong>：在进行没有声明的对象赋值时，需要用括号包起来，因为在 JavaScript 通常将 <code>{</code> 解析为一个块。eg. <code>({a, b} =  { a: &#39;bax&#39;, b: 101, c: 12 });</code> </p>
</blockquote>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口是 TypeScript 的核心之一，是一种额外的类型，主要用于结构类型检查，为这些类型命名和项目代码或第三方代码定义契约。</p>
<p>在使用接口过程中：1、可以通过在属性后添加 <code>?</code> 设置属性为可选。2、可以在属性名前用  <code>readonly</code> 来指定只读。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    x: number; // 必须属性</span><br><span class="line">    title?: string; // 可选属性</span><br><span class="line">    readonly y: number; // 只读属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 TypeScript 类型检查中，存在 <strong>额外的属性检查</strong>。即如果传入的参数存在接口声明中不存在的属性，TypeScript 就会报错。</p>
<ul>
<li>如果想要绕开这些检查，最简单的方法就是 <strong>使用类型断言</strong>。</li>
<li>如果一个对象上可能存在任意数量的其他属性，最佳的方法就是添加 <strong>字符串索引签名</strong>。</li>
<li>如果将对象赋值给变量，通过变量的方式传递参数，也不会经过额外属性检查。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Point &#123;</span><br><span class="line">    x: number;</span><br><span class="line">    y: number;</span><br><span class="line">    [propName: string]: any; // 利用字符串索引签名支持其他属性</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function createSquare (config: Point): &#123; area: number &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">let mySquare = createSquare(&#123;width: 10, x: 1, y: 2&#125; as Point); // 利用类型断言绕开检查</span><br><span class="line">let data = &#123;width: 10, x: 1, y: 2&#125;;</span><br><span class="line">let mySquare2 = createSquare(data);</span><br></pre></td></tr></table></figure>
<p>接口可以描述变量和参数，也可以用于描述函数的类型和类的类型。<br>除了变量、参数的类型检查外，接口 也常用于描述 函数 和 类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface isAdultFunc &#123;</span><br><span class="line">    (ages: number): boolean;</span><br><span class="line">&#125;</span><br><span class="line">let mySearch: SearchFunc = function (ages) &#123;</span><br><span class="line">    return ages &gt;= 18;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    setTime(d: Date): void;</span><br><span class="line">&#125;</span><br><span class="line">class Clock implements ClockInterface &#123;</span><br><span class="line">    currentTime: Date;</span><br><span class="line">    setTime(d: Date) &#123;</span><br><span class="line">        this.currentTime = d;</span><br><span class="line">    &#125;</span><br><span class="line">    constructor(h: number, m: number) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和类一样，接口也是能相互继承的。一个接口可以继承多个接口，这样可以更加灵活地分割到可重用的模块中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Shape &#123;</span><br><span class="line">    color: string;</span><br><span class="line">&#125;</span><br><span class="line">interface PenStroke &#123;</span><br><span class="line">    penWidth: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Square extends Shape, PenStroke &#123;</span><br><span class="line">    sideLength: number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口除了继承接口外，接口还可以继承类。接口继承类时，会继承类的成员但不包括其实现。就好像是声明了继承类中存在的成员，但不提供具体实现一样。（不建议这么使用，因为接口继承类时，也会继承类的 <code>private</code>  和 <code>protected</code> 成员，这也就意味着当你创建的接口击沉那个了一个拥有私有或者受保护的成员的类时，这个接口类型就只能被这个类或者其子类所实现）</p>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>ES6 目前已经支持 <code>class</code> 了，TypeScript 中的类和 ES6 语法类似。同时TypeScript 中类还支持 <code>public\private\protected</code> 等修饰符。</p>
<p>==<strong>注意：</strong>==</p>
<ul>
<li>在 <code>TypeScript</code> 中，成员默认视为 <code>public</code> 修饰符声明的 <strong>公共成员</strong>。</li>
<li>成员被标记为 <code>private</code> 时，该成员为 <strong>私有成员</strong> 就不能再声明它的类的外部访问。</li>
<li>成员被标记为 <code>protected</code> 时，其行为与 <code>private</code> 修饰符的行为很相似，但有一点不同，<strong>受保护成员</strong> 在派生类中仍然可以访问。</li>
<li>除了常用的 <code>public\private\protected</code> 修饰符，也可以通过 <code>readonly</code> 关键词将属性 <strong>成员设置为只读</strong>。这种只读的属性必须在声明时或构造函数中被初始化。</li>
<li>在 TypeScript 中使用 <code>getters/setters</code> <strong>存取器</strong> 来截取对象成员的访问和设置时，需将编译器的输出环境设置为 ECMAScript 5 或更高。其次，只拥有 <code>get</code> 而不带 <code>set</code> 的存取器会被自动推断为 <code>readonly</code>。</li>
<li>成员被标记为 <code>static</code> 时，该成员即为 <strong>静态成员</strong>。实例对象中的方法如果需要访问这个属性的时候需要在前面加上类名，如同在实例中使用 <code>this.</code> 前缀访问属性一样。</li>
</ul>
<blockquote>
<p><strong>tips:</strong></p>
<ul>
<li>在 TypeScript 的类中可以通过 <strong>参数属性</strong> （即通过在构造函数参数前添加一个访问限定符来声明）的方式来快速声明并初始化一个参数。</li>
<li>在 TypeScript 中，可通过 <code>abstract</code> 关键词，定义 <strong>抽象类</strong> 和内部的抽象方法。抽象类一般不会直接实例化。不同于接口的是，抽象类可以包含成员实现细节。需要注意的是，抽象类的抽象方法类似于接口的语法，不包含具体实现，其派生类中必须实现该方法。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    name: string;</span><br><span class="line">    provite ages: number;</span><br><span class="line">    protected sex: string;</span><br><span class="line">    readonly maxAges: number = 100;</span><br><span class="line">    static ancestor = &apos;ape man&apos;;</span><br><span class="line">    constructor(readonly minAges: number = 0) &#123; // 等价于声明了一个只读属性 minAges，并通过参数赋值</span><br><span class="line">    &#125;</span><br><span class="line">    getHi() &#123;</span><br><span class="line">        return `hi $&#123;this.name | Person.ancestor&#125;`;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>在 TypeScript 中类和 ES6 一样，可以通过 <code>extends</code> 关键词进行继承，同时子类（又被称为 派生类）的构造函数必需调用 <code>super()</code> 执行父类（又称为基类、超类）的构造函数。</p>
<blockquote>
<p>在继承时，如果访问 <code>this</code> 属性，一定需要在调用 <code>super()</code> 之后。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abstract class Animal &#123;</span><br><span class="line">    static hi = &apos;hi&apos;;</span><br><span class="line">    constructor(public name: string) &#123; &#125;</span><br><span class="line">    abstract makeSound(): void;</span><br><span class="line">    move(): void &#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125; is moving...`);</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi(): void &#123;</span><br><span class="line">        console.log(Animal.hi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line">    constructor(name: string) &#123;</span><br><span class="line">		super(name);</span><br><span class="line">	&#125;</span><br><span class="line">	makeSound() &#123;</span><br><span class="line">		console.log(&apos;wow&apos;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let dog: Dog; // 表示 Dog 的实例的类型是 Dog</span><br><span class="line">dog = new Dog(&apos;DOG&apos;);</span><br><span class="line"></span><br><span class="line">let DogMaker: typeof Dog = Dog; // typeof Dog 表示取 Dog 类的类型，而不是实例类型。</span><br><span class="line">DogMaker.hi = &apos;Hello&apos;;</span><br><span class="line"></span><br><span class="line">let dog2: Dog = new DogMaker(&apos;DOG&apos;);</span><br><span class="line">console.log(dog2.sayHi());</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>TypeScript 可以为函数定义类型。一个完整的函数类型包含两部分：参数类型和返回值类型。对于返回值，在函数和返回值类型之前使用 <code>=&gt;</code> 可以使之清晰，如果没有返回值，需指定返回值类型为 <code>void</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let myAdd: (baseValue: number, increment: number) =&gt; number =</span><br><span class="line">    function(x: number, y: number): number &#123; return x + y; &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="this"><a href="#this" class="headerlink" title="this"></a>this</h4><p>在 JavaScript 中，<code>this</code> 的值只会在函数被调用时才能确定。在 TypeScript 中，为了避免代码歧义，可以提供一个显式的 <code>this</code> <strong>参数</strong>。 这个 <code>this</code> 参数是一个假的参数，它出现在参数列表的最前面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Card &#123;</span><br><span class="line">    suit: string;</span><br><span class="line">    card: number;</span><br><span class="line">&#125;</span><br><span class="line">interface Deck &#123;</span><br><span class="line">    suits: string[];</span><br><span class="line">    cards: number[];</span><br><span class="line">    createCardPicker(this: Deck): () =&gt; Card;</span><br><span class="line">&#125;</span><br><span class="line">let deck: Deck = &#123;</span><br><span class="line">    suits: [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;],</span><br><span class="line">    cards: Array(52),</span><br><span class="line">    // NOTE: The function now explicitly specifies that its callee must be of type Deck</span><br><span class="line">    createCardPicker: function(this: Deck) &#123;</span><br><span class="line">        return () =&gt; &#123;</span><br><span class="line">            let pickedCard = Math.floor(Math.random() * 52);</span><br><span class="line">            let pickedSuit = Math.floor(pickedCard / 13);</span><br><span class="line"></span><br><span class="line">            return &#123;suit: this.suits[pickedSuit], card: pickedCard % 13&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cardPicker = deck.createCardPicker();</span><br><span class="line">let pickedCard = cardPicker();</span><br><span class="line"></span><br><span class="line">alert(&quot;card: &quot; + pickedCard.card + &quot; of &quot; + pickedCard.suit);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ul>
<li>箭头函数不会捕获 <code>this</code>（箭头函数会保存函数创建时的 <code>this</code>）。</li>
<li>如果期待的回调函数不要求 <code>this</code>，可以在回调函数类型声明中使用 <code>this: void</code> 表示回调函数不要求 <code>this</code>，避免出现调用错误。</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface CustomEvent &#123;</span><br><span class="line">	message: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function addCustomEventListener(callback: (this: void, e: CustomEvent) =&gt; void): void &#123;</span><br><span class="line">	// todos</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Handler &#123;</span><br><span class="line">    info: string;</span><br><span class="line">    onEvent(this: Handler, e: CustomEvent) &#123;</span><br><span class="line">        // oops, used this here. using this callback would crash at runtime</span><br><span class="line">        this.info = e.message;</span><br><span class="line">    &#125;</span><br><span class="line">    onError = (e: CustomEvent) =&gt; &#123;</span><br><span class="line">        // this 不会被捕获。缺点：1、每个实例都会创建一个箭头函数</span><br><span class="line">        this.info = e.message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let h = new Handler();</span><br><span class="line">// addCustomEventListener(h.onEvent); // error!</span><br><span class="line">addCustomEventListener(h.onError); // ok!</span><br></pre></td></tr></table></figure>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>在 JavaScript 中依据不同的参数而返回不同的结果是很常见的。在 TypeScript 中为了避免出现代码混乱，可以通过重载的方式声明函数的参数和返回结果，这样就可以检查是否有错误调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">interface Card &#123;</span><br><span class="line">	suit: string,</span><br><span class="line">	card: number,</span><br><span class="line">&#125;</span><br><span class="line">let suits: Array&lt;string&gt; = [&quot;hearts&quot;, &quot;spades&quot;, &quot;clubs&quot;, &quot;diamonds&quot;];</span><br><span class="line">function pickCard(x: Card[]): number;</span><br><span class="line">function pickCard(x: number): Card;</span><br><span class="line">function pickCard(x: any): any &#123;</span><br><span class="line">	if (typeof x === &apos;object&apos; &amp;&amp; x !== null) &#123;</span><br><span class="line">		let pickedCard = Math.floor(Math.random() * x.length);</span><br><span class="line">		return pickedCard;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (typeof x === &apos;number&apos;) &#123;</span><br><span class="line">		let pickedSuit = Math.floor(x / 13);</span><br><span class="line">		return &#123; suit: suits[pickedSuit], card: x % 13 &#125;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pickCard(&apos;2&apos;) // Error: No overload matches this call</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ul>
<li>编译器检查类型时，查找重载列表会尝试使用第一个重载定义，如果匹配就使用这个。因此在重载时，一定要将最精确的定义放在前面。</li>
<li><code>function pickCard(x): any</code> 并不是重载列表的一部分，因此这里只有两个重载：一个是接收对象另一个接收数字。 以其它参数调用 pickCard 会产生错误。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>前端工具</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title>前端CSS试题</title>
    <url>/2020/10/09/blog/fe-questions/%E5%89%8D%E7%AB%AFCSS%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>收集了解前端试题，温故而知新！！！</p>
<a id="more"></a>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li><a href="#l1">1. css盒子模型，box-sizing属性的理解</a></li>
<li><a href="#l2">2. 清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法</a></li>
<li><a href="#l3">3. 如何让一个不定宽高的盒子水平垂直居中</a></li>
<li><a href="#l4">4. px、em 和 rem 的区别</a></li>
<li><a href="#l5">5. position 各个定位的区别</a></li>
<li><a href="#l6">6. display:none 与 visibility：hidden 的区别</a></li>
<li><a href="#l7">7. CSS 中 link 和 @import 的区别</a></li>
<li><a href="#l8">8. 什么是响应式设计，响应式设计的基本原理是什么</a></li>
<li><a href="#l9">9. 为什么要初始化CSS样式</a></li>
<li><a href="#l10">10. CSS3有哪些新特性</a></li>
<li><a href="#l11">11. ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用</a></li>
<li><a href="#l12">12. CSS优化、提高性能的方法有哪些</a></li>
<li><a href="#l13">13. 重绘和回流</a></li>
<li><a href="#l14">14. flex 布局</a></li>
<li><a href="#l15">15. grid 布局</a></li>
<li><a href="#l16">16. css预处理器</a></li>
</ul>
<h4 id="l1">1. css盒子模型，box-sizing属性的理解</h4>

<p>css盒子模型：margin + border + padding + content （由外到内）</p>
<p><code>box-sizing: content-box(默认) | border-box | inherit;</code> 是 css3 的属性，主要是设置盒子的宽度时，是否仅包含 <code>content</code> 。</p>
<h4 id="l2">2. 清除浮动，什么时候需要清除浮动，清除浮动都有哪些方法</h4>

<p>浮动的元素是脱离文档标准流的。如果不进行清除浮动，会造成父元素高度塌陷，影响页面的布局。</p>
<p><strong>清除浮动的方式：</strong></p>
<ul>
<li>给父元素设置高度。（缺点：需要提前知道父元素需要的高度）</li>
<li>给父元素设置 <code>overflow: hidden;</code> （BFC独立盒子）</li>
<li>给父元素的伪类设置 <code>clear: both;</code> （更符合语义化）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 伪类 */</span></span><br><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>BFC：</strong>（overflow: hidden 可以触发 BFC 机制）</p>
<p>块级格式化上下文，创建了 BFC 的元素就是一个独立的盒子，它规定了内部如何布局，并且与这个独立盒子里的布局不受外部影响，当然它也不会影响到外面的元素，计算BFC的高度时，浮动元素也参与计算。</p>
</blockquote>
<h4 id="l3">3. 如何让一个不定宽高的盒子水平垂直居中</h4>

<ul>
<li>table-cell + text-align （不再推荐）</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>绝对定位 + 移动</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>flex 布局</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>grid 布局</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: grid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">    <span class="attribute">justify-self</span>: center;</span><br><span class="line">    <span class="attribute">align-self</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="l4">4. px、em 和 rem 的区别</h4>

<ul>
<li><code>px</code>: 像素，相对长度单位。像素 <code>px</code> 是相对于显示器屏幕分辨率而言的。</li>
<li><code>em</code> 的值并不是固定的，会继承父级元素的字体大小，代表倍数。</li>
<li><code>rem</code>的值并不是固定的，始终是基于根元素 <code>&lt;html&gt;</code> 的，也代表倍数。</li>
</ul>
<h4 id="l5">5. position 各个定位的区别</h4>

<ul>
<li><code>static</code>： 默认值。没有定位，元素出现在正常的流中</li>
<li><code>relative</code>（相对定位）：生成相对定位的元素,相对于其正常（原先本身）位置进行定位</li>
<li><code>absolute</code>（绝对定位）：生成绝对定位的元素，相对于static定位以外的第一个父元素进行定位</li>
<li><code>fixed</code>（固定定位）：生成绝对定位的元素，相对于浏览器窗口进行定位</li>
<li><code>sticky</code> (粘性定位)：基于用户的滚动位置来定位，粘性定位的元素是依赖于用户的滚动，在 position:relative 与 position:fixed 定位之间切换。</li>
</ul>
<blockquote>
<p>关于 <code>position: sticky;</code> 可参考，<a href="https://www.zhangxinxu.com/wordpress/2018/12/css-position-sticky/" target="_blank" rel="noopener">杀了个回马枪，还是说说position:sticky吧</a></p>
</blockquote>
<h4 id="l6">6. display:none 与 visibility：hidden 的区别</h4>

<table>
<thead>
<tr>
<th>区别</th>
<th>display: none;</th>
<th>visibility: hidden;</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否占据空间</td>
<td>不占据任何空间，在文档渲染时，该元素如同不存在（但依然存在文档对象模型树中）</td>
<td>该元素空间依旧存在</td>
</tr>
<tr>
<td>是否渲染</td>
<td>会触发 reflow（回流），进行渲染</td>
<td>会触发 repaint（重绘），因为没有发现位置变化，不进行渲染</td>
</tr>
<tr>
<td>是否是继承属性</td>
<td>不是继承属性，元素及其子元素都会消失</td>
<td>是继承属性，若子元素使用了visibility:visible，则不继承，这个子孙元素又会显现出</td>
</tr>
</tbody>
</table>
<h4 id="l7">7. CSS 中 link 和 @import 的区别</h4>

<ul>
<li><strong>所属不同：</strong> link 属于 XHTML 标签，主要是用于定义文档与外部资源的关系，而 @import 完全是 CSS 提供的一种加载 CSS 的方式。</li>
<li><strong>加载顺序不同：</strong> 当页面被加载时，link 引用的 CSS 会被同时加载，而 @import 引用的 CSS 会等到页面全部被下载完成后再加载。</li>
<li><strong>兼容性不同（不再考虑）：</strong> @import 是 CSS 2.1 的内容。</li>
<li>当使用 JavaScript 控制 DOM 改变样式时，只是使用 link 的方式，无法使用 @import 。</li>
</ul>
<h4 id="l8">8. 什么是响应式设计，响应式设计的基本原理是什么</h4>

<p>响应式网站设计是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p>
<p>基本原理是通过媒体查询检测不同的设备屏幕尺寸做对应处理。</p>
<h4 id="l9">9. 为什么要初始化CSS样式</h4>

<ul>
<li><strong>兼容性处理：</strong> 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对 CSS 初始化往往会出现浏览器之间的页面显示差异。</li>
<li><strong>SEO：</strong> 初始化样式会对 SEO 有一定的影响</li>
</ul>
<blockquote>
<p><strong>补充说明：</strong></p>
<ul>
<li><code>* {padding: 0; margin: 0;}</code> 这种初始化的方式，在应用较大、css样式较多时，<code>*</code> 会将所有便签初始化一次。</li>
</ul>
</blockquote>
<h4 id="l10">10. CSS3有哪些新特性</h4>

<ul>
<li>实现圆角 <code>border-radius</code>，阴影 <code>box-shadow</code>，边框图片 <code>border-image</code></li>
<li>对文字加特效 <code>text-shadow</code>，强制文本换行 <code>word-wrap</code>，线性渐变 <code>linear-gradient</code></li>
<li>实现旋转 <code>transform:rotate(90deg)</code>, 缩放 <code>scale(0.85,0.90)</code>, <code>translate(0px,-30px)</code> 定位,倾斜 <code>skew(-9deg,0deg)</code>;</li>
<li>增加了更多的CSS选择器、多背景、<code>rgba()</code></li>
<li>唯一引入的伪元素是 <code>::selection</code>；</li>
<li>实现媒体查询 <code>@media</code>，多栏布局 <code>flex</code></li>
<li>过渡 <code>transition</code> 动画 <code>animation</code></li>
</ul>
<h4 id="l11">11. ::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用</h4>

<p>单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）,双冒号是在当前规范中引入的，用于区分伪类和伪元素。</p>
<h4 id="l12">12. CSS优化、提高性能的方法有哪些</h4>

<ul>
<li>移除空的css规则（Remove empty rules）</li>
<li>正确使用 display 的属性</li>
<li>不滥用浮动、web字体</li>
<li>不声明过多的 font-size</li>
<li>不在选择符中使用ID标识符</li>
<li>遵守盒模型规则</li>
<li>尽量减少页面重排、重绘</li>
<li>抽象提取公共样式，减少代码量</li>
</ul>
<h4 id="l13">13. 重绘和回流</h4>

<p>回流一定会引起重绘，重绘不一定引起回流</p>
<p>具体请看：<a href="https://yiqingfeng.github.io/2019/06/17/2019-2/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98/">浏览器的重绘和回流</a></p>
<h4 id="l14">14. flex弹性布局</h4>

<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt></p>
<p><strong>flex 容器的属性：</strong></p>
<ul>
<li><code>flex-direction</code> 决定主轴排列方向，默认为 <code>row</code> 水平从左至右。</li>
<li><code>flex-wrap</code> 决定是否换行，以及如何换行，默认为 <code>nowrap</code> 不换行。</li>
<li><code>flex-flow</code> 即为<code>flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</code></li>
<li><code>justify-content</code> 决定子元素在主轴上的对齐方式，默认为 <code>flex-start</code> 左对齐。</li>
<li><code>align-items</code> 决定子元素在交叉轴上的对齐方式，默认为 <code>stretch</code> 占满整个容器高度。</li>
<li><code>align-content</code> 决定当存在多个轴线，即子元素分多行时的对齐方式，默认为 <code>stretch</code> 子元素将占满整个容器高度。</li>
</ul>
<p><strong>flex 子元素的属性：</strong></p>
<ul>
<li><code>order</code> 决定了元素的排列顺序，默认为 0。</li>
<li><code>flex-grow</code> 决定子元素的放大比例，默认为 0，即存在空余空间时，也不进行放大。</li>
<li><code>flex-shrink</code> 决定子元素的缩小比例，默认为 1，该属性不能设置为负值。</li>
<li><code>flex-basis</code> 决定分配多余空间前，子元素占据的主轴空间，默认为 <code>auto</code>，即元素的本身大小。</li>
<li><code>flex</code> 即为 <code>flex: &lt;flex-grow&gt; &lt;flex-shrink&gt;? || &lt;flex-basis&gt; ]</code>，该属性可以简写为 <code>auto (1 1 auto)</code> 和 <code>none (0 0 auto)</code></li>
<li><code>align-self</code> 元素的对齐方式，默认为 <code>auto</code>，表示继承父元素的 <code>align-items</code> 属性</li>
</ul>
<blockquote>
<p>注意：</p>
<p>设置为 <code>Flex</code> 布局后，子元素的 <code>float</code>、<code>clear</code> 和 <code>vertical-align</code> 属性将失效。</p>
</blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">flex布局教程–阮一峰</a></p>
<h4 id="l15">15. grid 网格布局</h4>

<p><a href="http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html" target="_blank" rel="noopener">Grid网格布局教程–阮一峰</a></p>
<h4 id="l16">16. css预处理器</h4>

<ul>
<li>less</li>
<li>sass</li>
<li>postcss</li>
<li>…</li>
</ul>
]]></content>
      <categories>
        <category>前端面试</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
